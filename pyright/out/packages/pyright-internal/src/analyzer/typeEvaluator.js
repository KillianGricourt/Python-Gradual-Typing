"use strict";
/*
 * typeEvaluator.ts
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 * Author: Eric Traut
 *
 * Module that evaluates types of parse tree nodes within
 * a program.
 *
 * Note: This is a gargantuan module - much larger than I would
 * normally create. It is written this way primarily for performance,
 * with the internal methods having access to the full closure of
 * the createTypeEvaluator function. This is the same approach
 * taken by the TypeScript compiler.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTypeEvaluator = exports.maxCodeComplexity = void 0;
const cancellationUtils_1 = require("../common/cancellationUtils");
const collectionUtils_1 = require("../common/collectionUtils");
const debug_1 = require("../common/debug");
const diagnostic_1 = require("../common/diagnostic");
const diagnosticRules_1 = require("../common/diagnosticRules");
const positionUtils_1 = require("../common/positionUtils");
const pythonVersion_1 = require("../common/pythonVersion");
const textRange_1 = require("../common/textRange");
const uri_1 = require("../common/uri/uri");
const localize_1 = require("../localization/localize");
const parseNodes_1 = require("../parser/parseNodes");
const parser_1 = require("../parser/parser");
const analyzerFileInfo_1 = require("./analyzerFileInfo");
const AnalyzerNodeInfo = __importStar(require("./analyzerNodeInfo"));
const codeFlowEngine_1 = require("./codeFlowEngine");
const codeFlowTypes_1 = require("./codeFlowTypes");
const constraintSolver_1 = require("./constraintSolver");
const constructors_1 = require("./constructors");
const dataClasses_1 = require("./dataClasses");
const declarationUtils_1 = require("./declarationUtils");
const decorators_1 = require("./decorators");
const enums_1 = require("./enums");
const functionTransform_1 = require("./functionTransform");
const namedTuples_1 = require("./namedTuples");
const operations_1 = require("./operations");
const parameterUtils_1 = require("./parameterUtils");
const ParseTreeUtils = __importStar(require("./parseTreeUtils"));
const patternMatching_1 = require("./patternMatching");
const properties_1 = require("./properties");
const protocols_1 = require("./protocols");
const ScopeUtils = __importStar(require("./scopeUtils"));
const staticExpressions_1 = require("./staticExpressions");
const symbol_1 = require("./symbol");
const symbolNameUtils_1 = require("./symbolNameUtils");
const symbolUtils_1 = require("./symbolUtils");
const typeCacheUtils_1 = require("./typeCacheUtils");
const typeEvaluatorTypes_1 = require("./typeEvaluatorTypes");
const TypePrinter = __importStar(require("./typePrinter"));
const typeUtils_1 = require("./typeUtils");
const typeVarContext_1 = require("./typeVarContext");
const typedDicts_1 = require("./typedDicts");
const types_1 = require("./types");
// This table contains the names of several built-in types that
// are not subscriptable at runtime on older versions of Python.
// It lists the first version of Python where subscripting is
// allowed.
const nonSubscriptableBuiltinTypes = new Map([
    ['asyncio.futures.Future', pythonVersion_1.pythonVersion3_9],
    ['asyncio.tasks.Task', pythonVersion_1.pythonVersion3_9],
    ['builtins.dict', pythonVersion_1.pythonVersion3_9],
    ['builtins.frozenset', pythonVersion_1.pythonVersion3_9],
    ['builtins.list', pythonVersion_1.pythonVersion3_9],
    ['builtins._PathLike', pythonVersion_1.pythonVersion3_9],
    ['builtins.set', pythonVersion_1.pythonVersion3_9],
    ['builtins.tuple', pythonVersion_1.pythonVersion3_9],
    ['collections.ChainMap', pythonVersion_1.pythonVersion3_9],
    ['collections.Counter', pythonVersion_1.pythonVersion3_9],
    ['collections.defaultdict', pythonVersion_1.pythonVersion3_9],
    ['collections.DefaultDict', pythonVersion_1.pythonVersion3_9],
    ['collections.deque', pythonVersion_1.pythonVersion3_9],
    ['collections.OrderedDict', pythonVersion_1.pythonVersion3_9],
    ['queue.Queue', pythonVersion_1.pythonVersion3_9],
]);
// Some types that do not inherit from others are still considered
// "compatible" based on the Python spec. These are sometimes referred
// to as "type promotions".
const typePromotions = new Map([
    ['builtins.float', ['builtins.int']],
    ['builtins.complex', ['builtins.float', 'builtins.int']],
    ['builtins.bytes', ['builtins.bytearray', 'builtins.memoryview']],
]);
// How many levels deep should we attempt to infer return
// types based on call-site argument types? The deeper we go,
// the more types we may be able to infer, but the worse the
// performance.
const maxReturnTypeInferenceStackSize = 2;
// What is the max number of input arguments we should allow
// for call-site return type inference? We've found that large,
// complex functions with many arguments can take too long to
// analyze.
const maxReturnTypeInferenceArgumentCount = 6;
// What is the max complexity of the code flow graph that
// we will analyze to determine the return type of a function
// when its parameters are unannotated? We want to keep this
// pretty low because this can be very costly.
const maxReturnTypeInferenceCodeFlowComplexity = 32;
// What is the max complexity of the code flow graph for
// call-site type inference? This is very expensive, so we
// want to keep this very low.
const maxReturnCallSiteTypeInferenceCodeFlowComplexity = 8;
// What is the max number of return types cached per function
// when using call-site inference?
const maxCallSiteReturnTypeCacheSize = 8;
// How many entries in a list, set, or dict should we examine
// when inferring the type? We need to cut it off at some point
// to avoid excessive computation.
const maxEntriesToUseForInference = 64;
// How many assignments to an unannotated variable should be used
// when inferring its type? We need to cut it off at some point
// to avoid excessive computation.
const maxDeclarationsToUseForInference = 64;
// Maximum number of times to attempt effective type evaluation
// of a variable that has no type declaration.
const maxEffectiveTypeEvaluationAttempts = 16;
// Maximum number of combinatoric union type expansions allowed
// when resolving an overload.
const maxOverloadUnionExpansionCount = 64;
// Maximum number of recursive function return type inference attempts
// that can be concurrently pending before we give up.
const maxInferFunctionReturnRecursionCount = 12;
// In certain loops, it's possible to construct arbitrarily-deep containers
// (tuples, lists, sets, or dicts) which can lead to infinite type analysis.
// This limits the depth.
const maxInferredContainerDepth = 8;
// Maximum recursion amount when comparing two recursive type aliases.
// Increasing this can greatly increase the time required to evaluate
// two recursive type aliases that have the same definition. Decreasing
// it can increase the chance of false negatives for such recursive
// type aliases.
const maxRecursiveTypeAliasRecursionCount = 10;
// This switch enables a special debug mode that attempts to catch
// bugs due to inconsistent evaluation flags used when reading types
// from the type cache.
const verifyTypeCacheEvaluatorFlags = false;
// This debugging option prints each expression and its evaluated type.
const printExpressionTypes = false;
// The following number is chosen somewhat arbitrarily. We need to cut
// off code flow analysis at some point for code flow graphs that are too
// complex. Otherwise we risk overflowing the stack or incurring extremely
// long analysis times. This number has been tuned empirically.
exports.maxCodeComplexity = 768;
function createTypeEvaluator(importLookup, evaluatorOptions, wrapWithLogger) {
    const symbolResolutionStack = [];
    const asymmetricAccessorAssignmentCache = new Set();
    const speculativeTypeTracker = new typeCacheUtils_1.SpeculativeTypeTracker();
    const suppressedNodeStack = [];
    const assignClassToSelfStack = [];
    let functionRecursionMap = new Set();
    let codeFlowAnalyzerCache = new Map();
    let typeCache = new Map();
    let effectiveTypeCache = new Map();
    let expectedTypeCache = new Map();
    let deferredClassCompletions = [];
    let cancellationToken;
    let printExpressionSpaceCount = 0;
    let incompleteGenerationCount = 0;
    const returnTypeInferenceContextStack = [];
    let returnTypeInferenceTypeCache;
    let isPrefetchedTypesInitialized = false;
    // Various types prefetched from stdlib stubs
    let noneTypeClass;
    let objectClass;
    let typeClass;
    let unionTypeClass;
    let awaitableClass;
    let functionClass;
    let tupleClass;
    let boolClass;
    let intClass;
    let strClass;
    let dictClass;
    let typedDictPrivateClass;
    let supportsKeysAndGetItemClass;
    let mappingClass;
    function runWithCancellationToken(token, callback) {
        try {
            cancellationToken = token;
            return callback();
        }
        finally {
            cancellationToken = undefined;
        }
    }
    function checkForCancellation() {
        if (cancellationToken) {
            (0, cancellationUtils_1.throwIfCancellationRequested)(cancellationToken);
        }
    }
    function getTypeCacheEntryCount() {
        return typeCache.size;
    }
    // This function should be called immediately prior to discarding
    // the type evaluator. It forcibly replaces existing cache maps
    // with empty equivalents. This shouldn't be necessary, but there
    // is apparently a bug in the v8 GC where it is unable to detect
    // circular references in complex data structures, so it fails
    // to clean up the objects if we don't help it out.
    function disposeEvaluator() {
        functionRecursionMap = new Set();
        codeFlowAnalyzerCache = new Map();
        typeCache = new Map();
        effectiveTypeCache = new Map();
        expectedTypeCache = new Map();
    }
    function readTypeCacheEntry(node) {
        // Should we use a temporary cache associated with a contextual
        // analysis of a function, contextualized based on call-site argument types?
        if (returnTypeInferenceTypeCache && isNodeInReturnTypeInferenceContext(node)) {
            return returnTypeInferenceTypeCache.get(node.id);
        }
        else {
            return typeCache.get(node.id);
        }
    }
    function isTypeCached(node) {
        const cacheEntry = readTypeCacheEntry(node);
        if (!cacheEntry) {
            return false;
        }
        return (!cacheEntry.typeResult.isIncomplete || cacheEntry.incompleteGenerationCount === incompleteGenerationCount);
    }
    function readTypeCache(node, flags) {
        var _a, _b;
        const cacheEntry = readTypeCacheEntry(node);
        if (!cacheEntry || cacheEntry.typeResult.isIncomplete) {
            return undefined;
        }
        if (evaluatorOptions.verifyTypeCacheEvaluatorFlags || verifyTypeCacheEvaluatorFlags) {
            if (flags !== undefined) {
                const expectedFlags = cacheEntry.flags;
                if (expectedFlags !== undefined && flags !== expectedFlags) {
                    const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
                    const position = (0, positionUtils_1.convertOffsetToPosition)(node.start, fileInfo.lines);
                    const message = `Type cache flag mismatch for node type ${node.nodeType} ` +
                        `(parent ${(_b = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.nodeType) !== null && _b !== void 0 ? _b : 'none'}): ` +
                        `cached flags = ${expectedFlags}, access flags = ${flags}, ` +
                        `file = {${fileInfo.fileUri} [${position.line + 1}:${position.character + 1}]}`;
                    if (evaluatorOptions.verifyTypeCacheEvaluatorFlags) {
                        (0, debug_1.fail)(message);
                    }
                    else {
                        console.log(message);
                    }
                }
            }
        }
        return cacheEntry.typeResult.type;
    }
    function writeTypeCache(node, typeResult, flags, inferenceContext, allowSpeculativeCaching = false) {
        // Should we use a temporary cache associated with a contextual
        // analysis of a function, contextualized based on call-site argument types?
        const typeCacheToUse = returnTypeInferenceTypeCache && isNodeInReturnTypeInferenceContext(node)
            ? returnTypeInferenceTypeCache
            : typeCache;
        if (!typeResult.isIncomplete) {
            incompleteGenerationCount++;
        }
        else {
            const oldValue = typeCacheToUse.get(node.id);
            if (oldValue !== undefined && !(0, types_1.isTypeSame)(typeResult.type, oldValue.typeResult.type)) {
                incompleteGenerationCount++;
            }
        }
        typeCacheToUse.set(node.id, { typeResult, flags, incompleteGenerationCount: incompleteGenerationCount });
        // If the entry is located within a part of the parse tree that is currently being
        // "speculatively" evaluated, track it so we delete the cached entry when we leave
        // this speculative context.
        if (isSpeculativeModeInUse(node)) {
            speculativeTypeTracker.trackEntry(typeCacheToUse, node.id);
            if (allowSpeculativeCaching) {
                speculativeTypeTracker.addSpeculativeType(node, typeResult, incompleteGenerationCount, inferenceContext === null || inferenceContext === void 0 ? void 0 : inferenceContext.expectedType);
            }
        }
    }
    function setTypeResultForNode(node, typeResult, flags = 0 /* EvalFlags.None */) {
        writeTypeCache(node, typeResult, flags);
    }
    function setAsymmetricDescriptorAssignment(node) {
        if (isSpeculativeModeInUse(/* node */ undefined)) {
            return;
        }
        asymmetricAccessorAssignmentCache.add(node.id);
    }
    function isAsymmetricAccessorAssignment(node) {
        return asymmetricAccessorAssignmentCache.has(node.id);
    }
    // Determines whether the specified node is contained within
    // the function node corresponding to the function that we
    // are currently analyzing in the context of parameter types
    // defined by a call site.
    function isNodeInReturnTypeInferenceContext(node) {
        const stackSize = returnTypeInferenceContextStack.length;
        if (stackSize === 0) {
            return false;
        }
        const contextNode = returnTypeInferenceContextStack[stackSize - 1];
        let curNode = node;
        while (curNode) {
            if (curNode === contextNode.functionNode) {
                return true;
            }
            curNode = curNode.parent;
        }
        return false;
    }
    function getCodeFlowAnalyzerForReturnTypeInferenceContext() {
        const stackSize = returnTypeInferenceContextStack.length;
        (0, debug_1.assert)(stackSize > 0);
        const contextNode = returnTypeInferenceContextStack[stackSize - 1];
        return contextNode.codeFlowAnalyzer;
    }
    function getIndexOfSymbolResolution(symbol, declaration) {
        return symbolResolutionStack.findIndex((entry) => entry.symbolId === symbol.id && entry.declaration === declaration);
    }
    function pushSymbolResolution(symbol, declaration) {
        const index = getIndexOfSymbolResolution(symbol, declaration);
        if (index >= 0) {
            // Mark all of the entries between these two as invalid.
            for (let i = index + 1; i < symbolResolutionStack.length; i++) {
                symbolResolutionStack[i].isResultValid = false;
            }
            return false;
        }
        symbolResolutionStack.push({
            symbolId: symbol.id,
            declaration,
            isResultValid: true,
        });
        return true;
    }
    function popSymbolResolution(symbol) {
        const poppedEntry = symbolResolutionStack.pop();
        (0, debug_1.assert)(poppedEntry.symbolId === symbol.id);
        return poppedEntry.isResultValid;
    }
    function setSymbolResolutionPartialType(symbol, declaration, type) {
        const index = getIndexOfSymbolResolution(symbol, declaration);
        if (index >= 0) {
            symbolResolutionStack[index].partialType = type;
        }
    }
    function getSymbolResolutionPartialType(symbol, declaration) {
        const index = getIndexOfSymbolResolution(symbol, declaration);
        if (index >= 0) {
            return symbolResolutionStack[index].partialType;
        }
        return undefined;
    }
    // Determines the type of the specified node by evaluating it in
    // context, logging any errors in the process. This may require the
    // type of surrounding statements to be evaluated.
    function getType(node) {
        var _a, _b;
        initializePrefetchedTypes(node);
        let type = (_a = evaluateTypeForSubnode(node, () => {
            evaluateTypesForExpressionInContext(node);
        })) === null || _a === void 0 ? void 0 : _a.type;
        // If this is a type parameter with a calculated variance, see if we
        // can swap it out for a version that has a computed variance.
        if (type && (0, types_1.isTypeVar)(type) && type.details.declaredVariance === 0 /* Variance.Auto */) {
            const typeVarType = type;
            const typeParamListNode = ParseTreeUtils.getParentNodeOfType(node, 76 /* ParseNodeType.TypeParameterList */);
            if (((_b = typeParamListNode === null || typeParamListNode === void 0 ? void 0 : typeParamListNode.parent) === null || _b === void 0 ? void 0 : _b.nodeType) === 10 /* ParseNodeType.Class */) {
                const classTypeResult = getTypeOfClass(typeParamListNode.parent);
                if (classTypeResult) {
                    inferTypeParameterVarianceForClass(classTypeResult.classType);
                    const typeParam = classTypeResult.classType.details.typeParameters.find((param) => (0, types_1.isTypeSame)(param, typeVarType, { ignoreTypeFlags: true }));
                    if (typeParam) {
                        type = types_1.TypeBase.isInstance(type) ? types_1.TypeVarType.cloneAsInstance(typeParam) : typeParam;
                    }
                }
            }
        }
        if (type) {
            type = (0, typeUtils_1.transformPossibleRecursiveTypeAlias)(type);
        }
        return type;
    }
    function getTypeResult(node) {
        return evaluateTypeForSubnode(node, () => {
            evaluateTypesForExpressionInContext(node);
        });
    }
    function getTypeResultForDecorator(node) {
        return evaluateTypeForSubnode(node, () => {
            evaluateTypesForExpressionInContext(node.expression);
        });
    }
    // Reads the type of the node from the cache.
    function getCachedType(node) {
        return readTypeCache(node, 0 /* EvalFlags.None */);
    }
    // Determines the expected type of a specified node based on surrounding
    // context. For example, if it's a subexpression of an argument expression,
    // the associated parameter type might inform the expected type.
    function getExpectedType(node) {
        // Scan up the parse tree to find the top-most expression node
        // so we can evaluate the entire expression.
        let topExpression = node;
        let curNode = node;
        while (curNode) {
            if ((0, parseNodes_1.isExpressionNode)(curNode)) {
                topExpression = curNode;
            }
            curNode = curNode.parent;
        }
        // Evaluate the expression. This will have the side effect of
        // storing an expected type in the expected type cache.
        evaluateTypesForExpressionInContext(topExpression);
        // Look for the resulting expected type by scanning up the parse tree.
        curNode = node;
        while (curNode) {
            const expectedType = expectedTypeCache.get(curNode.id);
            if (expectedType) {
                return {
                    type: expectedType,
                    node: curNode,
                };
            }
            if (curNode === topExpression) {
                break;
            }
            curNode = curNode.parent;
        }
        return undefined;
    }
    function initializePrefetchedTypes(node) {
        var _a;
        if (!isPrefetchedTypesInitialized) {
            // Some of these types have cyclical dependencies on each other,
            // so don't re-enter this block once we start executing it.
            isPrefetchedTypesInitialized = true;
            objectClass = getBuiltInType(node, 'object');
            typeClass = getBuiltInType(node, 'type');
            functionClass = getBuiltInType(node, 'function');
            unionTypeClass = getTypesType(node, 'UnionType');
            if (unionTypeClass && (0, types_1.isClass)(unionTypeClass)) {
                unionTypeClass.details.flags |= 8388608 /* ClassTypeFlags.SpecialFormClass */;
            }
            // Initialize and cache "Collection" to break a cyclical dependency
            // that occurs when resolving tuple below.
            getTypingType(node, 'Collection');
            noneTypeClass = (_a = getTypeshedType(node, 'NoneType')) !== null && _a !== void 0 ? _a : types_1.UnknownType.create();
            tupleClass = getBuiltInType(node, 'tuple');
            boolClass = getBuiltInType(node, 'bool');
            intClass = getBuiltInType(node, 'int');
            strClass = getBuiltInType(node, 'str');
            dictClass = getBuiltInType(node, 'dict');
            typedDictPrivateClass = getTypingType(node, '_TypedDict');
            awaitableClass = getTypingType(node, 'Awaitable');
            mappingClass = getTypingType(node, 'Mapping');
            supportsKeysAndGetItemClass = getTypeshedType(node, 'SupportsKeysAndGetItem');
            if (!supportsKeysAndGetItemClass) {
                // Fall back on 'Mapping' if 'SupportsKeysAndGetItem' is not available.
                supportsKeysAndGetItemClass = mappingClass;
            }
            // Wire up the `Any` class to the special-form version of our internal AnyType.
            if (objectClass && (0, types_1.isInstantiableClass)(objectClass) && typeClass && (0, types_1.isInstantiableClass)(typeClass)) {
                const anyClass = types_1.ClassType.createInstantiable('Any', 'typing.Any', 'typing', uri_1.Uri.empty(), 1 /* ClassTypeFlags.BuiltInClass */ |
                    8388608 /* ClassTypeFlags.SpecialFormClass */ |
                    16777216 /* ClassTypeFlags.IllegalIsinstanceClass */, 
                /* typeSourceId */ -1, 
                /* declaredMetaclass */ undefined, 
                /* effectiveMetaclass */ typeClass);
                anyClass.details.baseClasses.push(objectClass);
                (0, typeUtils_1.computeMroLinearization)(anyClass);
                const anySpecialForm = types_1.AnyType.createSpecialForm();
                if ((0, types_1.isAny)(anySpecialForm)) {
                    anySpecialForm.specialForm = anyClass;
                }
            }
        }
    }
    function getTypeOfExpression(node, flags = 0 /* EvalFlags.None */, inferenceContext, signatureTracker) {
        // Is this type already cached?
        const cacheEntry = readTypeCacheEntry(node);
        if (cacheEntry &&
            (!cacheEntry.typeResult.isIncomplete || cacheEntry.incompleteGenerationCount === incompleteGenerationCount)) {
            if (printExpressionTypes) {
                console.log(`${getPrintExpressionTypesSpaces()}${ParseTreeUtils.printExpression(node)} (${getLineNum(node)}): Cached ${printType(cacheEntry.typeResult.type)} ${cacheEntry.typeResult.typeErrors ? ' Errors' : ''}`);
            }
            return cacheEntry.typeResult;
        }
        else {
            // Is it cached in the speculative type cache?
            const cacheEntry = speculativeTypeTracker.getSpeculativeType(node, inferenceContext === null || inferenceContext === void 0 ? void 0 : inferenceContext.expectedType);
            if (cacheEntry &&
                (!cacheEntry.typeResult.isIncomplete ||
                    cacheEntry.incompleteGenerationCount === incompleteGenerationCount)) {
                if (printExpressionTypes) {
                    console.log(`${getPrintExpressionTypesSpaces()}${ParseTreeUtils.printExpression(node)} (${getLineNum(node)}): Speculative ${printType(cacheEntry.typeResult.type)}`);
                }
                return cacheEntry.typeResult;
            }
        }
        if (printExpressionTypes) {
            console.log(`${getPrintExpressionTypesSpaces()}${ParseTreeUtils.printExpression(node)} (${getLineNum(node)}): Pre`);
            printExpressionSpaceCount++;
        }
        // This is a frequently-called routine, so it's a good place to call
        // the cancellation check. If the operation is canceled, an exception
        // will be thrown at this point.
        checkForCancellation();
        if (inferenceContext) {
            inferenceContext.expectedType = (0, typeUtils_1.transformPossibleRecursiveTypeAlias)(inferenceContext.expectedType);
        }
        // If we haven't already fetched some core type definitions from the
        // typeshed stubs, do so here. It would be better to fetch this when it's
        // needed in assignType, but we don't have access to the parse tree
        // at that point.
        initializePrefetchedTypes(node);
        let typeResult = getTypeOfExpressionCore(node, flags, inferenceContext, signatureTracker);
        // Should we disable type promotions for bytes?
        if ((0, types_1.isInstantiableClass)(typeResult.type) &&
            typeResult.type.includePromotions &&
            !typeResult.type.includeSubclasses &&
            types_1.ClassType.isBuiltIn(typeResult.type, 'bytes')) {
            if (AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.disableBytesTypePromotions) {
                typeResult = {
                    ...typeResult,
                    type: types_1.ClassType.cloneRemoveTypePromotions(typeResult.type),
                };
            }
        }
        // Don't allow speculative caching for assignment expressions because
        // the target name node won't have a corresponding type cached speculatively.
        const allowSpeculativeCaching = node.nodeType !== 4 /* ParseNodeType.AssignmentExpression */;
        writeTypeCache(node, typeResult, flags, inferenceContext, allowSpeculativeCaching);
        // If there was an expected type, make sure that the result type is compatible.
        if (inferenceContext &&
            !(0, types_1.isAnyOrUnknown)(inferenceContext.expectedType) &&
            !(0, types_1.isNever)(inferenceContext.expectedType)) {
            expectedTypeCache.set(node.id, inferenceContext.expectedType);
            // If this is a generic function and there is a signature tracker,
            // make sure the signature is unique.
            if (signatureTracker && (0, types_1.isFunction)(typeResult.type)) {
                typeResult.type = (0, typeUtils_1.ensureFunctionSignaturesAreUnique)(typeResult.type, signatureTracker, node.start);
            }
            if (!typeResult.isIncomplete && !typeResult.expectedTypeDiagAddendum) {
                const diag = new diagnostic_1.DiagnosticAddendum();
                // Make sure the resulting type is assignable to the expected type.
                if (!assignType(inferenceContext.expectedType, typeResult.type, diag, 
                /* destTypeVarContext */ undefined, 
                /* srcTypeVarContext */ undefined, 1024 /* AssignTypeFlags.IgnoreTypeVarScope */)) {
                    typeResult.typeErrors = true;
                    typeResult.expectedTypeDiagAddendum = diag;
                    diag.addTextRange(node);
                }
            }
        }
        if (printExpressionTypes) {
            printExpressionSpaceCount--;
            console.log(`${getPrintExpressionTypesSpaces()}${ParseTreeUtils.printExpression(node)} (${getLineNum(node)}): Post ${printType(typeResult.type)}${typeResult.isIncomplete ? ' Incomplete' : ''}`);
        }
        return typeResult;
    }
    // This is a helper function that implements the core of getTypeOfExpression.
    function getTypeOfExpressionCore(node, flags = 0 /* EvalFlags.None */, inferenceContext, signatureTracker) {
        let typeResult;
        let expectingInstantiable = (flags & 128 /* EvalFlags.InstantiableType */) !== 0;
        switch (node.nodeType) {
            case 38 /* ParseNodeType.Name */: {
                typeResult = getTypeOfName(node, flags);
                break;
            }
            case 35 /* ParseNodeType.MemberAccess */: {
                typeResult = getTypeOfMemberAccess(node, flags);
                break;
            }
            case 27 /* ParseNodeType.Index */: {
                typeResult = getTypeOfIndex(node, flags);
                break;
            }
            case 9 /* ParseNodeType.Call */: {
                typeResult = getTypeOfCall(node, flags, inferenceContext, signatureTracker);
                break;
            }
            case 52 /* ParseNodeType.Tuple */: {
                typeResult = getTypeOfTuple(node, flags, inferenceContext, signatureTracker);
                break;
            }
            case 14 /* ParseNodeType.Constant */: {
                typeResult = getTypeOfConstant(node, flags);
                break;
            }
            case 48 /* ParseNodeType.StringList */: {
                const isExpectingType = (flags & 8 /* EvalFlags.StrLiteralAsType */) !== 0 && !isAnnotationLiteralValue(node);
                if (isExpectingType) {
                    // Don't report expecting type errors again. We will have already
                    // reported them when analyzing the contents of the string.
                    expectingInstantiable = false;
                }
                typeResult = getTypeOfStringList(node, flags, isExpectingType);
                break;
            }
            case 40 /* ParseNodeType.Number */: {
                typeResult = getTypeOfNumber(node, typeResult);
                break;
            }
            case 21 /* ParseNodeType.Ellipsis */: {
                typeResult = getTypeOfEllipsis(flags, typeResult, node);
                break;
            }
            case 55 /* ParseNodeType.UnaryOperation */: {
                typeResult = (0, operations_1.getTypeOfUnaryOperation)(evaluatorInterface, node, flags, inferenceContext);
                break;
            }
            case 7 /* ParseNodeType.BinaryOperation */: {
                let effectiveFlags = flags;
                // If we're expecting an instantiable type and this isn't a union operator,
                // don't require that the two operands are also instantiable types.
                if (expectingInstantiable && node.operator !== 6 /* OperatorType.BitwiseOr */) {
                    effectiveFlags &= ~128 /* EvalFlags.InstantiableType */;
                }
                typeResult = (0, operations_1.getTypeOfBinaryOperation)(evaluatorInterface, node, effectiveFlags, inferenceContext);
                break;
            }
            case 5 /* ParseNodeType.AugmentedAssignment */: {
                typeResult = (0, operations_1.getTypeOfAugmentedAssignment)(evaluatorInterface, node, inferenceContext);
                break;
            }
            case 34 /* ParseNodeType.List */:
            case 45 /* ParseNodeType.Set */: {
                typeResult = getTypeOfListOrSet(node, flags, inferenceContext);
                break;
            }
            case 46 /* ParseNodeType.Slice */: {
                typeResult = getTypeOfSlice(node);
                break;
            }
            case 6 /* ParseNodeType.Await */: {
                typeResult = getTypeOfAwaitOperator(node, flags, inferenceContext);
                break;
            }
            case 51 /* ParseNodeType.Ternary */: {
                typeResult = (0, operations_1.getTypeOfTernaryOperation)(evaluatorInterface, node, flags, inferenceContext);
                break;
            }
            case 11 /* ParseNodeType.Comprehension */: {
                typeResult = getTypeOfComprehension(node, flags, inferenceContext);
                break;
            }
            case 18 /* ParseNodeType.Dictionary */: {
                typeResult = getTypeOfDictionary(node, flags, inferenceContext);
                break;
            }
            case 33 /* ParseNodeType.Lambda */: {
                typeResult = getTypeOfLambda(node, inferenceContext);
                break;
            }
            case 3 /* ParseNodeType.Assignment */: {
                typeResult = getTypeOfExpression(node.rightExpression, flags, inferenceContext, signatureTracker);
                assignTypeToExpression(node.leftExpression, typeResult, node.rightExpression, 
                /* ignoreEmptyContainers */ true, 
                /* allowAssignmentToFinalVar */ true);
                break;
            }
            case 4 /* ParseNodeType.AssignmentExpression */: {
                if ((flags & 256 /* EvalFlags.TypeExpression */) !== 0) {
                    addError(localize_1.LocMessage.walrusNotAllowed(), node);
                }
                typeResult = getTypeOfExpression(node.rightExpression, flags, inferenceContext, signatureTracker);
                assignTypeToExpression(node.name, typeResult, node.rightExpression, /* ignoreEmptyContainers */ true);
                break;
            }
            case 60 /* ParseNodeType.Yield */: {
                typeResult = getTypeOfYield(node);
                break;
            }
            case 61 /* ParseNodeType.YieldFrom */: {
                typeResult = getTypeOfYieldFrom(node);
                break;
            }
            case 56 /* ParseNodeType.Unpack */: {
                typeResult = getTypeOfUnpackOperator(node, flags, inferenceContext);
                break;
            }
            case 54 /* ParseNodeType.TypeAnnotation */: {
                typeResult = getTypeOfExpression(node.typeAnnotation, 128 /* EvalFlags.InstantiableType */ |
                    256 /* EvalFlags.TypeExpression */ |
                    8 /* EvalFlags.StrLiteralAsType */ |
                    32 /* EvalFlags.NoParamSpec */ |
                    64 /* EvalFlags.NoTypeVarTuple */ |
                    32768 /* EvalFlags.VarTypeAnnotation */);
                break;
            }
            case 49 /* ParseNodeType.String */:
            case 30 /* ParseNodeType.FormatString */: {
                typeResult = getTypeOfString(node);
                break;
            }
            case 0 /* ParseNodeType.Error */: {
                // Evaluate the child expression as best we can so the
                // type information is cached for the completion handler.
                suppressDiagnostics(node, () => {
                    if (node.child) {
                        getTypeOfExpression(node.child);
                    }
                });
                typeResult = { type: types_1.UnknownType.create() };
                break;
            }
            default:
                (0, debug_1.assertNever)(node, `Illegal node type: ${node.nodeType}`);
        }
        if (!typeResult) {
            // We shouldn't get here. If we do, report an error.
            (0, debug_1.fail)(`Unhandled expression type '${ParseTreeUtils.printExpression(node)}'`);
        }
        // Do we need to validate that the type is instantiable?
        if (expectingInstantiable) {
            validateTypeIsInstantiable(typeResult, flags, node);
        }
        // If this is a PEP 695 type alias, remove the special form so the type
        // printer prints it as its aliased type rather than TypeAliasType.
        if ((flags & 256 /* EvalFlags.TypeExpression */) !== 0) {
            if (typeResult.type.specialForm && types_1.ClassType.isBuiltIn(typeResult.type.specialForm, 'TypeAliasType')) {
                typeResult.type = types_1.TypeBase.cloneAsSpecialForm(typeResult.type, undefined);
            }
        }
        return typeResult;
    }
    // Reports the case where a function or class has been decorated with
    // @type_check_only and is used in a value expression.
    function reportUseOfTypeCheckOnly(type, node) {
        let isTypeCheckingOnly = false;
        let name = '';
        if ((0, types_1.isInstantiableClass)(type) && !type.includeSubclasses) {
            isTypeCheckingOnly = types_1.ClassType.isTypeCheckOnly(type);
            name = type.details.name;
        }
        else if ((0, types_1.isFunction)(type)) {
            isTypeCheckingOnly = types_1.FunctionType.isTypeCheckOnly(type);
            name = type.details.name;
        }
        if (isTypeCheckingOnly) {
            const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
            if (!fileInfo.isStubFile) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeCheckOnly().format({ name }), node);
            }
        }
    }
    function validateTypeIsInstantiable(typeResult, flags, node) {
        // If the type is incomplete, don't log any diagnostics yet.
        if (typeResult.isIncomplete) {
            return;
        }
        if ((flags & 64 /* EvalFlags.NoTypeVarTuple */) !== 0) {
            if ((0, types_1.isVariadicTypeVar)(typeResult.type) && !typeResult.type.isVariadicInUnion) {
                addError(localize_1.LocMessage.typeVarTupleContext(), node);
                typeResult.type = types_1.UnknownType.create();
            }
        }
        if ((0, typeUtils_1.isEffectivelyInstantiable)(typeResult.type, { honorTypeVarBounds: true })) {
            return;
        }
        // Exempt ellipses.
        if ((0, types_1.isClassInstance)(typeResult.type) && types_1.ClassType.isBuiltIn(typeResult.type, ['EllipsisType', 'ellipsis'])) {
            return;
        }
        const diag = new diagnostic_1.DiagnosticAddendum();
        if ((0, types_1.isUnion)(typeResult.type)) {
            (0, typeUtils_1.doForEachSubtype)(typeResult.type, (subtype) => {
                if (!(0, typeUtils_1.isEffectivelyInstantiable)(subtype, { honorTypeVarBounds: true })) {
                    diag.addMessage(localize_1.LocAddendum.typeNotClass().format({ type: printType(subtype) }));
                }
            });
        }
        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeExpectedClass().format({ type: printType(typeResult.type) }) + diag.getString(), node);
        typeResult.type = types_1.UnknownType.create();
        typeResult.typeErrors = true;
    }
    function getTypeOfAwaitOperator(node, flags, inferenceContext) {
        if ((flags & 256 /* EvalFlags.TypeExpression */) !== 0) {
            addError(localize_1.LocMessage.awaitNotAllowed(), node);
            return { type: types_1.UnknownType.create() };
        }
        const expectedType = inferenceContext
            ? createAwaitableReturnType(node, inferenceContext.expectedType, 
            /* isGenerator */ false, 
            /* useCoroutine */ false)
            : undefined;
        const exprTypeResult = getTypeOfExpression(node.expression, flags, (0, typeUtils_1.makeInferenceContext)(expectedType));
        const typeResult = {
            type: getTypeOfAwaitable(exprTypeResult.type, node.expression),
            isIncomplete: exprTypeResult.isIncomplete,
            typeErrors: exprTypeResult.typeErrors,
        };
        if (exprTypeResult.isIncomplete) {
            typeResult.isIncomplete = true;
        }
        return typeResult;
    }
    function getTypeOfEllipsis(flags, typeResult, node) {
        var _a, _b;
        if ((flags & 1 /* EvalFlags.ConvertEllipsisToAny */) !== 0) {
            typeResult = { type: types_1.AnyType.create(/* isEllipsis */ true) };
        }
        else {
            const ellipsisType = (_b = (_a = getBuiltInObject(node, 'EllipsisType')) !== null && _a !== void 0 ? _a : getBuiltInObject(node, 'ellipsis')) !== null && _b !== void 0 ? _b : types_1.AnyType.create();
            typeResult = { type: ellipsisType };
        }
        return typeResult;
    }
    function getTypeOfNumber(node, typeResult) {
        if (node.isImaginary) {
            typeResult = { type: getBuiltInObject(node, 'complex') };
        }
        else if (node.isInteger) {
            typeResult = { type: cloneBuiltinObjectWithLiteral(node, 'int', node.value) };
        }
        else {
            typeResult = { type: getBuiltInObject(node, 'float') };
        }
        return typeResult;
    }
    function getTypeOfUnpackOperator(node, flags, inferenceContext) {
        var _a;
        let typeResult;
        let iterExpectedType;
        if (inferenceContext) {
            const iterableType = getBuiltInType(node, 'Iterable');
            if (iterableType && (0, types_1.isInstantiableClass)(iterableType)) {
                iterExpectedType = types_1.ClassType.cloneAsInstance(types_1.ClassType.cloneForSpecialization(iterableType, [inferenceContext.expectedType], 
                /* isTypeArgumentExplicit */ true));
            }
        }
        const iterTypeResult = getTypeOfExpression(node.expression, flags, (0, typeUtils_1.makeInferenceContext)(iterExpectedType));
        const iterType = iterTypeResult.type;
        if ((flags & 64 /* EvalFlags.NoTypeVarTuple */) === 0 && (0, types_1.isVariadicTypeVar)(iterType) && !iterType.isVariadicUnpacked) {
            typeResult = { type: types_1.TypeVarType.cloneForUnpacked(iterType) };
        }
        else if ((flags & 2097152 /* EvalFlags.AllowUnpackedTuple */) !== 0 &&
            (0, types_1.isInstantiableClass)(iterType) &&
            types_1.ClassType.isBuiltIn(iterType, 'tuple')) {
            typeResult = { type: types_1.ClassType.cloneForUnpacked(iterType) };
        }
        else if ((flags & 256 /* EvalFlags.TypeExpression */) !== 0) {
            addError(localize_1.LocMessage.unpackInAnnotation(), node, node.starToken);
            typeResult = { type: types_1.UnknownType.create() };
        }
        else {
            const iteratorTypeResult = (_a = getTypeOfIterator(iterTypeResult, /* isAsync */ false, node)) !== null && _a !== void 0 ? _a : {
                type: types_1.UnknownType.create(!!iterTypeResult.isIncomplete),
                isIncomplete: iterTypeResult.isIncomplete,
            };
            typeResult = {
                type: iteratorTypeResult.type,
                typeErrors: iterTypeResult.typeErrors,
                unpackedType: iterType,
                isIncomplete: iteratorTypeResult.isIncomplete,
            };
        }
        return typeResult;
    }
    function getTypeOfStringList(node, flags, isExpectingType) {
        let typeResult;
        if (isExpectingType) {
            let updatedFlags = flags | 4 /* EvalFlags.ForwardRefs */ | 128 /* EvalFlags.InstantiableType */;
            // In most cases, annotations within a string are not parsed by the interpreter.
            // There are a few exceptions (e.g. the "bound" value for a TypeVar constructor).
            if ((flags & 8388608 /* EvalFlags.ParsesStringLiteral */) === 0) {
                updatedFlags |= 524288 /* EvalFlags.NotParsed */;
            }
            if (node.typeAnnotation) {
                typeResult = getTypeOfExpression(node.typeAnnotation, updatedFlags);
            }
            else if (!node.typeAnnotation && node.strings.length === 1) {
                const tokenFlags = node.strings[0].token.flags;
                if (tokenFlags & 32 /* StringTokenFlags.Bytes */) {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.annotationBytesString(), node);
                    typeResult = { type: types_1.UnknownType.create() };
                }
                else if (tokenFlags & 8 /* StringTokenFlags.Raw */) {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.annotationRawString(), node);
                    typeResult = { type: types_1.UnknownType.create() };
                }
                else if (tokenFlags & 64 /* StringTokenFlags.Format */) {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.annotationFormatString(), node);
                    typeResult = { type: types_1.UnknownType.create() };
                }
                else {
                    // We didn't know at parse time that this string node was going
                    // to be evaluated as a forward-referenced type. We need
                    // to re-invoke the parser at this stage.
                    const expr = parseStringAsTypeAnnotation(node);
                    if (expr) {
                        typeResult = getTypeOfExpression(expr, updatedFlags);
                    }
                }
            }
            if (!typeResult) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.expectedTypeNotString(), node);
                typeResult = { type: types_1.UnknownType.create() };
            }
        }
        else {
            // Evaluate the format string expressions in this context.
            let isLiteralString = true;
            let isIncomplete = false;
            node.strings.forEach((expr) => {
                const typeResult = getTypeOfString(expr);
                if (typeResult.isIncomplete) {
                    isIncomplete = true;
                }
                let isExprLiteralString = false;
                if ((0, types_1.isClassInstance)(typeResult.type)) {
                    if (types_1.ClassType.isBuiltIn(typeResult.type, 'str') && typeResult.type.literalValue !== undefined) {
                        isExprLiteralString = true;
                    }
                    else if (types_1.ClassType.isBuiltIn(typeResult === null || typeResult === void 0 ? void 0 : typeResult.type, 'LiteralString')) {
                        isExprLiteralString = true;
                    }
                }
                if (!isExprLiteralString) {
                    isLiteralString = false;
                }
            });
            const isBytes = (node.strings[0].token.flags & 32 /* StringTokenFlags.Bytes */) !== 0;
            // Don't create a literal type if it's an f-string.
            if (node.strings.some((str) => str.nodeType === 30 /* ParseNodeType.FormatString */)) {
                if (isLiteralString) {
                    const literalStringType = getTypingType(node, 'LiteralString');
                    if (literalStringType && (0, types_1.isInstantiableClass)(literalStringType)) {
                        typeResult = { type: types_1.ClassType.cloneAsInstance(literalStringType) };
                    }
                }
                if (!typeResult) {
                    typeResult = {
                        type: getBuiltInObject(node, isBytes ? 'bytes' : 'str'),
                        isIncomplete,
                    };
                }
            }
            else {
                typeResult = {
                    type: cloneBuiltinObjectWithLiteral(node, isBytes ? 'bytes' : 'str', node.strings.map((s) => s.value).join('')),
                    isIncomplete,
                };
            }
        }
        return typeResult;
    }
    function getTypeOfString(node) {
        const isBytes = (node.token.flags & 32 /* StringTokenFlags.Bytes */) !== 0;
        let typeResult;
        let isIncomplete = false;
        // Don't create a literal type if it's an f-string.
        if (node.nodeType === 30 /* ParseNodeType.FormatString */) {
            let isLiteralString = true;
            // If all of the format expressions are of type LiteralString, then
            // the resulting formatted string is also LiteralString.
            node.fieldExpressions.forEach((expr) => {
                const exprTypeResult = getTypeOfExpression(expr);
                const exprType = exprTypeResult.type;
                if (exprTypeResult.isIncomplete) {
                    isIncomplete = true;
                }
                (0, typeUtils_1.doForEachSubtype)(exprType, (exprSubtype) => {
                    if (!(0, types_1.isClassInstance)(exprSubtype)) {
                        isLiteralString = false;
                        return;
                    }
                    if (types_1.ClassType.isBuiltIn(exprSubtype, 'LiteralString')) {
                        return;
                    }
                    if (types_1.ClassType.isBuiltIn(exprSubtype, 'str') && exprSubtype.literalValue !== undefined) {
                        return;
                    }
                    isLiteralString = false;
                });
            });
            if (!isBytes && isLiteralString) {
                const literalStringType = getTypingType(node, 'LiteralString');
                if (literalStringType && (0, types_1.isInstantiableClass)(literalStringType)) {
                    typeResult = { type: types_1.ClassType.cloneAsInstance(literalStringType), isIncomplete };
                }
            }
            if (!typeResult) {
                typeResult = {
                    type: getBuiltInObject(node, isBytes ? 'bytes' : 'str'),
                    isIncomplete,
                };
                if ((0, types_1.isClass)(typeResult.type) && typeResult.type.includePromotions) {
                    typeResult.type = types_1.ClassType.cloneRemoveTypePromotions(typeResult.type);
                }
            }
        }
        else {
            typeResult = {
                type: cloneBuiltinObjectWithLiteral(node, isBytes ? 'bytes' : 'str', node.value),
                isIncomplete,
            };
        }
        return typeResult;
    }
    function stripLiteralValue(type) {
        var _a, _b, _c;
        // Handle the not-uncommon case where the type is a union that consists
        // only of literal values.
        if ((0, types_1.isUnion)(type) && type.subtypes.length > 0) {
            if (((_a = type.literalInstances.literalStrMap) === null || _a === void 0 ? void 0 : _a.size) === type.subtypes.length ||
                ((_b = type.literalInstances.literalIntMap) === null || _b === void 0 ? void 0 : _b.size) === type.subtypes.length ||
                ((_c = type.literalInstances.literalEnumMap) === null || _c === void 0 ? void 0 : _c.size) === type.subtypes.length) {
                return stripLiteralValue(type.subtypes[0]);
            }
        }
        return (0, typeUtils_1.mapSubtypes)(type, (subtype) => {
            if ((0, types_1.isClass)(subtype)) {
                if (subtype.literalValue !== undefined) {
                    return types_1.ClassType.cloneWithLiteral(subtype, /* value */ undefined);
                }
                if (types_1.ClassType.isBuiltIn(subtype, 'LiteralString')) {
                    // Handle "LiteralString" specially.
                    if (strClass && (0, types_1.isInstantiableClass)(strClass)) {
                        let strInstance = types_1.ClassType.cloneAsInstance(strClass);
                        if (subtype.condition) {
                            strInstance = types_1.TypeBase.cloneForCondition(strInstance, (0, typeUtils_1.getTypeCondition)(subtype));
                        }
                        return strInstance;
                    }
                }
            }
            return subtype;
        });
    }
    function getTypeOfParameterAnnotation(paramTypeNode, paramCategory) {
        return getTypeOfAnnotation(paramTypeNode, {
            associateTypeVarsWithScope: true,
            allowTypeVarTuple: paramCategory === 1 /* ParameterCategory.ArgsList */,
            allowUnpackedTypedDict: paramCategory === 2 /* ParameterCategory.KwargsDict */,
            allowUnpackedTuple: paramCategory === 1 /* ParameterCategory.ArgsList */,
        });
    }
    function getTypeOfAnnotation(node, options) {
        var _a, _b, _c;
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        // Special-case the typing.pyi file, which contains some special
        // types that the type analyzer needs to interpret differently.
        if (fileInfo.isTypingStubFile || fileInfo.isTypingExtensionsStubFile) {
            const specialType = handleTypingStubTypeAnnotation(node);
            if (specialType) {
                return specialType;
            }
        }
        let evaluatorFlags = 128 /* EvalFlags.InstantiableType */ |
            256 /* EvalFlags.TypeExpression */ |
            1 /* EvalFlags.ConvertEllipsisToAny */ |
            8 /* EvalFlags.StrLiteralAsType */;
        if (options === null || options === void 0 ? void 0 : options.isVariableAnnotation) {
            evaluatorFlags |= 32768 /* EvalFlags.VarTypeAnnotation */;
        }
        if (!(options === null || options === void 0 ? void 0 : options.allowFinal)) {
            evaluatorFlags |= 16 /* EvalFlags.NoFinal */;
        }
        if (!(options === null || options === void 0 ? void 0 : options.allowClassVar)) {
            evaluatorFlags |= 131072 /* EvalFlags.NoClassVar */;
        }
        if (!(options === null || options === void 0 ? void 0 : options.allowTypeVarTuple)) {
            evaluatorFlags |= 64 /* EvalFlags.NoTypeVarTuple */;
        }
        else {
            evaluatorFlags |= 2097152 /* EvalFlags.AllowUnpackedTuple */;
        }
        if (!(options === null || options === void 0 ? void 0 : options.allowParamSpec)) {
            evaluatorFlags |= 32 /* EvalFlags.NoParamSpec */;
        }
        if (options === null || options === void 0 ? void 0 : options.associateTypeVarsWithScope) {
            evaluatorFlags |= 8192 /* EvalFlags.TypeVarGetsCurScope */;
        }
        if (options === null || options === void 0 ? void 0 : options.allowUnpackedTypedDict) {
            evaluatorFlags |= 4194304 /* EvalFlags.AllowUnpackedTypedDict */;
        }
        if (options === null || options === void 0 ? void 0 : options.allowUnpackedTuple) {
            evaluatorFlags |= 2097152 /* EvalFlags.AllowUnpackedTuple */;
        }
        if (options === null || options === void 0 ? void 0 : options.notParsedByInterpreter) {
            evaluatorFlags |= 524288 /* EvalFlags.NotParsed */;
        }
        if (options === null || options === void 0 ? void 0 : options.allowRequired) {
            evaluatorFlags |= 1048576 /* EvalFlags.AllowRequired */;
        }
        if ((0, analyzerFileInfo_1.isAnnotationEvaluationPostponed)(fileInfo)) {
            evaluatorFlags |= 4 /* EvalFlags.ForwardRefs */;
        }
        // If the annotation is part of a comment, allow forward references
        // even if it's not enclosed in quotes.
        if (((_a = node === null || node === void 0 ? void 0 : node.parent) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* ParseNodeType.Assignment */ && node.parent.typeAnnotationComment === node) {
            evaluatorFlags |= 4 /* EvalFlags.ForwardRefs */ | 524288 /* EvalFlags.NotParsed */;
        }
        else if (((_b = node === null || node === void 0 ? void 0 : node.parent) === null || _b === void 0 ? void 0 : _b.nodeType) === 62 /* ParseNodeType.FunctionAnnotation */) {
            if (node.parent.returnTypeAnnotation === node || node.parent.paramTypeAnnotations.some((n) => n === node)) {
                evaluatorFlags |= 4 /* EvalFlags.ForwardRefs */ | 524288 /* EvalFlags.NotParsed */;
            }
        }
        else if (((_c = node === null || node === void 0 ? void 0 : node.parent) === null || _c === void 0 ? void 0 : _c.nodeType) === 41 /* ParseNodeType.Parameter */) {
            if (node.parent.typeAnnotationComment === node) {
                evaluatorFlags |= 4 /* EvalFlags.ForwardRefs */ | 524288 /* EvalFlags.NotParsed */;
            }
        }
        const annotationType = getTypeOfExpression(node, evaluatorFlags).type;
        if ((0, types_1.isModule)(annotationType)) {
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.moduleAsType(), node);
        }
        return (0, typeUtils_1.convertToInstance)(annotationType);
    }
    function canBeFalsy(type, recursionCount = 0) {
        type = makeTopLevelTypeVarsConcrete(type);
        if (recursionCount > types_1.maxTypeRecursionCount) {
            return true;
        }
        recursionCount++;
        switch (type.category) {
            case 0 /* TypeCategory.Unbound */:
            case 1 /* TypeCategory.Unknown */:
            case 2 /* TypeCategory.Any */:
            case 3 /* TypeCategory.Never */: {
                return true;
            }
            case 8 /* TypeCategory.Union */: {
                return (0, types_1.findSubtype)(type, (subtype) => canBeFalsy(subtype, recursionCount)) !== undefined;
            }
            case 4 /* TypeCategory.Function */:
            case 5 /* TypeCategory.OverloadedFunction */:
            case 7 /* TypeCategory.Module */:
            case 9 /* TypeCategory.TypeVar */: {
                return false;
            }
            case 6 /* TypeCategory.Class */: {
                if (types_1.TypeBase.isInstantiable(type)) {
                    return false;
                }
                // Handle tuples specially.
                if ((0, typeUtils_1.isTupleClass)(type) && type.tupleTypeArguments) {
                    return (0, typeUtils_1.isUnboundedTupleClass)(type) || type.tupleTypeArguments.length === 0;
                }
                // Handle subclasses of tuple, such as NamedTuple.
                const tupleBaseClass = type.details.mro.find((mroClass) => !(0, types_1.isClass)(mroClass) || (0, typeUtils_1.isTupleClass)(mroClass));
                if (tupleBaseClass && (0, types_1.isClass)(tupleBaseClass) && tupleBaseClass.tupleTypeArguments) {
                    return (0, typeUtils_1.isUnboundedTupleClass)(tupleBaseClass) || tupleBaseClass.tupleTypeArguments.length === 0;
                }
                // Check for Literal[False] and Literal[True].
                if (types_1.ClassType.isBuiltIn(type, 'bool') && type.literalValue !== undefined) {
                    return type.literalValue === false;
                }
                // If this is a protocol class, don't make any assumptions about the absence
                // of specific methods. These could be provided by a class that conforms
                // to the protocol.
                if (types_1.ClassType.isProtocolClass(type)) {
                    return true;
                }
                const lenMethod = (0, typeUtils_1.lookUpObjectMember)(type, '__len__');
                if (lenMethod) {
                    return true;
                }
                const boolMethod = (0, typeUtils_1.lookUpObjectMember)(type, '__bool__');
                if (boolMethod) {
                    const boolMethodType = getTypeOfMember(boolMethod);
                    // If the __bool__ function unconditionally returns True, it can never be falsy.
                    if ((0, types_1.isFunction)(boolMethodType) && boolMethodType.details.declaredReturnType) {
                        const returnType = boolMethodType.details.declaredReturnType;
                        if ((0, types_1.isClassInstance)(returnType) &&
                            types_1.ClassType.isBuiltIn(returnType, 'bool') &&
                            returnType.literalValue === true) {
                            return false;
                        }
                    }
                    return true;
                }
                // If the class is not final, it's possible that it could be overridden
                // such that it is falsy. To be fully correct, we'd need to do the
                // following:
                // return !ClassType.isFinal(type);
                // However, pragmatically if the class is not an `object`, it's typically
                // OK to assume that it will not be overridden in this manner.
                return types_1.ClassType.isBuiltIn(type, 'object');
            }
        }
    }
    function canBeTruthy(type, recursionCount = 0) {
        type = makeTopLevelTypeVarsConcrete(type);
        if (recursionCount > types_1.maxTypeRecursionCount) {
            return true;
        }
        recursionCount++;
        switch (type.category) {
            case 1 /* TypeCategory.Unknown */:
            case 4 /* TypeCategory.Function */:
            case 5 /* TypeCategory.OverloadedFunction */:
            case 7 /* TypeCategory.Module */:
            case 9 /* TypeCategory.TypeVar */:
            case 3 /* TypeCategory.Never */:
            case 2 /* TypeCategory.Any */: {
                return true;
            }
            case 8 /* TypeCategory.Union */: {
                return (0, types_1.findSubtype)(type, (subtype) => canBeTruthy(subtype, recursionCount)) !== undefined;
            }
            case 0 /* TypeCategory.Unbound */: {
                return false;
            }
            case 6 /* TypeCategory.Class */: {
                if (types_1.TypeBase.isInstantiable(type)) {
                    return true;
                }
                if ((0, typeUtils_1.isNoneInstance)(type)) {
                    return false;
                }
                // // Check for tuple[()] (an empty tuple).
                if (type.tupleTypeArguments && type.tupleTypeArguments.length === 0) {
                    return false;
                }
                // Check for Literal[False], Literal[0], Literal[""].
                if (type.literalValue === false ||
                    type.literalValue === 0 ||
                    type.literalValue === BigInt(0) ||
                    type.literalValue === '') {
                    return false;
                }
                // If this is a protocol class, don't make any assumptions about the absence
                // of specific methods. These could be provided by a class that conforms
                // to the protocol.
                if (types_1.ClassType.isProtocolClass(type)) {
                    return true;
                }
                const boolMethod = (0, typeUtils_1.lookUpObjectMember)(type, '__bool__');
                if (boolMethod) {
                    const boolMethodType = getTypeOfMember(boolMethod);
                    // If the __bool__ function unconditionally returns False, it can never be truthy.
                    if ((0, types_1.isFunction)(boolMethodType) && boolMethodType.details.declaredReturnType) {
                        const returnType = boolMethodType.details.declaredReturnType;
                        if ((0, types_1.isClassInstance)(returnType) &&
                            types_1.ClassType.isBuiltIn(returnType, 'bool') &&
                            returnType.literalValue === false) {
                            return false;
                        }
                    }
                }
                return true;
            }
        }
    }
    // Filters a type such that that no part of it is definitely
    // truthy. For example, if a type is a union of None
    // and a custom class "Foo" that has no __len__ or __nonzero__
    // method, this method would strip off the "Foo"
    // and return only the "None".
    function removeTruthinessFromType(type) {
        return (0, typeUtils_1.mapSubtypes)(type, (subtype) => {
            const concreteSubtype = makeTopLevelTypeVarsConcrete(subtype);
            if ((0, types_1.isClassInstance)(concreteSubtype)) {
                if (concreteSubtype.literalValue !== undefined) {
                    let isLiteralFalsy;
                    if (concreteSubtype.literalValue instanceof types_1.EnumLiteral) {
                        isLiteralFalsy = !canBeTruthy(concreteSubtype);
                    }
                    else {
                        isLiteralFalsy = !concreteSubtype.literalValue;
                    }
                    // If the object is already definitely falsy, it's fine to
                    // include, otherwise it should be removed.
                    return isLiteralFalsy ? subtype : undefined;
                }
                // If the object is a bool, make it "false", since
                // "true" is a truthy value.
                if (types_1.ClassType.isBuiltIn(concreteSubtype, 'bool')) {
                    return types_1.ClassType.cloneWithLiteral(concreteSubtype, /* value */ false);
                }
                // If the object is an int, str or bytes, narrow to a literal type.
                // This is slightly unsafe in that someone could subclass `int`, `str`
                // or `bytes` and override the `__bool__` method to change its behavior,
                // but this is extremely unlikely (and ill advised).
                if (types_1.ClassType.isBuiltIn(concreteSubtype, 'int')) {
                    return types_1.ClassType.cloneWithLiteral(concreteSubtype, /* value */ 0);
                }
                else if (types_1.ClassType.isBuiltIn(concreteSubtype, ['str', 'bytes'])) {
                    return types_1.ClassType.cloneWithLiteral(concreteSubtype, /* value */ '');
                }
            }
            // If it's possible for the type to be falsy, include it.
            if (canBeFalsy(subtype)) {
                return subtype;
            }
            return undefined;
        });
    }
    // Filters a type such that that no part of it is definitely
    // falsy. For example, if a type is a union of None
    // and an "int", this method would strip off the "None"
    // and return only the "int".
    function removeFalsinessFromType(type) {
        return (0, typeUtils_1.mapSubtypes)(type, (subtype) => {
            const concreteSubtype = makeTopLevelTypeVarsConcrete(subtype);
            if ((0, types_1.isClassInstance)(concreteSubtype)) {
                if (concreteSubtype.literalValue !== undefined) {
                    let isLiteralTruthy;
                    if (concreteSubtype.literalValue instanceof types_1.EnumLiteral) {
                        isLiteralTruthy = !canBeFalsy(concreteSubtype);
                    }
                    else {
                        isLiteralTruthy = !!concreteSubtype.literalValue;
                    }
                    // If the object is already definitely truthy, it's fine to
                    // include, otherwise it should be removed.
                    return isLiteralTruthy ? subtype : undefined;
                }
                // If the object is a bool, make it "true", since
                // "false" is a falsy value.
                if (types_1.ClassType.isBuiltIn(concreteSubtype, 'bool')) {
                    return types_1.ClassType.cloneWithLiteral(concreteSubtype, /* value */ true);
                }
                // If the object is a "None" instance, we can eliminate it.
                if ((0, typeUtils_1.isNoneInstance)(concreteSubtype)) {
                    return undefined;
                }
                // If this is an instance of a class that cannot be subclassed,
                // we cannot say definitively that it's not falsy because a subclass
                // could override `__bool__`. For this reason, the code should not
                // remove any classes that are not final.
                // if (!ClassType.isFinal(concreteSubtype)) {
                //     return subtype;
                // }
                // However, we're going to pragmatically assume that any classes
                // other than `object` will not be overridden in this manner.
                if (types_1.ClassType.isBuiltIn(concreteSubtype, 'object')) {
                    return subtype;
                }
            }
            // If it's possible for the type to be truthy, include it.
            if (canBeTruthy(subtype)) {
                return subtype;
            }
            return undefined;
        });
    }
    // Gets a member type from an object or class. If it's a function, binds
    // it to the object or class. If selfType is undefined, the binding is done
    // using the objectType parameter. Callers can specify these separately
    // to handle the case where we're fetching the object member from a
    // metaclass but binding to the class.
    function getTypeOfBoundMember(errorNode, objectType, memberName, usage = { method: 'get' }, diag = undefined, flags = 0 /* MemberAccessFlags.Default */, selfType, recursionCount = 0) {
        if (types_1.ClassType.isPartiallyEvaluated(objectType)) {
            if (errorNode) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.classDefinitionCycle().format({ name: objectType.details.name }), errorNode);
            }
            return { type: types_1.UnknownType.create() };
        }
        // If this is an unspecialized generic class, specialize it using the default
        // values for its type parameters.
        if ((0, types_1.isInstantiableClass)(objectType) &&
            !objectType.includeSubclasses &&
            objectType.details.typeParameters.length > 0) {
            // Skip this if we're suppressing the use of attribute access override,
            // such as with dundered methods (like __call__).
            if ((flags & 512 /* MemberAccessFlags.SkipAttributeAccessOverride */) === 0) {
                objectType = (0, typeUtils_1.specializeWithDefaultTypeArgs)(objectType);
            }
        }
        // Determine the class that was used to instantiate the objectType.
        // If the objectType is a class itself, then the class used to instantiate
        // it is the metaclass.
        const objectTypeIsInstantiable = types_1.TypeBase.isInstantiable(objectType);
        const metaclass = objectType.details.effectiveMetaclass;
        let memberInfo;
        // If the object type is an instantiable (i.e. it derives from "type") and
        // we've been asked not to consider instance members, don't look in the class.
        // Consider only the metaclass class variables in this case.
        let skipObjectTypeLookup = objectTypeIsInstantiable && (flags & 16 /* MemberAccessFlags.SkipInstanceMembers */) !== 0;
        // Look up the attribute in the metaclass first. If the member is a descriptor
        // (an object with a __get__ and __set__ method) and the access is a 'get',
        // the Python runtime uses this descriptor to satisfy the lookup. Skip this
        // costly lookup in the common case where the metaclass is 'type' since we know
        // that `type` doesn't have any attributes that are descriptors.
        if (usage.method === 'get' &&
            objectTypeIsInstantiable &&
            metaclass &&
            (0, types_1.isInstantiableClass)(metaclass) &&
            !types_1.ClassType.isBuiltIn(metaclass, 'type') &&
            !types_1.ClassType.isSameGenericClass(metaclass, objectType)) {
            const descMemberInfo = getTypeOfClassMemberName(errorNode, metaclass, memberName, usage, 
            /* diag */ undefined, flags | 512 /* MemberAccessFlags.SkipAttributeAccessOverride */, objectType, recursionCount);
            if (descMemberInfo) {
                const isProperty = (0, types_1.isClassInstance)(descMemberInfo.type) && types_1.ClassType.isPropertyClass(descMemberInfo.type);
                if ((0, typeUtils_1.isDescriptorInstance)(descMemberInfo.type, /* requireSetter */ true) || isProperty) {
                    skipObjectTypeLookup = true;
                }
            }
        }
        let subDiag;
        if (!skipObjectTypeLookup) {
            let effectiveFlags = flags;
            if (objectTypeIsInstantiable) {
                effectiveFlags |=
                    16 /* MemberAccessFlags.SkipInstanceMembers */ |
                        512 /* MemberAccessFlags.SkipAttributeAccessOverride */ |
                        1024 /* MemberAccessFlags.DisallowGenericInstanceVariableAccess */;
                effectiveFlags &= ~32 /* MemberAccessFlags.SkipClassMembers */;
            }
            else {
                effectiveFlags |= 128 /* MemberAccessFlags.DisallowClassVarWrites */;
            }
            subDiag = diag ? new diagnostic_1.DiagnosticAddendum() : undefined;
            // See if the member is present in the object itself.
            memberInfo = getTypeOfClassMemberName(errorNode, objectType, memberName, usage, subDiag, effectiveFlags, selfType, recursionCount);
        }
        // If it wasn't found on the object, see if it's part of the metaclass.
        if (!memberInfo && metaclass && (0, types_1.isInstantiableClass)(metaclass)) {
            let effectiveFlags = flags;
            // Class members cannot be accessed on a class's metaclass through
            // an instance of a class. Limit access to metaclass instance members
            // in this case.
            if (!objectTypeIsInstantiable) {
                effectiveFlags |=
                    32 /* MemberAccessFlags.SkipClassMembers */ |
                        512 /* MemberAccessFlags.SkipAttributeAccessOverride */ |
                        8 /* MemberAccessFlags.SkipTypeBaseClass */;
                effectiveFlags &= ~16 /* MemberAccessFlags.SkipInstanceMembers */;
            }
            const metaclassDiag = diag ? new diagnostic_1.DiagnosticAddendum() : undefined;
            memberInfo = getTypeOfClassMemberName(errorNode, types_1.ClassType.cloneAsInstance(metaclass), memberName, usage, metaclassDiag, effectiveFlags, objectTypeIsInstantiable ? objectType : types_1.ClassType.cloneAsInstantiable(objectType), recursionCount);
            // If there was a descriptor error (as opposed to an error where the members
            // was simply not found), use this diagnostic message.
            if (memberInfo === null || memberInfo === void 0 ? void 0 : memberInfo.isDescriptorError) {
                subDiag = metaclassDiag;
            }
        }
        if (memberInfo) {
            if (memberInfo.isDescriptorError && diag && subDiag) {
                diag.addAddendum(subDiag);
            }
            return {
                type: memberInfo.type,
                classType: memberInfo.classType,
                isIncomplete: !!memberInfo.isTypeIncomplete,
                isAsymmetricAccessor: memberInfo.isAsymmetricAccessor,
                narrowedTypeForSet: memberInfo.narrowedTypeForSet,
                memberAccessDeprecationInfo: memberInfo.memberAccessDeprecationInfo,
                typeErrors: memberInfo.isDescriptorError,
            };
        }
        // If this is a type[Any] or type[Unknown], allow any other members.
        if ((0, types_1.isClassInstance)(objectType) && types_1.ClassType.isBuiltIn(objectType, 'type') && objectType.includeSubclasses) {
            if ((flags & (8 /* MemberAccessFlags.SkipTypeBaseClass */ | 512 /* MemberAccessFlags.SkipAttributeAccessOverride */)) === 0) {
                const typeArg = objectType.typeArguments && objectType.typeArguments.length >= 1
                    ? objectType.typeArguments[0]
                    : types_1.UnknownType.create();
                if ((0, types_1.isAnyOrUnknown)(typeArg)) {
                    return { type: typeArg, classType: types_1.UnknownType.create() };
                }
            }
        }
        if (diag && subDiag) {
            diag.addAddendum(subDiag);
        }
        return undefined;
    }
    function getBoundMagicMethod(classType, memberName, selfType, diag, recursionCount = 0) {
        if (recursionCount > types_1.maxTypeRecursionCount) {
            return undefined;
        }
        recursionCount++;
        const boundMethodResult = getTypeOfBoundMember(
        /* errorNode */ undefined, classType, memberName, 
        /* usage */ undefined, diag, 16 /* MemberAccessFlags.SkipInstanceMembers */ | 512 /* MemberAccessFlags.SkipAttributeAccessOverride */, selfType, recursionCount);
        if (!boundMethodResult || boundMethodResult.typeErrors) {
            return undefined;
        }
        if ((0, types_1.isFunction)(boundMethodResult.type) || (0, types_1.isOverloadedFunction)(boundMethodResult.type)) {
            return boundMethodResult.type;
        }
        if ((0, types_1.isClassInstance)(boundMethodResult.type)) {
            return getBoundMagicMethod(boundMethodResult.type, '__call__', selfType !== null && selfType !== void 0 ? selfType : types_1.ClassType.cloneAsInstance(classType), diag, recursionCount);
        }
        if ((0, types_1.isAnyOrUnknown)(boundMethodResult.type)) {
            return (0, typeUtils_1.getUnknownTypeForCallable)();
        }
        return undefined;
    }
    // Returns the signature(s) associated with a call node that contains
    // the specified node. It also returns the index of the argument
    // that contains the node.
    function getCallSignatureInfo(callNode, activeIndex, activeOrFake) {
        const exprNode = callNode.leftExpression;
        const callType = getType(exprNode);
        if (!callType) {
            return undefined;
        }
        const argList = [];
        let previousCategory = 0 /* ArgumentCategory.Simple */;
        // Empty arguments do not enter the AST as nodes, but instead are left blank.
        // Instead, we detect when we appear to be between two known arguments or at the
        // end of the argument list and insert a fake argument of an unknown type to have
        // something to match later.
        function addFakeArg() {
            argList.push({
                argumentCategory: previousCategory,
                typeResult: { type: types_1.UnknownType.create() },
                active: true,
            });
        }
        callNode.arguments.forEach((arg, index) => {
            let active = false;
            if (index === activeIndex) {
                if (activeOrFake) {
                    active = true;
                }
                else {
                    addFakeArg();
                }
            }
            previousCategory = arg.argumentCategory;
            argList.push({
                valueExpression: arg.valueExpression,
                argumentCategory: arg.argumentCategory,
                name: arg.name,
                active: active,
            });
        });
        if (callNode.arguments.length < activeIndex) {
            addFakeArg();
        }
        const signatures = [];
        function addOneFunctionToSignature(type) {
            let callResult;
            useSpeculativeMode(callNode, () => {
                callResult = validateArgs(exprNode, argList, { type }, new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(type)), 
                /* skipUnknownArgCheck */ true, 
                /* inferenceContext */ undefined, 
                /* signatureTracker */ undefined);
            });
            signatures.push({
                type: expandTypedKwargs(type),
                activeParam: callResult === null || callResult === void 0 ? void 0 : callResult.activeParam,
            });
        }
        function addFunctionToSignature(type) {
            if ((0, types_1.isFunction)(type)) {
                addOneFunctionToSignature(type);
            }
            else {
                types_1.OverloadedFunctionType.getOverloads(type).forEach((func) => {
                    addOneFunctionToSignature(func);
                });
            }
        }
        (0, typeUtils_1.doForEachSubtype)(callType, (subtype) => {
            switch (subtype.category) {
                case 4 /* TypeCategory.Function */:
                case 5 /* TypeCategory.OverloadedFunction */: {
                    addFunctionToSignature(subtype);
                    break;
                }
                case 6 /* TypeCategory.Class */: {
                    if (types_1.TypeBase.isInstantiable(subtype)) {
                        let constructorType;
                        // Try to get the `__init__` method first because it typically has more
                        // type information than `__new__`.
                        const initMethodResult = (0, constructors_1.getBoundInitMethod)(evaluatorInterface, callNode, types_1.ClassType.cloneAsInstance(subtype), 
                        /* diag */ undefined, 0 /* MemberAccessFlags.Default */);
                        if (initMethodResult && !initMethodResult.typeErrors) {
                            if ((0, types_1.isFunction)(initMethodResult.type) || (0, types_1.isOverloadedFunction)(initMethodResult.type)) {
                                constructorType = initMethodResult.type;
                            }
                        }
                        const isObjectInit = constructorType &&
                            (0, types_1.isFunction)(constructorType) &&
                            constructorType.details.fullName === 'builtins.object.__init__';
                        const isDefaultParams = constructorType &&
                            (0, types_1.isFunction)(constructorType) &&
                            types_1.FunctionType.hasDefaultParameters(constructorType);
                        // If there was no `__init__` or the only `__init__` that was found was from
                        // the `object` class or accepts only default parameters(* args, ** kwargs),
                        // see if we can find a better signature from the `__new__` method.
                        if (!constructorType || isObjectInit || isDefaultParams) {
                            const newMethodResult = (0, constructors_1.getBoundNewMethod)(evaluatorInterface, callNode, subtype);
                            if (newMethodResult && !newMethodResult.typeErrors) {
                                if ((0, types_1.isFunction)(newMethodResult.type) &&
                                    newMethodResult.type.details.fullName !== 'builtins.object.__new__') {
                                    constructorType = newMethodResult.type;
                                }
                                else if ((0, types_1.isOverloadedFunction)(newMethodResult.type)) {
                                    constructorType = newMethodResult.type;
                                }
                            }
                        }
                        if (constructorType) {
                            addFunctionToSignature(constructorType);
                        }
                    }
                    else {
                        const methodType = getBoundMagicMethod(subtype, '__call__');
                        if (methodType) {
                            addFunctionToSignature(methodType);
                        }
                    }
                    break;
                }
            }
        });
        if (signatures.length === 0) {
            return undefined;
        }
        return {
            callNode,
            signatures,
        };
    }
    // If the function includes a `**kwargs: Unpack[TypedDict]` parameter, the
    // parameter is expanded to include individual keyword args.
    function expandTypedKwargs(functionType) {
        var _a, _b;
        const kwargsIndex = functionType.details.parameters.findIndex((param) => param.category === 2 /* ParameterCategory.KwargsDict */);
        if (kwargsIndex < 0) {
            return functionType;
        }
        (0, debug_1.assert)(kwargsIndex === functionType.details.parameters.length - 1);
        const kwargsType = types_1.FunctionType.getEffectiveParameterType(functionType, kwargsIndex);
        if (!(0, types_1.isClassInstance)(kwargsType) || !types_1.ClassType.isTypedDictClass(kwargsType) || !kwargsType.isUnpacked) {
            return functionType;
        }
        const tdEntries = (_a = kwargsType.typedDictNarrowedEntries) !== null && _a !== void 0 ? _a : (_b = kwargsType.details.typedDictEntries) === null || _b === void 0 ? void 0 : _b.knownItems;
        if (!tdEntries) {
            return functionType;
        }
        const newFunction = types_1.FunctionType.clone(functionType);
        newFunction.details.parameters.splice(kwargsIndex);
        if (newFunction.specializedTypes) {
            newFunction.specializedTypes.parameterTypes.splice(kwargsIndex);
        }
        const kwSeparatorIndex = functionType.details.parameters.findIndex((param) => param.category === 1 /* ParameterCategory.ArgsList */);
        // Add a keyword separator if necessary.
        if (kwSeparatorIndex < 0) {
            types_1.FunctionType.addKeywordOnlyParameterSeparator(newFunction);
        }
        tdEntries.forEach((tdEntry, name) => {
            types_1.FunctionType.addParameter(newFunction, {
                category: 0 /* ParameterCategory.Simple */,
                name,
                hasDeclaredType: true,
                type: tdEntry.valueType,
                hasDefault: !tdEntry.isRequired,
                defaultType: tdEntry.valueType,
            });
        });
        return newFunction;
    }
    // Determines whether the specified expression is an explicit TypeAlias declaration.
    function isDeclaredTypeAlias(expression) {
        if (expression.nodeType === 54 /* ParseNodeType.TypeAnnotation */) {
            if (expression.valueExpression.nodeType === 38 /* ParseNodeType.Name */) {
                const symbolWithScope = lookUpSymbolRecursive(expression, expression.valueExpression.value, 
                /* honorCodeFlow */ false);
                if (symbolWithScope) {
                    const symbol = symbolWithScope.symbol;
                    return symbol.getDeclarations().find((decl) => isExplicitTypeAliasDeclaration(decl)) !== undefined;
                }
            }
        }
        return false;
    }
    // Determines whether the specified expression is a symbol with a declared type.
    function getDeclaredTypeForExpression(expression, usage) {
        var _a, _b;
        let symbol;
        let classOrObjectBase;
        let memberAccessClass;
        let bindFunction = true;
        let useDescriptorSetterType = false;
        switch (expression.nodeType) {
            case 38 /* ParseNodeType.Name */: {
                const symbolWithScope = lookUpSymbolRecursive(expression, expression.value, /* honorCodeFlow */ true);
                if (symbolWithScope) {
                    symbol = symbolWithScope.symbol;
                    // Handle the case where the symbol is a class-level variable
                    // where the type isn't declared in this class but is in
                    // a parent class.
                    if (!((_a = getDeclaredTypeOfSymbol(symbol, expression)) === null || _a === void 0 ? void 0 : _a.type) &&
                        symbolWithScope.scope.type === 3 /* ScopeType.Class */) {
                        const enclosingClass = ParseTreeUtils.getEnclosingClassOrFunction(expression);
                        if (enclosingClass && enclosingClass.nodeType === 10 /* ParseNodeType.Class */) {
                            const classTypeInfo = getTypeOfClass(enclosingClass);
                            if (classTypeInfo) {
                                const classMemberInfo = (0, typeUtils_1.lookUpClassMember)(classTypeInfo.classType, expression.value, 16 /* MemberAccessFlags.SkipInstanceMembers */ | 64 /* MemberAccessFlags.DeclaredTypesOnly */);
                                if (classMemberInfo) {
                                    symbol = classMemberInfo.symbol;
                                }
                            }
                        }
                    }
                }
                break;
            }
            case 54 /* ParseNodeType.TypeAnnotation */: {
                return getDeclaredTypeForExpression(expression.valueExpression, usage);
            }
            case 35 /* ParseNodeType.MemberAccess */: {
                const baseType = makeTopLevelTypeVarsConcrete(getTypeOfExpression(expression.leftExpression, 2 /* EvalFlags.MemberAccessBaseDefaults */).type);
                let classMemberInfo;
                if ((0, types_1.isClassInstance)(baseType)) {
                    classMemberInfo = (0, typeUtils_1.lookUpObjectMember)(baseType, expression.memberName.value, 64 /* MemberAccessFlags.DeclaredTypesOnly */);
                    classOrObjectBase = baseType;
                    memberAccessClass = classMemberInfo === null || classMemberInfo === void 0 ? void 0 : classMemberInfo.classType;
                    // If this is an instance member (e.g. a dataclass field), don't
                    // bind it to the object if it's a function.
                    if (classMemberInfo === null || classMemberInfo === void 0 ? void 0 : classMemberInfo.isInstanceMember) {
                        bindFunction = false;
                    }
                    useDescriptorSetterType = true;
                }
                else if ((0, types_1.isInstantiableClass)(baseType)) {
                    classMemberInfo = (0, typeUtils_1.lookUpClassMember)(baseType, expression.memberName.value, 16 /* MemberAccessFlags.SkipInstanceMembers */ | 64 /* MemberAccessFlags.DeclaredTypesOnly */);
                    classOrObjectBase = baseType;
                    memberAccessClass = classMemberInfo === null || classMemberInfo === void 0 ? void 0 : classMemberInfo.classType;
                }
                if (classMemberInfo) {
                    symbol = classMemberInfo.symbol;
                }
                break;
            }
            case 27 /* ParseNodeType.Index */: {
                const baseType = makeTopLevelTypeVarsConcrete(getTypeOfExpression(expression.baseExpression, 2 /* EvalFlags.IndexBaseDefaults */).type);
                if (baseType && (0, types_1.isClassInstance)(baseType)) {
                    const setItemType = getBoundMagicMethod(baseType, '__setitem__');
                    if (setItemType && (0, types_1.isFunction)(setItemType) && setItemType.details.parameters.length >= 2) {
                        const paramType = types_1.FunctionType.getEffectiveParameterType(setItemType, 1);
                        if (!(0, types_1.isAnyOrUnknown)(paramType)) {
                            return paramType;
                        }
                    }
                    else if (types_1.ClassType.isTypedDictClass(baseType)) {
                        const typeFromTypedDict = (0, typedDicts_1.getTypeOfIndexedTypedDict)(evaluatorInterface, expression, baseType, usage || { method: 'get' });
                        if (typeFromTypedDict) {
                            return typeFromTypedDict.type;
                        }
                    }
                }
                break;
            }
        }
        if (symbol) {
            let declaredType = (_b = getDeclaredTypeOfSymbol(symbol)) === null || _b === void 0 ? void 0 : _b.type;
            if (declaredType) {
                // If it's a descriptor, we need to get the setter type.
                if (useDescriptorSetterType && (0, types_1.isClassInstance)(declaredType)) {
                    const setter = getBoundMagicMethod(declaredType, '__set__');
                    if (setter && (0, types_1.isFunction)(setter) && setter.details.parameters.length >= 2) {
                        declaredType = setter.details.parameters[1].type;
                        if ((0, types_1.isAnyOrUnknown)(declaredType)) {
                            return undefined;
                        }
                    }
                }
                if (classOrObjectBase) {
                    if (memberAccessClass && (0, types_1.isInstantiableClass)(memberAccessClass)) {
                        declaredType = (0, typeUtils_1.partiallySpecializeType)(declaredType, memberAccessClass);
                    }
                    if ((0, types_1.isFunction)(declaredType) || (0, types_1.isOverloadedFunction)(declaredType)) {
                        if (bindFunction) {
                            declaredType = bindFunctionToClassOrObject(classOrObjectBase, declaredType);
                        }
                    }
                }
                return declaredType;
            }
        }
        return undefined;
    }
    // Applies an "await" operation to the specified type and returns
    // the result. According to PEP 492, await operates on an Awaitable
    // (object that provides an __await__ that returns a generator object).
    // If errorNode is undefined, no errors are reported.
    function getTypeOfAwaitable(type, errorNode) {
        if (!awaitableClass ||
            !(0, types_1.isInstantiableClass)(awaitableClass) ||
            awaitableClass.details.typeParameters.length !== 1) {
            return types_1.UnknownType.create();
        }
        const awaitableProtocolObj = types_1.ClassType.cloneAsInstance(awaitableClass);
        return (0, typeUtils_1.mapSubtypes)(type, (subtype) => {
            subtype = makeTopLevelTypeVarsConcrete(subtype);
            if ((0, types_1.isAnyOrUnknown)(subtype)) {
                return subtype;
            }
            const diag = errorNode ? new diagnostic_1.DiagnosticAddendum() : undefined;
            if ((0, types_1.isClassInstance)(subtype)) {
                const typeVarContext = new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(awaitableProtocolObj));
                if (assignType(awaitableProtocolObj, subtype, diag, typeVarContext)) {
                    const specializedType = (0, typeUtils_1.applySolvedTypeVars)(awaitableProtocolObj, typeVarContext);
                    if ((0, types_1.isClass)(specializedType) &&
                        specializedType.typeArguments &&
                        specializedType.typeArguments.length > 0) {
                        return specializedType.typeArguments[0];
                    }
                    return types_1.UnknownType.create();
                }
            }
            if (errorNode) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeNotAwaitable().format({ type: printType(subtype) }) + (diag === null || diag === void 0 ? void 0 : diag.getString()), errorNode);
            }
            return types_1.UnknownType.create();
        });
    }
    // Validates that the type is an iterator and returns the iterated type
    // (i.e. the type returned from the '__next__' or '__anext__' method).
    function getTypeOfIterator(typeResult, isAsync, errorNode, emitNotIterableError = true) {
        const iterMethodName = isAsync ? '__aiter__' : '__iter__';
        const nextMethodName = isAsync ? '__anext__' : '__next__';
        let isValidIterator = true;
        let type = (0, typeUtils_1.transformPossibleRecursiveTypeAlias)(typeResult.type);
        type = makeTopLevelTypeVarsConcrete(type);
        type = (0, types_1.removeUnbound)(type);
        if ((0, typeUtils_1.isOptionalType)(type) && emitNotIterableError) {
            if (!typeResult.isIncomplete) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportOptionalIterable, localize_1.LocMessage.noneNotIterable(), errorNode);
            }
            type = (0, typeUtils_1.removeNoneFromUnion)(type);
        }
        const iterableType = (0, typeUtils_1.mapSubtypes)(type, (subtype) => {
            subtype = makeTopLevelTypeVarsConcrete(subtype);
            if ((0, types_1.isAnyOrUnknown)(subtype)) {
                return subtype;
            }
            const diag = new diagnostic_1.DiagnosticAddendum();
            if ((0, types_1.isClass)(subtype)) {
                // Handle an empty tuple specially.
                if (types_1.TypeBase.isInstance(subtype) &&
                    (0, typeUtils_1.isTupleClass)(subtype) &&
                    subtype.tupleTypeArguments &&
                    subtype.tupleTypeArguments.length === 0) {
                    return types_1.NeverType.createNever();
                }
                const iterReturnType = getTypeOfMagicMethodCall(subtype, iterMethodName, [], errorNode);
                if (!iterReturnType) {
                    // There was no __iter__. See if we can fall back to
                    // the __getitem__ method instead.
                    if (!isAsync && (0, types_1.isClassInstance)(subtype)) {
                        const getItemReturnType = getTypeOfMagicMethodCall(subtype, '__getitem__', [
                            {
                                type: intClass && (0, types_1.isInstantiableClass)(intClass)
                                    ? types_1.ClassType.cloneAsInstance(intClass)
                                    : types_1.UnknownType.create(),
                            },
                        ], errorNode);
                        if (getItemReturnType) {
                            return getItemReturnType;
                        }
                    }
                    diag.addMessage(localize_1.LocMessage.methodNotDefined().format({ name: iterMethodName }));
                }
                else {
                    const iterReturnTypeDiag = new diagnostic_1.DiagnosticAddendum();
                    const returnType = mapSubtypesExpandTypeVars(iterReturnType, /* options */ undefined, (subtype) => {
                        if ((0, types_1.isAnyOrUnknown)(subtype)) {
                            return subtype;
                        }
                        if ((0, types_1.isClassInstance)(subtype)) {
                            let nextReturnType = getTypeOfMagicMethodCall(subtype, nextMethodName, [], errorNode);
                            if (!nextReturnType) {
                                iterReturnTypeDiag.addMessage(localize_1.LocMessage.methodNotDefinedOnType().format({
                                    name: nextMethodName,
                                    type: printType(subtype),
                                }));
                            }
                            else {
                                // Convert any unpacked TypeVarTuples into object instances. We don't
                                // know anything more about them.
                                nextReturnType = (0, typeUtils_1.mapSubtypes)(nextReturnType, (returnSubtype) => {
                                    if ((0, types_1.isTypeVar)(returnSubtype) && (0, types_1.isUnpackedVariadicTypeVar)(returnSubtype)) {
                                        return getObjectType();
                                    }
                                    return returnSubtype;
                                });
                                if (!isAsync) {
                                    return nextReturnType;
                                }
                                // If it's an async iteration, there's an implicit
                                // 'await' operator applied.
                                return getTypeOfAwaitable(nextReturnType, errorNode);
                            }
                        }
                        else {
                            iterReturnTypeDiag.addMessage(localize_1.LocMessage.methodReturnsNonObject().format({ name: iterMethodName }));
                        }
                        return undefined;
                    });
                    if (iterReturnTypeDiag.isEmpty()) {
                        return returnType;
                    }
                    diag.addAddendum(iterReturnTypeDiag);
                }
            }
            if (!typeResult.isIncomplete && emitNotIterableError) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeNotIterable().format({ type: printType(subtype) }) + diag.getString(), errorNode);
            }
            isValidIterator = false;
            return undefined;
        });
        return isValidIterator ? { type: iterableType, isIncomplete: typeResult.isIncomplete } : undefined;
    }
    // Validates that the type is an iterable and returns the iterable type argument.
    function getTypeOfIterable(typeResult, isAsync, errorNode, emitNotIterableError = true) {
        const iterMethodName = isAsync ? '__aiter__' : '__iter__';
        let isValidIterable = true;
        let type = makeTopLevelTypeVarsConcrete(typeResult.type);
        if ((0, typeUtils_1.isOptionalType)(type)) {
            if (!typeResult.isIncomplete && emitNotIterableError) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportOptionalIterable, localize_1.LocMessage.noneNotIterable(), errorNode);
            }
            type = (0, typeUtils_1.removeNoneFromUnion)(type);
        }
        const iterableType = (0, typeUtils_1.mapSubtypes)(type, (subtype) => {
            if ((0, types_1.isAnyOrUnknown)(subtype)) {
                return subtype;
            }
            if ((0, types_1.isClass)(subtype)) {
                const iterReturnType = getTypeOfMagicMethodCall(subtype, iterMethodName, [], errorNode);
                if (iterReturnType) {
                    return makeTopLevelTypeVarsConcrete(iterReturnType);
                }
            }
            if (emitNotIterableError) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeNotIterable().format({ type: printType(subtype) }), errorNode);
            }
            isValidIterable = false;
            return undefined;
        });
        return isValidIterable ? { type: iterableType, isIncomplete: typeResult.isIncomplete } : undefined;
    }
    function isTypeHashable(type) {
        let isTypeHashable = true;
        (0, typeUtils_1.doForEachSubtype)(makeTopLevelTypeVarsConcrete(type), (subtype) => {
            if ((0, types_1.isClassInstance)(subtype)) {
                // Assume the class is hashable.
                let isObjectHashable = true;
                // Have we already computed and cached the hashability?
                if (subtype.details.isInstanceHashable !== undefined) {
                    isObjectHashable = subtype.details.isInstanceHashable;
                }
                else {
                    const hashMember = (0, typeUtils_1.lookUpObjectMember)(subtype, '__hash__', 4 /* MemberAccessFlags.SkipObjectBaseClass */);
                    if (hashMember && hashMember.isTypeDeclared) {
                        const decls = hashMember.symbol.getTypedDeclarations();
                        const synthesizedType = hashMember.symbol.getSynthesizedType();
                        // Handle the case where the type is synthesized (used for
                        // dataclasses).
                        if (synthesizedType) {
                            isObjectHashable = !(0, typeUtils_1.isNoneInstance)(synthesizedType);
                        }
                        else {
                            // Assume that if '__hash__' is declared as a variable, it is
                            // not hashable. If it's declared as a function, it is. We'll
                            // skip evaluating its full type because that's not needed in
                            // this case.
                            if (decls.every((decl) => decl.type === 1 /* DeclarationType.Variable */)) {
                                isObjectHashable = false;
                            }
                        }
                    }
                    // Cache the hashability for next time.
                    subtype.details.isInstanceHashable = isObjectHashable;
                }
                if (!isObjectHashable) {
                    isTypeHashable = false;
                }
            }
        });
        return isTypeHashable;
    }
    function getTypedDictClassType() {
        return typedDictPrivateClass && (0, types_1.isInstantiableClass)(typedDictPrivateClass) ? typedDictPrivateClass : undefined;
    }
    function getTupleClassType() {
        return tupleClass && (0, types_1.isInstantiableClass)(tupleClass) ? tupleClass : undefined;
    }
    function getObjectType() {
        return objectClass ? (0, typeUtils_1.convertToInstance)(objectClass) : types_1.UnknownType.create();
    }
    function getNoneType() {
        return noneTypeClass ? (0, typeUtils_1.convertToInstance)(noneTypeClass) : types_1.UnknownType.create();
    }
    function getUnionClassType() {
        return unionTypeClass !== null && unionTypeClass !== void 0 ? unionTypeClass : types_1.UnknownType.create();
    }
    function getTypingType(node, symbolName) {
        var _a;
        return ((_a = getTypeOfModule(node, symbolName, ['typing'])) !== null && _a !== void 0 ? _a : getTypeOfModule(node, symbolName, ['typing_extensions']));
    }
    function getTypesType(node, symbolName) {
        return getTypeOfModule(node, symbolName, ['types']);
    }
    function getTypeshedType(node, symbolName) {
        return getTypeOfModule(node, symbolName, ['_typeshed']);
    }
    function getTypeOfModule(node, symbolName, nameParts) {
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        const lookupResult = importLookup({ nameParts, importingFileUri: fileInfo.fileUri });
        if (!lookupResult) {
            return undefined;
        }
        const symbol = lookupResult.symbolTable.get(symbolName);
        if (!symbol) {
            return undefined;
        }
        return getEffectiveTypeOfSymbol(symbol);
    }
    function checkCodeFlowTooComplex(node) {
        const scopeNode = node.nodeType === 31 /* ParseNodeType.Function */ ? node : ParseTreeUtils.getExecutionScopeNode(node);
        const codeComplexity = AnalyzerNodeInfo.getCodeFlowComplexity(scopeNode);
        if (codeComplexity > exports.maxCodeComplexity) {
            let errorRange = scopeNode;
            if (scopeNode.nodeType === 31 /* ParseNodeType.Function */) {
                errorRange = scopeNode.name;
            }
            else if (scopeNode.nodeType === 36 /* ParseNodeType.Module */) {
                errorRange = { start: 0, length: 0 };
            }
            const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
            addDiagnosticForTextRange(fileInfo, diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.codeTooComplexToAnalyze(), errorRange);
            return true;
        }
        return false;
    }
    function isNodeReachable(node, sourceNode) {
        if (checkCodeFlowTooComplex(node)) {
            return true;
        }
        const flowNode = AnalyzerNodeInfo.getFlowNode(node);
        if (!flowNode) {
            if (node.parent) {
                return isNodeReachable(node.parent, sourceNode);
            }
            return false;
        }
        const sourceFlowNode = sourceNode ? AnalyzerNodeInfo.getFlowNode(sourceNode) : undefined;
        return codeFlowEngine.isFlowNodeReachable(flowNode, sourceFlowNode);
    }
    function isAfterNodeReachable(node) {
        const returnFlowNode = AnalyzerNodeInfo.getAfterFlowNode(node);
        if (!returnFlowNode) {
            return false;
        }
        if (checkCodeFlowTooComplex(node)) {
            return true;
        }
        if (!codeFlowEngine.isFlowNodeReachable(returnFlowNode)) {
            return false;
        }
        if (!isFlowNodeReachableUsingNeverNarrowing(node, returnFlowNode)) {
            return false;
        }
        return true;
    }
    // Although isFlowNodeReachable indicates that the node is reachable, it
    // may not be reachable if we apply "never narrowing".
    function isFlowNodeReachableUsingNeverNarrowing(node, flowNode) {
        const analyzer = getCodeFlowAnalyzerForNode(node.id, /* typeAtStart */ undefined);
        if (checkCodeFlowTooComplex(node)) {
            return true;
        }
        const codeFlowResult = analyzer.getTypeFromCodeFlow(flowNode, /* reference */ undefined, {
            typeAtStart: { type: types_1.UnboundType.create() },
        });
        return codeFlowResult.type !== undefined && !(0, types_1.isNever)(codeFlowResult.type);
    }
    // Determines whether there is a code flow path from sourceNode to sinkNode.
    function isFlowPathBetweenNodes(sourceNode, sinkNode, allowSelf = true) {
        if (checkCodeFlowTooComplex(sourceNode)) {
            return true;
        }
        const sourceFlowNode = AnalyzerNodeInfo.getFlowNode(sourceNode);
        const sinkFlowNode = AnalyzerNodeInfo.getFlowNode(sinkNode);
        if (!sourceFlowNode || !sinkFlowNode) {
            return false;
        }
        if (sourceFlowNode === sinkFlowNode) {
            return allowSelf;
        }
        return codeFlowEngine.isFlowNodeReachable(sinkFlowNode, sourceFlowNode, /* ignoreNoReturn */ true);
    }
    // Determines whether the specified string literal is part
    // of a Literal['xxx'] statement. If so, we will not treat
    // the string as a normal forward-declared type annotation.
    function isAnnotationLiteralValue(node) {
        if (node.parent && node.parent.nodeType === 27 /* ParseNodeType.Index */) {
            const baseType = getTypeOfExpression(node.parent.baseExpression).type;
            if (baseType && (0, types_1.isInstantiableClass)(baseType)) {
                if (types_1.ClassType.isSpecialBuiltIn(baseType, 'Literal')) {
                    return true;
                }
            }
        }
        return false;
    }
    function addInformation(message, node, range) {
        return addDiagnosticWithSuppressionCheck('information', message, node, range);
    }
    function addError(message, node, range) {
        return addDiagnosticWithSuppressionCheck('error', message, node, range);
    }
    function addUnusedCode(node, textRange) {
        if (!isDiagnosticSuppressedForNode(node)) {
            const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
            fileInfo.diagnosticSink.addUnusedCodeWithTextRange(localize_1.LocMessage.unreachableCode(), textRange);
        }
    }
    function addUnreachableCode(node, textRange) {
        if (!isDiagnosticSuppressedForNode(node)) {
            const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
            fileInfo.diagnosticSink.addUnreachableCodeWithTextRange(localize_1.LocMessage.unreachableCode(), textRange);
        }
    }
    function addDeprecated(message, node) {
        if (!isDiagnosticSuppressedForNode(node)) {
            const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
            fileInfo.diagnosticSink.addDeprecatedWithTextRange(message, node);
        }
    }
    function addDiagnosticWithSuppressionCheck(diagLevel, message, node, range) {
        var _a;
        if (isDiagnosticSuppressedForNode(node)) {
            // See if this node is suppressed but the diagnostic should be generated
            // anyway so it can be used by the caller that requested the suppression.
            const suppressionEntry = suppressedNodeStack.find((suppressedNode) => ParseTreeUtils.isNodeContainedWithin(node, suppressedNode.node) && suppressedNode.suppressedDiags);
            (_a = suppressionEntry === null || suppressionEntry === void 0 ? void 0 : suppressionEntry.suppressedDiags) === null || _a === void 0 ? void 0 : _a.push(message);
            return undefined;
        }
        if (isNodeReachable(node)) {
            const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
            return fileInfo.diagnosticSink.addDiagnosticWithTextRange(diagLevel, message, range !== null && range !== void 0 ? range : node);
        }
        return undefined;
    }
    function isDiagnosticSuppressedForNode(node) {
        if (speculativeTypeTracker.isSpeculative(node, /* ignoreIfDiagnosticsAllowed */ true)) {
            return true;
        }
        return suppressedNodeStack.some((suppressedNode) => ParseTreeUtils.isNodeContainedWithin(node, suppressedNode.node));
    }
    // This function is similar to isDiagnosticSuppressedForNode except that it
    // returns false if diagnostics are suppressed for the node but the caller
    // has requested that diagnostics be generated anyway.
    function canSkipDiagnosticForNode(node) {
        if (speculativeTypeTracker.isSpeculative(node, /* ignoreIfDiagnosticsAllowed */ true)) {
            return true;
        }
        const suppressedEntries = suppressedNodeStack.filter((suppressedNode) => ParseTreeUtils.isNodeContainedWithin(node, suppressedNode.node));
        if (suppressedEntries.length === 0) {
            return false;
        }
        return suppressedEntries.every((entry) => !entry.suppressedDiags);
    }
    function addDiagnostic(rule, message, node, range) {
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        const diagLevel = fileInfo.diagnosticRuleSet[rule];
        if (diagLevel === 'none') {
            return undefined;
        }
        const containingFunction = ParseTreeUtils.getEnclosingFunction(node);
        if (containingFunction) {
            // Should we suppress this diagnostic because it's within an unannotated function?
            const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
            if (!fileInfo.diagnosticRuleSet.analyzeUnannotatedFunctions) {
                // Is the target node within the body of the function? If so, suppress the diagnostic.
                if (ParseTreeUtils.isUnannotatedFunction(containingFunction) &&
                    ParseTreeUtils.isNodeContainedWithin(node, containingFunction.suite)) {
                    return undefined;
                }
            }
            // Should we suppress this diagnostic because it's within a no_type_check function?
            const containingClassNode = ParseTreeUtils.getEnclosingClass(containingFunction, /* stopAtFunction */ true);
            const functionInfo = (0, decorators_1.getFunctionInfoFromDecorators)(evaluatorInterface, containingFunction, !!containingClassNode);
            if ((functionInfo.flags & 524288 /* FunctionTypeFlags.NoTypeCheck */) !== 0) {
                return undefined;
            }
        }
        const diagnostic = addDiagnosticWithSuppressionCheck(diagLevel, message, node, range);
        if (diagnostic) {
            diagnostic.setRule(rule);
        }
        return diagnostic;
    }
    function addDiagnosticForTextRange(fileInfo, rule, message, range) {
        const diagLevel = fileInfo.diagnosticRuleSet[rule];
        if (diagLevel === 'none') {
            return undefined;
        }
        const diagnostic = fileInfo.diagnosticSink.addDiagnosticWithTextRange(diagLevel, message, range);
        if (rule) {
            diagnostic.setRule(rule);
        }
        return diagnostic;
    }
    function assignTypeToNameNode(nameNode, typeResult, ignoreEmptyContainers, srcExpression, allowAssignmentToFinalVar = false, expectedTypeDiagAddendum) {
        var _a, _b, _c;
        const nameValue = nameNode.value;
        const symbolWithScope = lookUpSymbolRecursive(nameNode, nameValue, /* honorCodeFlow */ false);
        if (!symbolWithScope) {
            // This can happen when we are evaluating a piece of code that was
            // determined to be unreachable by the binder.
            return;
        }
        const declarations = symbolWithScope.symbol.getDeclarations();
        let declaredType = (_a = getDeclaredTypeOfSymbol(symbolWithScope.symbol)) === null || _a === void 0 ? void 0 : _a.type;
        const fileInfo = AnalyzerNodeInfo.getFileInfo(nameNode);
        // If this is a class scope and there is no type declared for this class variable,
        // see if a parent class has a type declared.
        if (declaredType === undefined && symbolWithScope.scope.type === 3 /* ScopeType.Class */) {
            const containingClass = ParseTreeUtils.getEnclosingClass(nameNode);
            if (containingClass) {
                const classType = getTypeOfClass(containingClass);
                if (classType) {
                    const memberInfo = (0, typeUtils_1.lookUpClassMember)(classType.classType, nameNode.value, 1 /* MemberAccessFlags.SkipOriginalClass */);
                    if (memberInfo === null || memberInfo === void 0 ? void 0 : memberInfo.isTypeDeclared) {
                        declaredType = getTypeOfMember(memberInfo);
                    }
                }
            }
        }
        // We found an existing declared type. Make sure the type is assignable.
        let destType = typeResult.type;
        const isTypeAlias = !!declaredType && (0, types_1.isClassInstance)(declaredType) && types_1.ClassType.isBuiltIn(declaredType, 'TypeAlias');
        if (declaredType && !isTypeAlias) {
            let diagAddendum = new diagnostic_1.DiagnosticAddendum();
            if (!assignType(declaredType, typeResult.type, diagAddendum)) {
                // If there was an expected type mismatch, use that diagnostic
                // addendum because it will be more informative.
                if (expectedTypeDiagAddendum) {
                    diagAddendum = expectedTypeDiagAddendum;
                }
                if (!typeResult.isIncomplete) {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportAssignmentType, localize_1.LocMessage.typeAssignmentMismatch().format(printSrcDestTypes(typeResult.type, declaredType)) +
                        diagAddendum.getString(), srcExpression !== null && srcExpression !== void 0 ? srcExpression : nameNode, (_c = (_b = diagAddendum.getEffectiveTextRange()) !== null && _b !== void 0 ? _b : srcExpression) !== null && _c !== void 0 ? _c : nameNode);
                }
                // Replace the assigned type with the (unnarrowed) declared type.
                destType = declaredType;
            }
            else {
                // Constrain the resulting type to match the declared type.
                destType = narrowTypeBasedOnAssignment(nameNode, declaredType, typeResult).type;
            }
        }
        else {
            // If this is a member name (within a class scope) and the member name
            // appears to be a constant, use the strict source type. If it's a member
            // variable that can be overridden by a child class, use the more general
            // version by stripping off the literal.
            const scope = ScopeUtils.getScopeForNode(nameNode);
            if ((scope === null || scope === void 0 ? void 0 : scope.type) === 3 /* ScopeType.Class */) {
                if (types_1.TypeBase.isInstance(destType) &&
                    !(0, symbolNameUtils_1.isConstantName)(nameValue) &&
                    !isFinalVariable(symbolWithScope.symbol)) {
                    destType = stripLiteralValue(destType);
                }
            }
        }
        const varDeclIndex = declarations.findIndex((decl) => decl.type === 1 /* DeclarationType.Variable */);
        const varDecl = varDeclIndex >= 0 ? declarations[varDeclIndex] : undefined;
        // Are there any non-var decls before the var decl?
        const nonVarDecl = declarations.find((decl, index) => varDeclIndex < index && decl.type !== 1 /* DeclarationType.Variable */);
        if (varDecl && varDecl.type === 1 /* DeclarationType.Variable */) {
            if (varDecl.isConstant) {
                // A constant variable can be assigned only once. If this
                // isn't the first assignment, generate an error.
                if (nameNode !== (0, declarationUtils_1.getNameNodeForDeclaration)(declarations[0]) || !!nonVarDecl) {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportConstantRedefinition, localize_1.LocMessage.constantRedefinition().format({ name: nameValue }), nameNode);
                }
            }
            else if (isFinalVariableDeclaration(varDecl) && !allowAssignmentToFinalVar) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.finalReassigned().format({ name: nameValue }), nameNode);
            }
        }
        if (!typeResult.isIncomplete) {
            reportPossibleUnknownAssignment(fileInfo.diagnosticRuleSet.reportUnknownVariableType, diagnosticRules_1.DiagnosticRule.reportUnknownVariableType, nameNode, destType, nameNode, ignoreEmptyContainers);
        }
        writeTypeCache(nameNode, { type: destType, isIncomplete: typeResult.isIncomplete }, 0 /* EvalFlags.None */);
    }
    function assignTypeToMemberAccessNode(target, typeResult, srcExpr, expectedTypeDiagAddendum) {
        var _a;
        const baseTypeResult = getTypeOfExpression(target.leftExpression, 2 /* EvalFlags.MemberAccessBaseDefaults */);
        const baseType = makeTopLevelTypeVarsConcrete(baseTypeResult.type);
        // Handle member accesses (e.g. self.x or cls.y).
        if (target.leftExpression.nodeType === 38 /* ParseNodeType.Name */) {
            // Determine whether we're writing to a class or instance member.
            const enclosingClassNode = ParseTreeUtils.getEnclosingClass(target);
            if (enclosingClassNode) {
                const classTypeResults = getTypeOfClass(enclosingClassNode);
                if (classTypeResults && (0, types_1.isInstantiableClass)(classTypeResults.classType)) {
                    if ((0, types_1.isClassInstance)(baseType)) {
                        if (types_1.ClassType.isSameGenericClass(baseType, classTypeResults.classType)) {
                            assignTypeToMemberVariable(target, typeResult, /* isInstanceMember */ true, srcExpr);
                        }
                    }
                    else if ((0, types_1.isInstantiableClass)(baseType)) {
                        if (types_1.ClassType.isSameGenericClass(baseType, classTypeResults.classType)) {
                            assignTypeToMemberVariable(target, typeResult, /* isInstanceMember */ false, srcExpr);
                        }
                    }
                    // Assignments to instance or class variables through "self" or "cls" is not
                    // allowed for protocol classes unless it is also declared within the class.
                    if (types_1.ClassType.isProtocolClass(classTypeResults.classType)) {
                        const memberSymbol = types_1.ClassType.getSymbolTable(classTypeResults.classType).get(target.memberName.value);
                        if (memberSymbol) {
                            const classLevelDecls = memberSymbol.getDeclarations().filter((decl) => {
                                return !ParseTreeUtils.getEnclosingFunction(decl.node);
                            });
                            if (classLevelDecls.length === 0) {
                                addError(localize_1.LocMessage.assignmentInProtocol(), target.memberName);
                            }
                        }
                    }
                }
            }
        }
        const setTypeResult = getTypeOfMemberAccessWithBaseType(target, baseTypeResult, {
            method: 'set',
            setType: typeResult,
            setErrorNode: srcExpr,
            setExpectedTypeDiag: expectedTypeDiagAddendum,
        }, 0 /* EvalFlags.None */);
        if (setTypeResult.isAsymmetricAccessor) {
            setAsymmetricDescriptorAssignment(target);
        }
        const resultToCache = {
            type: (_a = setTypeResult.narrowedTypeForSet) !== null && _a !== void 0 ? _a : typeResult.type,
            isIncomplete: typeResult.isIncomplete,
            memberAccessDeprecationInfo: setTypeResult.memberAccessDeprecationInfo,
        };
        writeTypeCache(target.memberName, resultToCache, 0 /* EvalFlags.None */);
        writeTypeCache(target, resultToCache, 0 /* EvalFlags.None */);
    }
    function assignTypeToMemberVariable(node, typeResult, isInstanceMember, srcExprNode) {
        var _a;
        const memberName = node.memberName.value;
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        const classDef = ParseTreeUtils.getEnclosingClass(node);
        if (!classDef) {
            return;
        }
        const classTypeInfo = getTypeOfClass(classDef);
        if (classTypeInfo && (0, types_1.isInstantiableClass)(classTypeInfo.classType)) {
            let memberInfo = (0, typeUtils_1.lookUpClassMember)(classTypeInfo.classType, memberName, isInstanceMember ? 0 /* MemberAccessFlags.Default */ : 16 /* MemberAccessFlags.SkipInstanceMembers */);
            const memberFields = types_1.ClassType.getSymbolTable(classTypeInfo.classType);
            if (memberInfo) {
                // Are we accessing an existing member on this class, or is
                // it a member on a parent class?
                const memberClass = (0, types_1.isInstantiableClass)(memberInfo.classType) ? memberInfo.classType : undefined;
                const isThisClass = memberClass && types_1.ClassType.isSameGenericClass(classTypeInfo.classType, memberClass);
                // Check for an attempt to write to an instance variable that is
                // not defined by __slots__.
                if (isThisClass && isInstanceMember && memberClass) {
                    const inheritedSlotsNames = types_1.ClassType.getInheritedSlotsNames(memberClass);
                    if (inheritedSlotsNames && memberClass.details.localSlotsNames) {
                        // Skip this check if the local slots is specified but empty because this pattern
                        // is used in a legitimate manner for mix-in classes.
                        if (memberClass.details.localSlotsNames.length > 0 &&
                            !inheritedSlotsNames.some((name) => name === memberName)) {
                            // Determine whether the assignment corresponds to a descriptor
                            // that was assigned as a class variable. If so, then slots will not
                            // apply in this case.
                            const classMemberDetails = (0, typeUtils_1.lookUpClassMember)(memberClass, memberName, 16 /* MemberAccessFlags.SkipInstanceMembers */);
                            let isPotentiallyDescriptor = false;
                            if (classMemberDetails) {
                                const classMemberSymbolType = getEffectiveTypeOfSymbol(classMemberDetails.symbol);
                                if ((0, types_1.isAnyOrUnknown)(classMemberSymbolType) ||
                                    (0, types_1.isUnbound)(classMemberSymbolType) ||
                                    (0, typeUtils_1.isMaybeDescriptorInstance)(classMemberSymbolType)) {
                                    isPotentiallyDescriptor = true;
                                }
                            }
                            if (!isPotentiallyDescriptor) {
                                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.slotsAttributeError().format({ name: memberName }), node.memberName);
                            }
                        }
                    }
                }
                if (isThisClass && memberInfo.isInstanceMember === isInstanceMember) {
                    const symbol = memberFields.get(memberName);
                    (0, debug_1.assert)(symbol !== undefined);
                    const typedDecls = symbol.getDeclarations();
                    // Check for an attempt to overwrite a constant member variable.
                    if (typedDecls.length > 0 &&
                        typedDecls[0].type === 1 /* DeclarationType.Variable */ &&
                        srcExprNode &&
                        node.memberName !== typedDecls[0].node) {
                        if (typedDecls[0].isConstant) {
                            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportConstantRedefinition, localize_1.LocMessage.constantRedefinition().format({ name: node.memberName.value }), node.memberName);
                        }
                    }
                }
                else {
                    // Is the target a property?
                    const declaredType = (_a = getDeclaredTypeOfSymbol(memberInfo.symbol)) === null || _a === void 0 ? void 0 : _a.type;
                    if (declaredType && !(0, typeUtils_1.isProperty)(declaredType)) {
                        // Handle the case where there is a class variable defined with the same
                        // name, but there's also now an instance variable introduced. Combine the
                        // type of the class variable with that of the new instance variable.
                        if (!memberInfo.isInstanceMember && isInstanceMember) {
                            // The class variable is accessed in this case.
                            setSymbolAccessed(fileInfo, memberInfo.symbol, node.memberName);
                            const memberType = getTypeOfMember(memberInfo);
                            typeResult = { ...typeResult, type: (0, types_1.combineTypes)([typeResult.type, memberType]) };
                        }
                    }
                }
            }
            // Look up the member info again, now that we've potentially updated it.
            memberInfo = (0, typeUtils_1.lookUpClassMember)(classTypeInfo.classType, memberName, 64 /* MemberAccessFlags.DeclaredTypesOnly */);
            if (!memberInfo && srcExprNode && !typeResult.isIncomplete) {
                reportPossibleUnknownAssignment(fileInfo.diagnosticRuleSet.reportUnknownMemberType, diagnosticRules_1.DiagnosticRule.reportUnknownMemberType, node.memberName, typeResult.type, node, 
                /* ignoreEmptyContainers */ true);
            }
        }
    }
    function assignTypeToTupleOrListNode(target, typeResult, srcExpr) {
        const targetExpressions = target.nodeType === 34 /* ParseNodeType.List */ ? target.entries : target.expressions;
        // Initialize the array of target types, one for each target.
        const targetTypes = new Array(targetExpressions.length);
        for (let i = 0; i < targetExpressions.length; i++) {
            targetTypes[i] = [];
        }
        const targetUnpackIndex = targetExpressions.findIndex((expr) => expr.nodeType === 56 /* ParseNodeType.Unpack */);
        // Do any of the targets use an unpack operator? If so, it will consume all of the
        // entries at that location.
        const unpackIndex = targetExpressions.findIndex((expr) => expr.nodeType === 56 /* ParseNodeType.Unpack */);
        typeResult = { ...typeResult, type: makeTopLevelTypeVarsConcrete(typeResult.type) };
        const diagAddendum = new diagnostic_1.DiagnosticAddendum();
        (0, typeUtils_1.doForEachSubtype)(typeResult.type, (subtype) => {
            var _a, _b;
            // Is this subtype a tuple?
            const tupleType = (0, typeUtils_1.getSpecializedTupleType)(subtype);
            if (tupleType && tupleType.tupleTypeArguments) {
                const sourceEntryTypes = tupleType.tupleTypeArguments.map((t) => (0, typeUtils_1.addConditionToType)(t.type, (0, typeUtils_1.getTypeCondition)(subtype), /* skipSelfCondition */ true));
                const unboundedIndex = tupleType.tupleTypeArguments.findIndex((t) => t.isUnbounded);
                if (unboundedIndex >= 0) {
                    if (sourceEntryTypes.length < targetTypes.length) {
                        const typeToReplicate = sourceEntryTypes.length > 0 ? sourceEntryTypes[unboundedIndex] : types_1.AnyType.create();
                        // Add elements to make the count match the target count.
                        while (sourceEntryTypes.length < targetTypes.length) {
                            sourceEntryTypes.splice(unboundedIndex, 0, typeToReplicate);
                        }
                    }
                }
                // If there's an unpack operator in the target and we have too many source elements,
                // combine them to assign to the unpacked target.
                if (targetUnpackIndex >= 0) {
                    if (sourceEntryTypes.length > targetTypes.length) {
                        const removedEntries = sourceEntryTypes.splice(targetUnpackIndex, sourceEntryTypes.length - targetTypes.length + 1);
                        let combinedTypes = (0, types_1.combineTypes)(removedEntries);
                        if (target.nodeType === 34 /* ParseNodeType.List */) {
                            combinedTypes = stripLiteralValue(combinedTypes);
                        }
                        sourceEntryTypes.splice(targetUnpackIndex, 0, combinedTypes);
                    }
                    else if (sourceEntryTypes.length === targetTypes.length - 1) {
                        sourceEntryTypes.splice(targetUnpackIndex, 0, types_1.NeverType.createNever());
                    }
                }
                sourceEntryTypes.forEach((type, targetIndex) => {
                    if (targetIndex < targetTypes.length) {
                        targetTypes[targetIndex].push(type);
                    }
                });
                // Have we accounted for all of the targets and sources? If not, we have a size mismatch.
                if (sourceEntryTypes.length !== targetExpressions.length) {
                    const subDiag = diagAddendum.createAddendum();
                    subDiag.addMessage((target.nodeType === 34 /* ParseNodeType.List */
                        ? localize_1.LocAddendum.listAssignmentMismatch()
                        : localize_1.LocAddendum.tupleAssignmentMismatch()).format({
                        type: printType(subtype),
                    }));
                    subDiag.createAddendum().addMessage((unpackIndex >= 0
                        ? localize_1.LocAddendum.tupleSizeMismatchIndeterminateDest()
                        : localize_1.LocAddendum.tupleSizeMismatch()).format({
                        expected: unpackIndex >= 0 ? targetExpressions.length - 1 : targetExpressions.length,
                        received: sourceEntryTypes.length,
                    }));
                }
            }
            else {
                // The assigned expression isn't a tuple, so it had better
                // be some iterable type.
                const iterableType = (_b = (_a = getTypeOfIterator({ type: subtype, isIncomplete: typeResult.isIncomplete }, 
                /* isAsync */ false, srcExpr)) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : types_1.UnknownType.create();
                for (let index = 0; index < targetExpressions.length; index++) {
                    targetTypes[index].push((0, typeUtils_1.addConditionToType)(iterableType, (0, typeUtils_1.getTypeCondition)(subtype)));
                }
            }
        });
        if (!diagAddendum.isEmpty()) {
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportAssignmentType, (target.nodeType === 34 /* ParseNodeType.List */
                ? localize_1.LocMessage.listAssignmentMismatch()
                : localize_1.LocMessage.tupleAssignmentMismatch()).format({
                type: printType(typeResult.type),
            }) + diagAddendum.getString(), target);
        }
        // Assign the resulting types to the individual names in the tuple
        // or list target expression.
        targetExpressions.forEach((expr, index) => {
            const typeList = targetTypes[index];
            const targetType = typeList.length === 0 ? types_1.UnknownType.create() : (0, types_1.combineTypes)(typeList);
            assignTypeToExpression(expr, { type: targetType, isIncomplete: typeResult.isIncomplete }, srcExpr, 
            /* ignoreEmptyContainers */ true);
        });
        writeTypeCache(target, typeResult, 0 /* EvalFlags.None */);
    }
    // If the type includes promotion types, expand these to their constituent types.
    function expandPromotionTypes(node, type, excludeBytes = false) {
        return (0, typeUtils_1.mapSubtypes)(type, (subtype) => {
            if (!(0, types_1.isClass)(subtype) || !subtype.includePromotions) {
                return subtype;
            }
            if (excludeBytes && types_1.ClassType.isBuiltIn(subtype, 'bytes')) {
                return subtype;
            }
            const typesToCombine = [types_1.ClassType.cloneRemoveTypePromotions(subtype)];
            const promotionTypeNames = typePromotions.get(subtype.details.fullName);
            if (promotionTypeNames) {
                for (const promotionTypeName of promotionTypeNames) {
                    const nameSplit = promotionTypeName.split('.');
                    let promotionSubtype = getBuiltInType(node, nameSplit[nameSplit.length - 1]);
                    if (promotionSubtype && (0, types_1.isInstantiableClass)(promotionSubtype)) {
                        promotionSubtype = types_1.ClassType.cloneRemoveTypePromotions(promotionSubtype);
                        if ((0, types_1.isClassInstance)(subtype)) {
                            promotionSubtype = types_1.ClassType.cloneAsInstance(promotionSubtype);
                        }
                        promotionSubtype = (0, typeUtils_1.addConditionToType)(promotionSubtype, subtype.condition);
                        typesToCombine.push(promotionSubtype);
                    }
                }
            }
            return (0, types_1.combineTypes)(typesToCombine);
        });
    }
    // Replaces all of the top-level TypeVars (as opposed to TypeVars
    // used as type arguments in other types) with their concrete form.
    // If conditionFilter is specified and the TypeVar is a constrained
    // TypeVar, only the conditions that match the filter will be included.
    function makeTopLevelTypeVarsConcrete(type, makeParamSpecsConcrete = false, conditionFilter) {
        return (0, typeUtils_1.mapSubtypes)(type, (subtype) => {
            var _a;
            if ((0, types_1.isParamSpec)(subtype)) {
                if (subtype.paramSpecAccess === 'args') {
                    return makeTupleObject([{ type: getObjectType(), isUnbounded: true }]);
                }
                else if (subtype.paramSpecAccess === 'kwargs') {
                    if (dictClass && (0, types_1.isInstantiableClass)(dictClass) && strClass && (0, types_1.isInstantiableClass)(strClass)) {
                        return types_1.ClassType.cloneAsInstance(types_1.ClassType.cloneForSpecialization(dictClass, [(0, typeUtils_1.convertToInstance)(strClass), getObjectType()], 
                        /* isTypeArgumentExplicit */ true));
                    }
                    return types_1.UnknownType.create();
                }
            }
            // If this is a function that contains only a ParamSpec (no additional
            // parameters), convert it to a concrete type of (*args: Any, **kwargs: Any).
            if (makeParamSpecsConcrete && (0, types_1.isFunction)(subtype)) {
                const convertedType = (0, typeUtils_1.convertParamSpecValueToType)(subtype);
                if ((0, types_1.isParamSpec)(convertedType)) {
                    return types_1.FunctionType.applyParamSpecValue(subtype, (0, typeUtils_1.getUnknownTypeForCallable)());
                }
            }
            if ((0, types_1.isTypeVar)(subtype) && subtype.details.isVariadic) {
                // If it's in a union, convert to type or object.
                if (subtype.isVariadicInUnion) {
                    if (types_1.TypeBase.isInstantiable(subtype)) {
                        if (typeClass && (0, types_1.isInstantiableClass)(typeClass)) {
                            return typeClass;
                        }
                    }
                    else {
                        return getObjectType();
                    }
                    return types_1.AnyType.create();
                }
                // Fall back to "*tuple[object, ...]".
                return makeTupleObject([{ type: getObjectType(), isUnbounded: true }], /* isUnpacked */ true);
            }
            if ((0, types_1.isTypeVar)(subtype)) {
                // If this is a recursive type alias placeholder
                // that hasn't yet been resolved, return it as is.
                if (subtype.details.recursiveTypeAliasName) {
                    return subtype;
                }
                if (subtype.details.constraints.length > 0) {
                    const typesToCombine = [];
                    // Expand the list of constrained subtypes, filtering out any that are
                    // disallowed by the conditionFilter.
                    subtype.details.constraints.forEach((constraintType, constraintIndex) => {
                        if (conditionFilter) {
                            const typeVarName = types_1.TypeVarType.getNameWithScope(subtype);
                            const applicableConstraint = conditionFilter.find((filter) => filter.typeVar.nameWithScope === typeVarName);
                            // If this type variable is being constrained to a single index,
                            // don't include the other indices.
                            if (applicableConstraint && applicableConstraint.constraintIndex !== constraintIndex) {
                                return;
                            }
                        }
                        if (types_1.TypeBase.isInstantiable(subtype)) {
                            constraintType = (0, typeUtils_1.convertToInstantiable)(constraintType);
                        }
                        typesToCombine.push((0, typeUtils_1.addConditionToType)(constraintType, [{ typeVar: subtype, constraintIndex }]));
                    });
                    return (0, types_1.combineTypes)(typesToCombine);
                }
                if (subtype.details.isExemptFromBoundCheck) {
                    return types_1.AnyType.create();
                }
                // Fall back to a bound of "object" if no bound is provided.
                let boundType = (_a = subtype.details.boundType) !== null && _a !== void 0 ? _a : getObjectType();
                boundType = types_1.TypeBase.isInstantiable(subtype) ? (0, typeUtils_1.convertToInstantiable)(boundType) : boundType;
                return (0, typeUtils_1.addConditionToType)(boundType, [{ typeVar: subtype, constraintIndex: 0 }]);
            }
            return subtype;
        });
    }
    // Creates a new type by mapping an existing type (which could be a union)
    // to another type or types. The callback is called for each subtype.
    // Top-level TypeVars are expanded (e.g. a bound TypeVar is expanded to
    // its bound type and a constrained TypeVar is expanded to its individual
    // constrained types). If conditionFilter is specified, conditions that
    // do not match will be ignored.
    function mapSubtypesExpandTypeVars(type, options, callback, recursionCount = 0) {
        const newSubtypes = [];
        let typeChanged = false;
        function expandSubtype(unexpandedType, isLastSubtype) {
            let expandedType = (0, types_1.isUnion)(unexpandedType) ? unexpandedType : makeTopLevelTypeVarsConcrete(unexpandedType);
            expandedType = (0, typeUtils_1.transformPossibleRecursiveTypeAlias)(expandedType);
            if (options === null || options === void 0 ? void 0 : options.expandCallback) {
                expandedType = options.expandCallback(expandedType);
            }
            (0, typeUtils_1.doForEachSubtype)(expandedType, (subtype, index, allSubtypes) => {
                var _a;
                if (options === null || options === void 0 ? void 0 : options.conditionFilter) {
                    const filteredType = applyConditionFilterToType(subtype, options.conditionFilter, recursionCount);
                    if (!filteredType) {
                        return undefined;
                    }
                    subtype = filteredType;
                }
                let transformedType = callback(subtype, unexpandedType, isLastSubtype && index === allSubtypes.length - 1);
                if (transformedType !== unexpandedType) {
                    typeChanged = true;
                }
                if (transformedType) {
                    // Apply the type condition if it's associated with a constrained TypeVar.
                    const typeCondition = (_a = (0, typeUtils_1.getTypeCondition)(subtype)) === null || _a === void 0 ? void 0 : _a.filter((condition) => condition.typeVar.details.constraints.length > 0);
                    if (typeCondition && typeCondition.length > 0) {
                        transformedType = (0, typeUtils_1.addConditionToType)(transformedType, typeCondition);
                    }
                    // This code path can often produce many duplicate subtypes. We can
                    // reduce the cost of the combineTypes call below by filtering out these
                    // duplicates proactively.
                    if (newSubtypes.length === 0 ||
                        !(0, types_1.isTypeSame)(transformedType, newSubtypes[newSubtypes.length - 1])) {
                        newSubtypes.push(transformedType);
                    }
                }
                return undefined;
            }, options === null || options === void 0 ? void 0 : options.sortSubtypes);
        }
        if ((0, types_1.isUnion)(type)) {
            const subtypes = (options === null || options === void 0 ? void 0 : options.sortSubtypes) ? (0, typeUtils_1.sortTypes)(type.subtypes) : type.subtypes;
            subtypes.forEach((subtype, index) => {
                expandSubtype(subtype, index === type.subtypes.length - 1);
            });
        }
        else {
            expandSubtype(type, /* isLastSubtype */ true);
        }
        if (!typeChanged) {
            return type;
        }
        const newType = (0, types_1.combineTypes)(newSubtypes);
        // Do our best to retain type aliases.
        if (newType.category === 8 /* TypeCategory.Union */) {
            types_1.UnionType.addTypeAliasSource(newType, type);
        }
        return newType;
    }
    function applyConditionFilterToType(type, conditionFilter, recursionCount) {
        if (recursionCount > types_1.maxTypeRecursionCount) {
            return type;
        }
        recursionCount++;
        // If the type has a condition associated with it, make sure it's compatible.
        if (!types_1.TypeCondition.isCompatible((0, typeUtils_1.getTypeCondition)(type), conditionFilter)) {
            return undefined;
        }
        // If the type is generic, see if any of its type arguments should be filtered.
        // This is possible only in cases where the type parameter is covariant.
        // TODO - handle functions and tuples
        if ((0, types_1.isClass)(type) && type.typeArguments && !type.tupleTypeArguments) {
            inferTypeParameterVarianceForClass(type);
            let typeWasTransformed = false;
            const filteredTypeArgs = type.typeArguments.map((typeArg, index) => {
                if (index >= type.details.typeParameters.length) {
                    return typeArg;
                }
                const variance = types_1.TypeVarType.getVariance(type.details.typeParameters[index]);
                if (variance !== 3 /* Variance.Covariant */) {
                    return typeArg;
                }
                const filteredTypeArg = mapSubtypesExpandTypeVars(typeArg, { conditionFilter }, (expandedSubtype) => {
                    return expandedSubtype;
                }, recursionCount);
                if (filteredTypeArg !== typeArg) {
                    typeWasTransformed = true;
                }
                return filteredTypeArg;
            });
            if (typeWasTransformed) {
                return types_1.ClassType.cloneForSpecialization(type, filteredTypeArgs, /* isTypeArgumentExplicit */ true);
            }
        }
        return type;
    }
    function markNamesAccessed(node, names) {
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        const scope = ScopeUtils.getScopeForNode(node);
        if (scope) {
            names.forEach((symbolName) => {
                const symbolInScope = scope.lookUpSymbolRecursive(symbolName);
                if (symbolInScope) {
                    setSymbolAccessed(fileInfo, symbolInScope.symbol, node);
                }
            });
        }
    }
    function assignTypeToExpression(target, typeResult, srcExpr, ignoreEmptyContainers = false, allowAssignmentToFinalVar = false, expectedTypeDiagAddendum) {
        // Is the source expression a TypeVar() call?
        if ((0, types_1.isTypeVar)(typeResult.type)) {
            if (srcExpr && srcExpr.nodeType === 9 /* ParseNodeType.Call */) {
                const callType = getTypeOfExpression(srcExpr.leftExpression, 2 /* EvalFlags.CallBaseDefaults */).type;
                if ((0, types_1.isInstantiableClass)(callType) &&
                    (types_1.ClassType.isBuiltIn(callType, 'TypeVar') ||
                        types_1.ClassType.isBuiltIn(callType, 'TypeVarTuple') ||
                        types_1.ClassType.isBuiltIn(callType, 'ParamSpec'))) {
                    const typeVarTarget = target.nodeType === 54 /* ParseNodeType.TypeAnnotation */ ? target.valueExpression : target;
                    if (typeVarTarget.nodeType !== 38 /* ParseNodeType.Name */ ||
                        typeVarTarget.value !== typeResult.type.details.name) {
                        addError(typeResult.type.details.isParamSpec
                            ? localize_1.LocMessage.paramSpecAssignedName().format({
                                name: types_1.TypeVarType.getReadableName(typeResult.type),
                            })
                            : localize_1.LocMessage.typeVarAssignedName().format({
                                name: types_1.TypeVarType.getReadableName(typeResult.type),
                            }), typeVarTarget);
                    }
                }
            }
        }
        // If the type was partially unbound, an error will have already been logged.
        // Remove the unbound before assigning to the target expression so the unbound
        // error doesn't propagate.
        if ((0, types_1.findSubtype)(typeResult.type, (subtype) => (0, types_1.isUnbound)(subtype))) {
            typeResult = { ...typeResult, type: (0, types_1.removeUnbound)(typeResult.type) };
        }
        switch (target.nodeType) {
            case 38 /* ParseNodeType.Name */: {
                assignTypeToNameNode(target, typeResult, ignoreEmptyContainers, srcExpr, allowAssignmentToFinalVar, expectedTypeDiagAddendum);
                break;
            }
            case 35 /* ParseNodeType.MemberAccess */: {
                assignTypeToMemberAccessNode(target, typeResult, srcExpr, expectedTypeDiagAddendum);
                break;
            }
            case 27 /* ParseNodeType.Index */: {
                const baseTypeResult = getTypeOfExpression(target.baseExpression, 2 /* EvalFlags.IndexBaseDefaults */);
                getTypeOfIndexWithBaseType(target, baseTypeResult, {
                    method: 'set',
                    setType: typeResult,
                    setErrorNode: srcExpr,
                    setExpectedTypeDiag: expectedTypeDiagAddendum,
                }, 0 /* EvalFlags.None */);
                writeTypeCache(target, typeResult, 0 /* EvalFlags.None */);
                break;
            }
            case 34 /* ParseNodeType.List */:
            case 52 /* ParseNodeType.Tuple */: {
                assignTypeToTupleOrListNode(target, typeResult, srcExpr);
                break;
            }
            case 54 /* ParseNodeType.TypeAnnotation */: {
                const annotationType = getTypeOfAnnotation(target.typeAnnotation, {
                    isVariableAnnotation: true,
                    allowFinal: ParseTreeUtils.isFinalAllowedForAssignmentTarget(target.valueExpression),
                    allowClassVar: ParseTreeUtils.isClassVarAllowedForAssignmentTarget(target.valueExpression),
                });
                // Handle a bare "Final" or "ClassVar" in a special manner.
                const isBareFinalOrClassVar = (0, types_1.isClassInstance)(annotationType) &&
                    (types_1.ClassType.isBuiltIn(annotationType, 'Final') || types_1.ClassType.isBuiltIn(annotationType, 'ClassVar'));
                if (!isBareFinalOrClassVar) {
                    const isTypeAliasAnnotation = (0, types_1.isClassInstance)(annotationType) && types_1.ClassType.isBuiltIn(annotationType, 'TypeAlias');
                    if (!isTypeAliasAnnotation) {
                        if (assignType(annotationType, typeResult.type)) {
                            // Don't attempt to narrow based on the annotated type if the type
                            // is a enum because the annotated type in an enum doesn't reflect
                            // the type of the symbol.
                            if (!(0, types_1.isClassInstance)(typeResult.type) || !types_1.ClassType.isEnumClass(typeResult.type)) {
                                typeResult = narrowTypeBasedOnAssignment(target, annotationType, typeResult);
                            }
                        }
                    }
                }
                assignTypeToExpression(target.valueExpression, typeResult, srcExpr, ignoreEmptyContainers, allowAssignmentToFinalVar, expectedTypeDiagAddendum);
                break;
            }
            case 56 /* ParseNodeType.Unpack */: {
                if (target.expression.nodeType === 38 /* ParseNodeType.Name */) {
                    assignTypeToNameNode(target.expression, {
                        type: getBuiltInObject(target.expression, 'list', [typeResult.type]),
                        isIncomplete: typeResult.isIncomplete,
                    }, ignoreEmptyContainers, srcExpr);
                }
                break;
            }
            case 0 /* ParseNodeType.Error */: {
                // Evaluate the child expression as best we can so the
                // type information is cached for the completion handler.
                if (target.child) {
                    suppressDiagnostics(target.child, () => {
                        getTypeOfExpression(target.child);
                    });
                }
                break;
            }
            default: {
                addError(localize_1.LocMessage.assignmentTargetExpr(), target);
                break;
            }
        }
    }
    function verifyRaiseExceptionType(node) {
        const baseExceptionType = getBuiltInType(node, 'BaseException');
        if (node.typeExpression) {
            const exceptionType = getTypeOfExpression(node.typeExpression).type;
            // Validate that the argument of "raise" is an exception object or class.
            // If it is a class, validate that the class's constructor accepts zero
            // arguments.
            if (exceptionType && baseExceptionType && (0, types_1.isInstantiableClass)(baseExceptionType)) {
                const diagAddendum = new diagnostic_1.DiagnosticAddendum();
                (0, typeUtils_1.doForEachSubtype)(exceptionType, (subtype) => {
                    const concreteSubtype = makeTopLevelTypeVarsConcrete(subtype);
                    if (!(0, types_1.isAnyOrUnknown)(concreteSubtype)) {
                        if ((0, types_1.isInstantiableClass)(concreteSubtype) && concreteSubtype.literalValue === undefined) {
                            if (!(0, typeUtils_1.derivesFromClassRecursive)(concreteSubtype, baseExceptionType, 
                            /* ignoreUnknown */ false)) {
                                diagAddendum.addMessage(localize_1.LocMessage.exceptionTypeIncorrect().format({
                                    type: printType(subtype),
                                }));
                            }
                            else {
                                let callResult;
                                suppressDiagnostics(node.typeExpression, () => {
                                    callResult = (0, constructors_1.validateConstructorArguments)(evaluatorInterface, node.typeExpression, [], concreteSubtype, 
                                    /* skipUnknownArgCheck */ false, 
                                    /* inferenceContext */ undefined, 
                                    /* signatureTracker */ undefined);
                                });
                                if (callResult && callResult.argumentErrors) {
                                    diagAddendum.addMessage(localize_1.LocMessage.exceptionTypeNotInstantiable().format({
                                        type: printType(subtype),
                                    }));
                                }
                            }
                        }
                        else if ((0, types_1.isClassInstance)(concreteSubtype)) {
                            if (!(0, typeUtils_1.derivesFromClassRecursive)(types_1.ClassType.cloneAsInstantiable(concreteSubtype), baseExceptionType, 
                            /* ignoreUnknown */ false)) {
                                diagAddendum.addMessage(localize_1.LocMessage.exceptionTypeIncorrect().format({
                                    type: printType(subtype),
                                }));
                            }
                        }
                        else {
                            diagAddendum.addMessage(localize_1.LocMessage.exceptionTypeIncorrect().format({
                                type: printType(subtype),
                            }));
                        }
                    }
                });
                if (!diagAddendum.isEmpty()) {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.expectedExceptionClass() + diagAddendum.getString(), node.typeExpression);
                }
            }
        }
    }
    function verifyDeleteExpression(node) {
        switch (node.nodeType) {
            case 38 /* ParseNodeType.Name */: {
                // Get the type to evaluate whether it's bound
                // and to mark it accessed.
                getTypeOfExpression(node);
                break;
            }
            case 35 /* ParseNodeType.MemberAccess */: {
                const baseTypeResult = getTypeOfExpression(node.leftExpression, 2 /* EvalFlags.MemberAccessBaseDefaults */);
                const delAccessResult = getTypeOfMemberAccessWithBaseType(node, baseTypeResult, { method: 'del' }, 0 /* EvalFlags.None */);
                const resultToCache = {
                    type: delAccessResult.type,
                    memberAccessDeprecationInfo: delAccessResult.memberAccessDeprecationInfo,
                };
                writeTypeCache(node.memberName, resultToCache, 0 /* EvalFlags.None */);
                writeTypeCache(node, resultToCache, 0 /* EvalFlags.None */);
                break;
            }
            case 27 /* ParseNodeType.Index */: {
                const baseTypeResult = getTypeOfExpression(node.baseExpression, 2 /* EvalFlags.IndexBaseDefaults */);
                getTypeOfIndexWithBaseType(node, baseTypeResult, { method: 'del' }, 0 /* EvalFlags.None */);
                writeTypeCache(node, { type: types_1.UnboundType.create() }, 0 /* EvalFlags.None */);
                break;
            }
            case 52 /* ParseNodeType.Tuple */: {
                node.expressions.forEach((expr) => {
                    verifyDeleteExpression(expr);
                });
                break;
            }
            case 0 /* ParseNodeType.Error */: {
                // Evaluate the child expression as best we can so the
                // type information is cached for the completion handler.
                if (node.child) {
                    suppressDiagnostics(node.child, () => {
                        getTypeOfExpression(node.child);
                    });
                }
                break;
            }
            default: {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.delTargetExpr(), node);
                break;
            }
        }
    }
    function setSymbolAccessed(fileInfo, symbol, node) {
        if (!isSpeculativeModeInUse(node)) {
            fileInfo.accessedSymbolSet.add(symbol.id);
        }
    }
    function getTypeOfName(node, flags) {
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        const name = node.value;
        let symbol;
        let type;
        let isIncomplete = false;
        const allowForwardReferences = (flags & 4 /* EvalFlags.ForwardRefs */) !== 0 || fileInfo.isStubFile;
        // Look for the scope that contains the value definition and
        // see if it has a declared type.
        let symbolWithScope = lookUpSymbolRecursive(node, name, !allowForwardReferences, allowForwardReferences && (flags & 256 /* EvalFlags.TypeExpression */) !== 0);
        if (!symbolWithScope) {
            // If the node is part of a "from X import Y as Z" statement and the node
            // is the "Y" (non-aliased) name, we need to look up the alias symbol
            // since the non-aliased name is not in the symbol table.
            const alias = getAliasFromImport(node);
            if (alias) {
                symbolWithScope = lookUpSymbolRecursive(alias, alias.value, !allowForwardReferences, allowForwardReferences && (flags & 256 /* EvalFlags.TypeExpression */) !== 0);
            }
        }
        if (symbolWithScope) {
            let useCodeFlowAnalysis = !allowForwardReferences;
            // If the symbol is implicitly imported from the builtin
            // scope, there's no need to use code flow analysis.
            if (symbolWithScope.scope.type === 5 /* ScopeType.Builtin */) {
                useCodeFlowAnalysis = false;
            }
            symbol = symbolWithScope.symbol;
            setSymbolAccessed(fileInfo, symbol, node);
            // If we're not supposed to be analyzing this function, skip the remaining work
            // to determine the name's type. Simply evaluate its type as Any.
            if (!fileInfo.diagnosticRuleSet.analyzeUnannotatedFunctions) {
                const containingFunction = ParseTreeUtils.getEnclosingFunction(node);
                if (containingFunction && ParseTreeUtils.isUnannotatedFunction(containingFunction)) {
                    return {
                        type: types_1.AnyType.create(),
                        isIncomplete: false,
                    };
                }
            }
            // Get the effective type (either the declared type or the inferred type).
            // If we're using code flow analysis, pass the usage node so we consider
            // only the assignment nodes that are reachable from this usage.
            const effectiveTypeInfo = getEffectiveTypeOfSymbolForUsage(symbol, useCodeFlowAnalysis ? node : undefined);
            let effectiveType = (0, typeUtils_1.transformPossibleRecursiveTypeAlias)(effectiveTypeInfo.type);
            if (effectiveTypeInfo.isIncomplete) {
                if ((0, types_1.isUnbound)(effectiveType)) {
                    effectiveType = types_1.UnknownType.create(/* isIncomplete */ true);
                }
                isIncomplete = true;
            }
            if (effectiveTypeInfo.isRecursiveDefinition && isNodeReachable(node)) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.recursiveDefinition().format({ name }), node);
            }
            const isSpecialBuiltIn = !!effectiveType && (0, types_1.isInstantiableClass)(effectiveType) && types_1.ClassType.isSpecialBuiltIn(effectiveType);
            type = effectiveType;
            if (useCodeFlowAnalysis && !isSpecialBuiltIn) {
                // See if code flow analysis can tell us anything more about the type.
                // If the symbol is declared outside of our execution scope, use its effective
                // type. If it's declared inside our execution scope, it generally starts
                // as unbound at the start of the code flow.
                let typeAtStart = effectiveType;
                let isTypeAtStartIncomplete = false;
                if (!symbolWithScope.isBeyondExecutionScope && symbol.isInitiallyUnbound()) {
                    typeAtStart = types_1.UnboundType.create();
                    // Is this a module-level scope? If so, see if it's an alias of a builtin.
                    if (symbolWithScope.scope.type === 4 /* ScopeType.Module */) {
                        (0, debug_1.assert)(symbolWithScope.scope.parent);
                        const builtInSymbol = symbolWithScope.scope.parent.lookUpSymbol(name);
                        if (builtInSymbol) {
                            const builtInEffectiveType = getEffectiveTypeOfSymbolForUsage(builtInSymbol);
                            typeAtStart = builtInEffectiveType.type;
                        }
                    }
                }
                if (symbolWithScope.isBeyondExecutionScope) {
                    const outerScopeTypeResult = getCodeFlowTypeForCapturedVariable(node, symbolWithScope, effectiveType);
                    if (outerScopeTypeResult === null || outerScopeTypeResult === void 0 ? void 0 : outerScopeTypeResult.type) {
                        type = outerScopeTypeResult.type;
                        typeAtStart = type;
                        isTypeAtStartIncomplete = !!outerScopeTypeResult.isIncomplete;
                    }
                }
                const codeFlowTypeResult = getFlowTypeOfReference(node, /* startNode */ undefined, {
                    targetSymbolId: symbol.id,
                    typeAtStart: { type: typeAtStart, isIncomplete: isTypeAtStartIncomplete },
                    skipConditionalNarrowing: (flags & 256 /* EvalFlags.TypeExpression */) !== 0,
                });
                if (codeFlowTypeResult.type) {
                    type = codeFlowTypeResult.type;
                }
                if (codeFlowTypeResult.isIncomplete) {
                    isIncomplete = true;
                }
            }
            // Detect, report, and fill in missing type arguments if appropriate.
            type = reportMissingTypeArguments(node, type, flags);
            // Report inappropriate use of variables in type expressions.
            if ((flags & 256 /* EvalFlags.TypeExpression */) !== 0) {
                type = validateSymbolIsTypeExpression(node, type, !!effectiveTypeInfo.includesVariableDecl);
            }
        }
        else {
            // Handle the special case of "reveal_type" and "reveal_locals".
            if (name === 'reveal_type' || name === 'reveal_locals') {
                type = types_1.AnyType.create();
            }
            else {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportUndefinedVariable, localize_1.LocMessage.symbolIsUndefined().format({ name }), node);
                type = types_1.UnknownType.create();
            }
        }
        if ((0, types_1.isParamSpec)(type)) {
            if (flags & 32 /* EvalFlags.NoParamSpec */) {
                addError(localize_1.LocMessage.paramSpecContext(), node);
                type = types_1.UnknownType.create();
            }
        }
        type = convertSpecialFormToRuntimeValue(type, flags);
        if ((flags & 256 /* EvalFlags.TypeExpression */) === 0) {
            reportUseOfTypeCheckOnly(type, node);
        }
        if ((flags & 128 /* EvalFlags.InstantiableType */) !== 0) {
            if ((flags & 1024 /* EvalFlags.AllowGeneric */) === 0) {
                if ((0, types_1.isInstantiableClass)(type) && types_1.ClassType.isBuiltIn(type, 'Generic')) {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.genericNotAllowed(), node);
                }
            }
        }
        if ((0, types_1.isTypeVar)(type) && !type.details.isSynthesized) {
            type = validateTypeVarUsage(node, type, flags);
        }
        return { type, isIncomplete };
    }
    // Reports diagnostics if type isn't valid within a type expression.
    function validateSymbolIsTypeExpression(node, type, includesVariableDecl) {
        // Verify that the name does not refer to a (non type alias) variable.
        if (!includesVariableDecl || type.typeAliasInfo) {
            return type;
        }
        if ((0, types_1.isTypeVar)(type) || (0, typeUtils_1.isTypeAliasPlaceholder)(type)) {
            return type;
        }
        // Exempts class types that are created by calling
        // NewType, NamedTuple, etc.
        if ((0, types_1.isClass)(type) && !type.includeSubclasses && types_1.ClassType.isValidTypeAliasClass(type)) {
            return type;
        }
        // Disable for assignments in the typings.pyi file, since it defines special forms.
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        if (fileInfo.isTypingStubFile) {
            return type;
        }
        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportInvalidTypeForm, localize_1.LocMessage.typeAnnotationVariable(), node);
        return types_1.UnknownType.create();
    }
    // If the value is a special form (like a TypeVar or `Any`) and is being
    // evaluated in a value expression context, convert it from its special
    // meaning to its runtime value.
    function convertSpecialFormToRuntimeValue(type, flags) {
        var _a;
        const exemptFlags = 256 /* EvalFlags.TypeExpression */ | 128 /* EvalFlags.InstantiableType */ | 33554432 /* EvalFlags.NoConvertSpecialForm */;
        if ((flags & exemptFlags) !== 0) {
            return type;
        }
        // Isinstance treats traditional (non-PEP 695) type aliases that are unions
        // as tuples of classes rather than unions.
        if ((flags & 536870912 /* EvalFlags.IsinstanceArg */) !== 0) {
            if ((0, types_1.isUnion)(type) && type.typeAliasInfo && !type.typeAliasInfo.isPep695Syntax) {
                return type;
            }
        }
        return (_a = type.specialForm) !== null && _a !== void 0 ? _a : type;
    }
    // Handles the case where a variable or parameter is defined in an outer
    // scope and captured by an inner scope (a function, lambda, or comprehension).
    function getCodeFlowTypeForCapturedVariable(node, symbolWithScope, effectiveType) {
        // This function applies only to captured variables, not those that
        // are accessed via an explicit nonlocal or global binding.
        if (symbolWithScope.usesGlobalBinding || symbolWithScope.usesNonlocalBinding) {
            return undefined;
        }
        // This function applies only to variables, parameters, and imports, not to other
        // types of symbols.
        const decls = symbolWithScope.symbol.getDeclarations();
        if (!decls.every((decl) => decl.type === 1 /* DeclarationType.Variable */ ||
            decl.type === 2 /* DeclarationType.Parameter */ ||
            decl.type === 8 /* DeclarationType.Alias */)) {
            return undefined;
        }
        // If the symbol is modified in scopes other than the one in which it is
        // declared (e.g. through a nonlocal or global binding), it is not eligible
        // for code flow analysis.
        if (!decls.every((decl) => decl.type === 2 /* DeclarationType.Parameter */ ||
            ScopeUtils.getScopeForNode(decl.node) === symbolWithScope.scope)) {
            return undefined;
        }
        // If the symbol is a non-final variable in the global scope, it is not
        // eligible because it could be modified by other modules.
        if (!decls.every((decl) => {
            var _a;
            return decl.type !== 1 /* DeclarationType.Variable */ ||
                decl.isFinal ||
                ((_a = ScopeUtils.getScopeForNode(decl.node)) === null || _a === void 0 ? void 0 : _a.type) !== 4 /* ScopeType.Module */;
        })) {
            return undefined;
        }
        // If the symbol is a variable captured by an inner function
        // or lambda, see if we can infer the type from the outer scope.
        const scopeHierarchy = ScopeUtils.getScopeHierarchy(node, symbolWithScope.scope);
        if (scopeHierarchy && scopeHierarchy.length >= 2) {
            // Find the parse node associated with the scope that is just inside of the
            // scope that declares the captured variable.
            const innerScopeNode = ScopeUtils.findTopNodeInScope(node, scopeHierarchy[scopeHierarchy.length - 2]);
            if ((innerScopeNode === null || innerScopeNode === void 0 ? void 0 : innerScopeNode.nodeType) === 31 /* ParseNodeType.Function */ ||
                (innerScopeNode === null || innerScopeNode === void 0 ? void 0 : innerScopeNode.nodeType) === 33 /* ParseNodeType.Lambda */ ||
                (innerScopeNode === null || innerScopeNode === void 0 ? void 0 : innerScopeNode.nodeType) === 10 /* ParseNodeType.Class */) {
                const innerScopeCodeFlowNode = AnalyzerNodeInfo.getFlowNode(innerScopeNode);
                if (innerScopeCodeFlowNode) {
                    // See if any of the assignments of the symbol are reachable
                    // from this node. If so, we cannot apply any narrowing because
                    // the type could change after the capture.
                    if (symbolWithScope.symbol.getDeclarations().every((decl) => {
                        // Parameter declarations always start life at the beginning
                        // of the execution scope, so they are always safe to narrow.
                        if (decl.type === 2 /* DeclarationType.Parameter */) {
                            return true;
                        }
                        const declCodeFlowNode = AnalyzerNodeInfo.getFlowNode(decl.node);
                        if (!declCodeFlowNode) {
                            return false;
                        }
                        return !codeFlowEngine.isFlowNodeReachable(declCodeFlowNode, innerScopeCodeFlowNode, 
                        /* ignoreNoReturn */ true);
                    })) {
                        let typeAtStart = effectiveType;
                        if (symbolWithScope.symbol.isInitiallyUnbound()) {
                            typeAtStart = types_1.UnboundType.create();
                        }
                        return getFlowTypeOfReference(node, innerScopeNode, {
                            targetSymbolId: symbolWithScope.symbol.id,
                            typeAtStart: { type: typeAtStart },
                        });
                    }
                }
            }
        }
        return undefined;
    }
    // Validates that a TypeVar is valid in this context. If so, it clones it
    // and provides a scope ID defined by its containing scope (class, function
    // or type alias). If not, it emits errors indicating why the TypeVar
    // cannot be used in this location.
    function validateTypeVarUsage(node, type, flags) {
        var _a;
        if (types_1.TypeBase.isInstantiable(type) && !type.scopeId && !(0, typeUtils_1.isTypeAliasPlaceholder)(type)) {
            const scopedTypeVarInfo = findScopedTypeVar(node, type);
            type = scopedTypeVarInfo.type;
            if ((flags & 2048 /* EvalFlags.NoTypeVarWithScopeId */) !== 0 && type.scopeId !== undefined) {
                if (!type.details.isSynthesized && !type.details.isParamSpec) {
                    // This TypeVar already has a scope ID assigned to it. See if it
                    // originates from type parameter syntax. If so, allow it.
                    if (type.details.isTypeParamSyntax) {
                        return type;
                    }
                    // If this type variable expression is used within a generic class,
                    // function, or type alias that uses type parameter syntax, there is
                    // no need to report an error here.
                    const typeVarScopeNode = ParseTreeUtils.getTypeVarScopeNode(node);
                    if (typeVarScopeNode &&
                        typeVarScopeNode.typeParameters &&
                        !typeVarScopeNode.typeParameters.parameters.some((t) => t.name === node)) {
                        return type;
                    }
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeVarUsedByOuterScope().format({ name: type.details.name }), node);
                }
            }
            else if ((flags & 8192 /* EvalFlags.TypeVarGetsCurScope */) !== 0) {
                if (type.scopeId === undefined) {
                    if (!scopedTypeVarInfo.foundInterveningClass) {
                        let enclosingScope = ParseTreeUtils.getEnclosingClassOrFunction(node);
                        // Handle P.args and P.kwargs as a special case for inner functions.
                        if (enclosingScope &&
                            ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.nodeType) === 35 /* ParseNodeType.MemberAccess */ &&
                            node.parent.leftExpression === node) {
                            const memberName = node.parent.memberName.value;
                            if (memberName === 'args' || memberName === 'kwargs') {
                                const outerFunctionScope = ParseTreeUtils.getEnclosingClassOrFunction(enclosingScope);
                                if ((outerFunctionScope === null || outerFunctionScope === void 0 ? void 0 : outerFunctionScope.nodeType) === 31 /* ParseNodeType.Function */) {
                                    enclosingScope = outerFunctionScope;
                                }
                                else if (!scopedTypeVarInfo.type.scopeId) {
                                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.paramSpecNotUsedByOuterScope().format({
                                        name: type.details.name,
                                    }), node);
                                }
                            }
                        }
                        if (enclosingScope) {
                            // If the enclosing scope is using type parameter syntax, traditional
                            // type variables can't be used in this context.
                            if (enclosingScope.typeParameters &&
                                !enclosingScope.typeParameters.parameters.some((param) => param.name.value === type.details.name)) {
                                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeParameterNotDeclared().format({
                                    name: type.details.name,
                                    container: enclosingScope.name.value,
                                }), node);
                            }
                            type = types_1.TypeVarType.cloneForScopeId(type, ParseTreeUtils.getScopeIdForNode(enclosingScope), enclosingScope.name.value, enclosingScope.nodeType === 31 /* ParseNodeType.Function */
                                ? 1 /* TypeVarScopeType.Function */
                                : 0 /* TypeVarScopeType.Class */);
                        }
                        else {
                            (0, debug_1.fail)('AssociateTypeVarsWithCurrentScope flag was set but enclosing scope not found');
                        }
                    }
                    else {
                        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeVarUsedByOuterScope().format({ name: type.details.name }), node);
                    }
                }
            }
            else if ((flags & 4096 /* EvalFlags.AllowTypeVarWithoutScopeId */) === 0) {
                if ((type.scopeId === undefined || scopedTypeVarInfo.foundInterveningClass) &&
                    !type.details.isSynthesized) {
                    const message = (0, types_1.isParamSpec)(type)
                        ? localize_1.LocMessage.paramSpecNotUsedByOuterScope()
                        : localize_1.LocMessage.typeVarNotUsedByOuterScope();
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, message.format({ name: type.details.name }), node);
                }
            }
        }
        // If this type var is variadic, the name refers to the packed form. It
        // must be unpacked in most contexts.
        if ((0, types_1.isUnpackedVariadicTypeVar)(type)) {
            type = types_1.TypeVarType.cloneForPacked(type);
        }
        return type;
    }
    // Determines if the type is a generic class or type alias with missing
    // type arguments. If so, it fills in these type arguments with Unknown
    // and optionally reports an error.
    function reportMissingTypeArguments(node, type, flags) {
        var _a;
        if ((flags & 2 /* EvalFlags.NoSpecialize */) !== 0) {
            return type;
        }
        // Is this a generic class that needs to be specialized?
        if ((0, types_1.isInstantiableClass)(type)) {
            if ((flags & 128 /* EvalFlags.InstantiableType */) !== 0 && (flags & 512 /* EvalFlags.AllowMissingTypeArgs */) === 0) {
                if (!type.typeAliasInfo && (0, typeUtils_1.requiresTypeArguments)(type)) {
                    if (!type.typeArguments || !type.isTypeArgumentExplicit) {
                        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportMissingTypeArgument, localize_1.LocMessage.typeArgsMissingForClass().format({
                            name: type.aliasName || type.details.name,
                        }), node);
                    }
                }
            }
            if (!type.typeArguments) {
                type = (_a = createSpecializedClassType(type, /* typeArgs */ undefined, flags, node)) === null || _a === void 0 ? void 0 : _a.type;
            }
        }
        // Is this a generic type alias that needs to be specialized?
        if ((flags & 128 /* EvalFlags.InstantiableType */) !== 0 &&
            type.typeAliasInfo &&
            type.typeAliasInfo.typeParameters &&
            type.typeAliasInfo.typeParameters.length > 0 &&
            !type.typeAliasInfo.typeArguments) {
            let reportMissingTypeArguments = false;
            const defaultTypeArgs = [];
            const typeVarContext = new typeVarContext_1.TypeVarContext(type.typeAliasInfo.typeVarScopeId);
            type.typeAliasInfo.typeParameters.forEach((param) => {
                if (!param.details.isDefaultExplicit) {
                    reportMissingTypeArguments = true;
                }
                let defaultType;
                if (param.details.isDefaultExplicit || param.details.isParamSpec) {
                    defaultType = (0, typeUtils_1.applySolvedTypeVars)(param, typeVarContext, {
                        unknownIfNotFound: true,
                        tupleClassType: getTupleClassType(),
                    });
                }
                else if (param.details.isVariadic && tupleClass && (0, types_1.isInstantiableClass)(tupleClass)) {
                    defaultType = makeTupleObject([{ type: types_1.UnknownType.create(), isUnbounded: true }], 
                    /* isUnpackedTuple */ true);
                }
                else {
                    defaultType = types_1.UnknownType.create();
                }
                defaultTypeArgs.push(defaultType);
                typeVarContext.setTypeVarType(param, defaultType);
            });
            if (reportMissingTypeArguments) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportMissingTypeArgument, localize_1.LocMessage.typeArgsMissingForAlias().format({
                    name: type.typeAliasInfo.name,
                }), node);
            }
            type = types_1.TypeBase.cloneForTypeAlias((0, typeUtils_1.applySolvedTypeVars)(type, typeVarContext, {
                unknownIfNotFound: true,
                tupleClassType: getTupleClassType(),
            }), type.typeAliasInfo.name, type.typeAliasInfo.fullName, type.typeAliasInfo.moduleName, type.typeAliasInfo.fileUri, type.typeAliasInfo.typeVarScopeId, type.typeAliasInfo.isPep695Syntax, type.typeAliasInfo.typeParameters, defaultTypeArgs);
        }
        return type;
    }
    // Walks up the parse tree to find a function, class, or type alias
    // declaration that provides the context for a type variable.
    function findScopedTypeVar(node, type) {
        let curNode = node;
        let nestedClassCount = 0;
        (0, debug_1.assert)(types_1.TypeBase.isInstantiable(type));
        while (curNode) {
            curNode = ParseTreeUtils.getTypeVarScopeNode(curNode);
            if (!curNode) {
                break;
            }
            let typeParametersForScope;
            let scopeUsesTypeParameterSyntax = false;
            if (curNode.nodeType === 10 /* ParseNodeType.Class */) {
                const classTypeInfo = getTypeOfClass(curNode);
                if (classTypeInfo && !types_1.ClassType.isPartiallyEvaluated(classTypeInfo.classType)) {
                    typeParametersForScope = classTypeInfo.classType.details.typeParameters;
                }
                scopeUsesTypeParameterSyntax = !!curNode.typeParameters;
                nestedClassCount++;
            }
            else if (curNode.nodeType === 31 /* ParseNodeType.Function */) {
                const functionType = getTypeOfFunctionPredecorated(curNode);
                if (functionType) {
                    const functionDetails = functionType.details;
                    typeParametersForScope = functionDetails.typeParameters;
                }
                scopeUsesTypeParameterSyntax = !!curNode.typeParameters;
            }
            else if (curNode.nodeType === 77 /* ParseNodeType.TypeAlias */) {
                scopeUsesTypeParameterSyntax = !!curNode.typeParameters;
            }
            if (typeParametersForScope) {
                const match = typeParametersForScope.find((typeVar) => typeVar.details.name === type.details.name);
                if ((match === null || match === void 0 ? void 0 : match.scopeId) !== undefined && match.scopeName !== undefined && match.scopeType !== undefined) {
                    // Use the scoped version of the TypeVar rather than the (unscoped) original type.
                    type = types_1.TypeVarType.cloneForScopeId(type, match.scopeId, match.scopeName, match.scopeType);
                    return {
                        type,
                        foundInterveningClass: nestedClassCount > 1 && !scopeUsesTypeParameterSyntax,
                    };
                }
            }
            curNode = curNode.parent;
        }
        // See if this is part of an assignment statement that is defining a type alias.
        curNode = node;
        while (curNode) {
            let leftType;
            let typeAliasNode = undefined;
            if (curNode.nodeType === 77 /* ParseNodeType.TypeAlias */) {
                leftType = readTypeCache(curNode.name, 0 /* EvalFlags.None */);
                typeAliasNode = curNode;
            }
            else if (curNode.nodeType === 3 /* ParseNodeType.Assignment */) {
                leftType = readTypeCache(curNode.leftExpression, 0 /* EvalFlags.None */);
            }
            if (leftType) {
                // Is this a placeholder that was temporarily written to the cache for
                // purposes of resolving type aliases?
                if (leftType &&
                    (0, types_1.isTypeVar)(leftType) &&
                    leftType.details.recursiveTypeAliasScopeId &&
                    leftType.details.recursiveTypeAliasName) {
                    // Type alias statements cannot be used with old-style type variables.
                    if (typeAliasNode && !type.details.isTypeParamSyntax) {
                        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeParameterNotDeclared().format({
                            name: type.details.name,
                            container: typeAliasNode.name.value,
                        }), node);
                    }
                    else {
                        // If this is a TypeAliasType call, the recursiveTypeParameters will already
                        // be populated, and we need to verify that the type parameter is in the
                        // list of allowed type parameters.
                        const allowedTypeParams = leftType.details.recursiveTypeParameters;
                        if (allowedTypeParams) {
                            if (!allowedTypeParams.some((param) => param.details.name === type.details.name)) {
                                // Return the original type.
                                return { type, foundInterveningClass: false };
                            }
                        }
                    }
                    return {
                        type: types_1.TypeVarType.cloneForScopeId(type, leftType.details.recursiveTypeAliasScopeId, leftType.details.recursiveTypeAliasName, 2 /* TypeVarScopeType.TypeAlias */),
                        foundInterveningClass: false,
                    };
                }
            }
            curNode = curNode.parent;
        }
        // Return the original type.
        return { type, foundInterveningClass: false };
    }
    function getTypeOfMemberAccess(node, flags) {
        var _a;
        // Compute flags specifically for evaluating the left expression.
        let leftExprFlags = 2 /* EvalFlags.MemberAccessBaseDefaults */;
        leftExprFlags |=
            flags &
                (256 /* EvalFlags.TypeExpression */ |
                    32768 /* EvalFlags.VarTypeAnnotation */ |
                    4 /* EvalFlags.ForwardRefs */ |
                    524288 /* EvalFlags.NotParsed */ |
                    2048 /* EvalFlags.NoTypeVarWithScopeId */ |
                    8192 /* EvalFlags.TypeVarGetsCurScope */);
        // Handle special casing for ParamSpec "args" and "kwargs" accesses.
        if ((flags & 128 /* EvalFlags.InstantiableType */) !== 0) {
            const memberName = node.memberName.value;
            if (memberName === 'args' || memberName === 'kwargs') {
                leftExprFlags |= 33554432 /* EvalFlags.NoConvertSpecialForm */;
            }
        }
        const baseTypeResult = getTypeOfExpression(node.leftExpression, leftExprFlags);
        if ((0, typeUtils_1.isTypeAliasPlaceholder)(baseTypeResult.type)) {
            return {
                type: types_1.UnknownType.create(/* isIncomplete */ true),
                isIncomplete: true,
            };
        }
        const typeResult = getTypeOfMemberAccessWithBaseType(node, baseTypeResult, { method: 'get' }, flags | 2 /* EvalFlags.NoSpecialize */);
        if ((0, codeFlowTypes_1.isCodeFlowSupportedForReference)(node)) {
            // Before performing code flow analysis, update the cache to prevent recursion.
            writeTypeCache(node, { ...typeResult, isIncomplete: true }, flags);
            writeTypeCache(node.memberName, { ...typeResult, isIncomplete: true }, flags);
            // If the type is initially unbound, see if there's a parent class that
            // potentially initialized the value.
            let typeAtStart = typeResult.type;
            let isTypeAtStartIncomplete = !!typeResult.isIncomplete;
            if ((0, types_1.isUnbound)(typeAtStart)) {
                const baseType = makeTopLevelTypeVarsConcrete(baseTypeResult.type);
                let classMemberInfo;
                if ((0, types_1.isInstantiableClass)(baseType)) {
                    classMemberInfo = (0, typeUtils_1.lookUpClassMember)(baseType, node.memberName.value, 1 /* MemberAccessFlags.SkipOriginalClass */);
                }
                else if ((0, types_1.isClassInstance)(baseType)) {
                    classMemberInfo = (0, typeUtils_1.lookUpObjectMember)(baseType, node.memberName.value, 1 /* MemberAccessFlags.SkipOriginalClass */);
                }
                if (classMemberInfo) {
                    typeAtStart = getTypeOfMember(classMemberInfo);
                    isTypeAtStartIncomplete = false;
                }
            }
            // See if we can refine the type based on code flow analysis.
            const codeFlowTypeResult = getFlowTypeOfReference(node, /* startNode */ undefined, {
                targetSymbolId: symbol_1.indeterminateSymbolId,
                typeAtStart: { type: typeAtStart, isIncomplete: isTypeAtStartIncomplete },
                skipConditionalNarrowing: (flags & 256 /* EvalFlags.TypeExpression */) !== 0,
            });
            if (codeFlowTypeResult.type) {
                typeResult.type = codeFlowTypeResult.type;
            }
            if (codeFlowTypeResult.isIncomplete) {
                typeResult.isIncomplete = true;
            }
            // Detect, report, and fill in missing type arguments if appropriate.
            typeResult.type = reportMissingTypeArguments(node, typeResult.type, flags);
        }
        if (baseTypeResult.isIncomplete) {
            typeResult.isIncomplete = true;
        }
        // See if we need to log an "unknown member access" diagnostic.
        let skipPartialUnknownCheck = typeResult.isIncomplete;
        // Don't report an error if the type is a partially-specialized
        // class being passed as an argument. This comes up frequently in
        // cases where a type is passed as an argument (e.g. "defaultdict(list)").
        // It can also come up in cases like "isinstance(x, (list, dict))".
        // We need to check for functions as well to handle Callable.
        if (((0, types_1.isInstantiableClass)(typeResult.type) && !typeResult.type.includeSubclasses) ||
            typeResult.type.specialForm) {
            const argNode = ParseTreeUtils.getParentNodeOfType(node, 1 /* ParseNodeType.Argument */);
            if (argNode && ((_a = argNode === null || argNode === void 0 ? void 0 : argNode.parent) === null || _a === void 0 ? void 0 : _a.nodeType) === 9 /* ParseNodeType.Call */) {
                skipPartialUnknownCheck = true;
            }
        }
        if (!skipPartialUnknownCheck) {
            reportPossibleUnknownAssignment(AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.reportUnknownMemberType, diagnosticRules_1.DiagnosticRule.reportUnknownMemberType, node.memberName, typeResult.type, node, 
            /* ignoreEmptyContainers */ false);
        }
        // Cache the type information in the member name node.
        writeTypeCache(node.memberName, typeResult, flags);
        return typeResult;
    }
    function getTypeOfMemberAccessWithBaseType(node, baseTypeResult, usage, flags) {
        var _a, _b;
        let baseType = (0, typeUtils_1.transformPossibleRecursiveTypeAlias)(baseTypeResult.type);
        const memberName = node.memberName.value;
        let diag = new diagnostic_1.DiagnosticAddendum();
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        let type;
        let narrowedTypeForSet;
        let typeErrors = false;
        let isIncomplete = !!baseTypeResult.isIncomplete;
        let isAsymmetricAccessor;
        const isRequired = false;
        const isNotRequired = false;
        let memberAccessDeprecationInfo;
        // If the base type was incomplete and unbound, don't proceed
        // because false positive errors will be generated.
        if (baseTypeResult.isIncomplete && (0, types_1.isUnbound)(baseType)) {
            return { type: types_1.UnknownType.create(/* isIncomplete */ true), isIncomplete: true };
        }
        if (baseType.specialForm && (flags & 256 /* EvalFlags.TypeExpression */) === 0) {
            baseType = baseType.specialForm;
        }
        if ((0, types_1.isParamSpec)(baseType) && baseType.paramSpecAccess) {
            baseType = makeTopLevelTypeVarsConcrete(baseType);
        }
        switch (baseType.category) {
            case 2 /* TypeCategory.Any */:
            case 1 /* TypeCategory.Unknown */:
            case 3 /* TypeCategory.Never */: {
                type = baseType;
                break;
            }
            case 0 /* TypeCategory.Unbound */: {
                break;
            }
            case 9 /* TypeCategory.TypeVar */: {
                if (baseType.details.isParamSpec) {
                    // Handle special cases for "P.args" and "P.kwargs".
                    if (memberName === 'args' || memberName === 'kwargs') {
                        const isArgs = memberName === 'args';
                        const paramNode = ParseTreeUtils.getEnclosingParameter(node);
                        const expectedCategory = isArgs ? 1 /* ParameterCategory.ArgsList */ : 2 /* ParameterCategory.KwargsDict */;
                        if (!paramNode || paramNode.category !== expectedCategory) {
                            const errorMessage = isArgs
                                ? localize_1.LocMessage.paramSpecArgsUsage()
                                : localize_1.LocMessage.paramSpecKwargsUsage();
                            addError(errorMessage, node);
                            type = types_1.UnknownType.create(isIncomplete);
                            break;
                        }
                        type = types_1.TypeVarType.cloneForParamSpecAccess(baseType, memberName);
                        break;
                    }
                    if (!isIncomplete) {
                        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.paramSpecUnknownMember().format({ name: memberName }), node);
                    }
                    type = types_1.UnknownType.create(isIncomplete);
                    break;
                }
                // It's illegal to reference a member from a type variable.
                if ((flags & 256 /* EvalFlags.TypeExpression */) !== 0) {
                    if (!isIncomplete) {
                        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeVarNoMember().format({
                            type: printType(baseType),
                            name: memberName,
                        }), node.leftExpression);
                    }
                    type = types_1.UnknownType.create(isIncomplete);
                    break;
                }
                if (baseType.details.recursiveTypeAliasName) {
                    type = types_1.UnknownType.create(/* isIncomplete */ true);
                    isIncomplete = true;
                    break;
                }
                if (baseType.details.isVariadic) {
                    break;
                }
                return getTypeOfMemberAccessWithBaseType(node, {
                    type: makeTopLevelTypeVarsConcrete(baseType),
                    bindToSelfType: types_1.TypeBase.isInstantiable(baseType) ? (0, typeUtils_1.convertToInstance)(baseType) : baseType,
                    isIncomplete,
                }, usage, 0 /* EvalFlags.None */);
            }
            case 6 /* TypeCategory.Class */: {
                let typeResult;
                const enumMemberResult = (0, enums_1.getTypeOfEnumMember)(evaluatorInterface, node, baseType, memberName, isIncomplete);
                if (enumMemberResult) {
                    if (usage.method === 'get') {
                        typeResult = enumMemberResult;
                    }
                    else {
                        // Is this an attempt to delete or overwrite an enum member?
                        if ((0, types_1.isClassInstance)(enumMemberResult.type) &&
                            types_1.ClassType.isSameGenericClass(enumMemberResult.type, baseType) &&
                            enumMemberResult.type.literalValue !== undefined) {
                            const diagMessage = usage.method === 'set' ? localize_1.LocMessage.enumMemberSet() : localize_1.LocMessage.enumMemberDelete();
                            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportAttributeAccessIssue, diagMessage.format({ name: memberName }) + diag.getString(), node.memberName, (_a = diag.getEffectiveTextRange()) !== null && _a !== void 0 ? _a : node.memberName);
                        }
                    }
                }
                if (!typeResult) {
                    typeResult = getTypeOfBoundMember(node.memberName, baseType, memberName, usage, diag, (flags & 256 /* EvalFlags.TypeExpression */) === 0 ? undefined : 2048 /* MemberAccessFlags.TypeExpression */, baseTypeResult.bindToSelfType);
                }
                if (typeResult) {
                    if (!typeResult.typeErrors) {
                        type = (0, typeUtils_1.addConditionToType)(typeResult.type, (0, typeUtils_1.getTypeCondition)(baseType), 
                        /* skipSelfCondition */ true);
                    }
                    else {
                        typeErrors = true;
                    }
                    if (typeResult.isAsymmetricAccessor) {
                        isAsymmetricAccessor = true;
                    }
                    if (typeResult.isIncomplete) {
                        isIncomplete = true;
                    }
                    if (typeResult.narrowedTypeForSet) {
                        narrowedTypeForSet = (0, typeUtils_1.addConditionToType)(typeResult.narrowedTypeForSet, (0, typeUtils_1.getTypeCondition)(baseType), 
                        /* skipSelfCondition */ true);
                    }
                    if (typeResult.memberAccessDeprecationInfo) {
                        memberAccessDeprecationInfo = typeResult.memberAccessDeprecationInfo;
                    }
                }
                break;
            }
            case 7 /* TypeCategory.Module */: {
                const symbol = types_1.ModuleType.getField(baseType, memberName);
                if (symbol && !symbol.isExternallyHidden()) {
                    if (usage.method === 'get') {
                        setSymbolAccessed(fileInfo, symbol, node.memberName);
                    }
                    const typeResult = getEffectiveTypeOfSymbolForUsage(symbol, 
                    /* usageNode */ undefined, 
                    /* useLastDecl */ true);
                    type = typeResult.type;
                    if ((flags & 256 /* EvalFlags.TypeExpression */) !== 0) {
                        type = validateSymbolIsTypeExpression(node, type, !!typeResult.includesVariableDecl);
                    }
                    if ((0, types_1.isTypeVar)(type)) {
                        type = validateTypeVarUsage(node, type, flags);
                    }
                    // If the type resolved to "unbound", treat it as "unknown" in
                    // the case of a module reference because if it's truly unbound,
                    // that error will be reported within the module and should not
                    // leak into other modules that import it.
                    if ((0, types_1.isUnbound)(type)) {
                        type = types_1.UnknownType.create(/* isIncomplete */ true);
                    }
                    if (symbol.isPrivateMember()) {
                        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportPrivateUsage, localize_1.LocMessage.privateUsedOutsideOfModule().format({
                            name: memberName,
                        }), node.memberName);
                    }
                    if (symbol.isPrivatePyTypedImport()) {
                        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportPrivateImportUsage, localize_1.LocMessage.privateImportFromPyTypedModule().format({
                            name: memberName,
                            module: baseType.moduleName,
                        }), node.memberName);
                    }
                }
                else {
                    // Does the module export a top-level __getattr__ function?
                    if (usage.method === 'get') {
                        const getAttrSymbol = types_1.ModuleType.getField(baseType, '__getattr__');
                        if (getAttrSymbol) {
                            const isModuleGetAttrSupported = fileInfo.executionEnvironment.pythonVersion.isGreaterOrEqualTo(pythonVersion_1.pythonVersion3_7) ||
                                getAttrSymbol.getDeclarations().some((decl) => decl.uri.hasExtension('.pyi'));
                            if (isModuleGetAttrSupported) {
                                const getAttrTypeResult = getEffectiveTypeOfSymbolForUsage(getAttrSymbol);
                                if ((0, types_1.isFunction)(getAttrTypeResult.type)) {
                                    type = getFunctionEffectiveReturnType(getAttrTypeResult.type);
                                    if (getAttrTypeResult.isIncomplete) {
                                        isIncomplete = true;
                                    }
                                }
                            }
                        }
                    }
                    // If the field was not found and the module type is marked
                    // such that all fields should be Any/Unknown, return that type.
                    if (!type && baseType.notPresentFieldType) {
                        type = baseType.notPresentFieldType;
                    }
                    if (!type) {
                        if (!isIncomplete) {
                            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportAttributeAccessIssue, localize_1.LocMessage.moduleUnknownMember().format({
                                memberName,
                                moduleName: baseType.moduleName,
                            }), node.memberName);
                        }
                        type = evaluatorOptions.evaluateUnknownImportsAsAny ? types_1.AnyType.create() : types_1.UnknownType.create();
                    }
                }
                break;
            }
            case 8 /* TypeCategory.Union */: {
                type = (0, typeUtils_1.mapSubtypes)(baseType, (subtype) => {
                    if ((0, types_1.isUnbound)(subtype)) {
                        // Don't do anything if it's unbound. The error will already
                        // be reported elsewhere.
                        return undefined;
                    }
                    if ((0, typeUtils_1.isNoneInstance)(subtype)) {
                        (0, debug_1.assert)((0, types_1.isClassInstance)(subtype));
                        const typeResult = getTypeOfBoundMember(node.memberName, subtype, memberName, usage, diag);
                        if (typeResult && !typeResult.typeErrors) {
                            type = (0, typeUtils_1.addConditionToType)(typeResult.type, (0, typeUtils_1.getTypeCondition)(baseType));
                            if (typeResult.isIncomplete) {
                                isIncomplete = true;
                            }
                            return type;
                        }
                        if (!isIncomplete) {
                            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportOptionalMemberAccess, localize_1.LocMessage.noneUnknownMember().format({ name: memberName }), node.memberName);
                        }
                        return undefined;
                    }
                    const typeResult = getTypeOfMemberAccessWithBaseType(node, {
                        type: subtype,
                        isIncomplete: baseTypeResult.isIncomplete,
                    }, usage, 0 /* EvalFlags.None */);
                    if (typeResult.isIncomplete) {
                        isIncomplete = true;
                    }
                    if (typeResult.memberAccessDeprecationInfo) {
                        memberAccessDeprecationInfo = typeResult.memberAccessDeprecationInfo;
                    }
                    if (typeResult.typeErrors) {
                        typeErrors = true;
                    }
                    return typeResult.type;
                });
                break;
            }
            case 4 /* TypeCategory.Function */:
            case 5 /* TypeCategory.OverloadedFunction */: {
                if (memberName === '__self__') {
                    // The "__self__" member is not currently defined in the "function"
                    // class, so we'll special-case it here.
                    const functionType = (0, types_1.isFunction)(baseType) ? baseType : baseType.overloads[0];
                    if (functionType.preBoundFlags !== undefined &&
                        (functionType.preBoundFlags & 4 /* FunctionTypeFlags.StaticMethod */) === 0) {
                        type = functionType.boundToType;
                    }
                }
                else {
                    type = getTypeOfMemberAccessWithBaseType(node, { type: functionClass ? (0, typeUtils_1.convertToInstance)(functionClass) : types_1.UnknownType.create() }, usage, flags).type;
                }
                break;
            }
            default:
                (0, debug_1.assertNever)(baseType);
        }
        // If type is undefined, emit a general error message indicating that the
        // member could not be accessed.
        if (!type) {
            const isFunctionRule = (0, types_1.isFunction)(baseType) ||
                (0, types_1.isOverloadedFunction)(baseType) ||
                ((0, types_1.isClassInstance)(baseType) && types_1.ClassType.isBuiltIn(baseType, 'function'));
            if (!baseTypeResult.isIncomplete) {
                let diagMessage = localize_1.LocMessage.memberAccess();
                if (usage.method === 'set') {
                    diagMessage = localize_1.LocMessage.memberSet();
                }
                else if (usage.method === 'del') {
                    diagMessage = localize_1.LocMessage.memberDelete();
                }
                // If there is an expected type diagnostic addendum (used for assignments),
                // use that rather than the local diagnostic addendum because it will be
                // more informative.
                if (usage.setExpectedTypeDiag) {
                    diag = usage.setExpectedTypeDiag;
                }
                // If the class is a TypedDict, and there's a key with the same name,
                // suggest that they user want to use ["key"] name instead.
                if ((0, types_1.isClass)(baseType) && baseType.details.typedDictEntries) {
                    const tdKey = baseType.details.typedDictEntries.knownItems.get(memberName);
                    if (tdKey) {
                        const subDiag = new diagnostic_1.DiagnosticAddendum();
                        subDiag.addMessage(localize_1.LocAddendum.typedDictKeyAccess().format({ name: memberName }));
                        diag.addAddendum(subDiag);
                    }
                }
                const rule = isFunctionRule
                    ? diagnosticRules_1.DiagnosticRule.reportFunctionMemberAccess
                    : diagnosticRules_1.DiagnosticRule.reportAttributeAccessIssue;
                addDiagnostic(rule, diagMessage.format({ name: memberName, type: printType(baseType) }) + diag.getString(), node.memberName, (_b = diag.getEffectiveTextRange()) !== null && _b !== void 0 ? _b : node.memberName);
            }
            // If this is member access on a function, use "Any" so if the
            // reportFunctionMemberAccess rule is disabled, we don't trigger
            // additional reportUnknownMemberType diagnostics.
            type = isFunctionRule ? types_1.AnyType.create() : types_1.UnknownType.create();
        }
        if ((flags & 256 /* EvalFlags.TypeExpression */) === 0) {
            reportUseOfTypeCheckOnly(type, node.memberName);
        }
        type = convertSpecialFormToRuntimeValue(type, flags);
        return {
            type,
            isIncomplete,
            isAsymmetricAccessor,
            narrowedTypeForSet,
            isRequired,
            isNotRequired,
            memberAccessDeprecationInfo,
            typeErrors,
        };
    }
    function getTypeOfClassMemberName(errorNode, classType, memberName, usage, diag, flags, selfType, recursionCount = 0) {
        var _a, _b, _c;
        const isAccessedThroughObject = types_1.TypeBase.isInstance(classType);
        // Always look for a member with a declared type first.
        let memberInfo = (0, typeUtils_1.lookUpClassMember)(classType, memberName, flags | 64 /* MemberAccessFlags.DeclaredTypesOnly */);
        // If we couldn't find a symbol with a declared type, use
        // a symbol with an inferred type.
        if (!memberInfo) {
            memberInfo = (0, typeUtils_1.lookUpClassMember)(classType, memberName, flags);
        }
        if (!memberInfo) {
            // No attribute of that name was found. If this is a member access
            // through an object, see if there's an attribute access override
            // method ("__getattr__", etc.).
            if ((flags & 512 /* MemberAccessFlags.SkipAttributeAccessOverride */) === 0 && errorNode) {
                const generalAttrType = applyAttributeAccessOverride(errorNode, classType, usage, memberName, selfType);
                if (generalAttrType) {
                    return {
                        symbol: undefined,
                        type: generalAttrType.type,
                        isTypeIncomplete: false,
                        isDescriptorError: false,
                        isClassMember: false,
                        isClassVar: false,
                        isAsymmetricAccessor: !!generalAttrType.isAsymmetricAccessor,
                    };
                }
            }
            // Report that the member could not be accessed.
            diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.memberUnknown().format({ name: memberName }));
            return undefined;
        }
        let type;
        let isTypeIncomplete = false;
        let narrowedTypeForSet;
        if (memberInfo.symbol.isInitVar()) {
            diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.memberIsInitVar().format({ name: memberName }));
            return undefined;
        }
        if (usage.method !== 'get' && errorNode) {
            // If the usage indicates a 'set' or 'delete' and the access is within the
            // class definition itself, use only the declared type to avoid circular
            // type evaluation.
            const containingClass = ParseTreeUtils.getEnclosingClass(errorNode);
            if (containingClass) {
                const containingClassType = (_a = getTypeOfClass(containingClass)) === null || _a === void 0 ? void 0 : _a.classType;
                if (containingClassType &&
                    (0, types_1.isInstantiableClass)(containingClassType) &&
                    types_1.ClassType.isSameGenericClass(containingClassType, classType)) {
                    type = (_b = getDeclaredTypeOfSymbol(memberInfo.symbol)) === null || _b === void 0 ? void 0 : _b.type;
                    if (type && (0, types_1.isInstantiableClass)(memberInfo.classType)) {
                        type = (0, typeUtils_1.partiallySpecializeType)(type, memberInfo.classType);
                    }
                    // If we're setting a class variable via a write through an object,
                    // this is normally considered a type violation. But it is allowed
                    // if the class variable is a descriptor object. In this case, we will
                    // clear the flag that causes an error to be generated.
                    if (usage.method === 'set' &&
                        (0, symbolUtils_1.isEffectivelyClassVar)(memberInfo.symbol, types_1.ClassType.isDataClass(containingClassType)) &&
                        isAccessedThroughObject) {
                        const selfClass = (selfType !== null && selfType !== void 0 ? selfType : memberName === '__new__') ? undefined : classType;
                        const typeResult = getTypeOfMemberInternal(errorNode, memberInfo, selfClass, flags);
                        if (typeResult) {
                            if ((0, typeUtils_1.isDescriptorInstance)(typeResult.type, /* requireSetter */ true)) {
                                type = typeResult.type;
                                flags &= 128 /* MemberAccessFlags.DisallowClassVarWrites */;
                            }
                        }
                    }
                    if (!type) {
                        type = types_1.UnknownType.create();
                    }
                }
            }
        }
        if (!type) {
            let selfClass;
            if (selfType) {
                selfClass = (0, typeUtils_1.convertToInstantiable)(selfType);
            }
            else {
                // Skip this for __new__ methods because they are not bound
                // to the class but rather assume the type of the cls argument.
                if (memberName !== '__new__') {
                    selfClass = classType;
                }
            }
            const typeResult = getTypeOfMemberInternal(errorNode, memberInfo, selfClass, flags);
            type = (_c = typeResult === null || typeResult === void 0 ? void 0 : typeResult.type) !== null && _c !== void 0 ? _c : types_1.UnknownType.create();
            if (typeResult === null || typeResult === void 0 ? void 0 : typeResult.isIncomplete) {
                isTypeIncomplete = true;
            }
        }
        // Don't include variables within typed dict classes.
        if ((0, types_1.isClass)(memberInfo.classType) && types_1.ClassType.isTypedDictClass(memberInfo.classType)) {
            const typedDecls = memberInfo.symbol.getTypedDeclarations();
            if (typedDecls.length > 0 && typedDecls[0].type === 1 /* DeclarationType.Variable */) {
                diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.memberUnknown().format({ name: memberName }));
                return undefined;
            }
        }
        if (usage.method === 'get') {
            // Mark the member accessed if it's not coming from a parent class.
            if (errorNode &&
                (0, types_1.isInstantiableClass)(memberInfo.classType) &&
                types_1.ClassType.isSameGenericClass(memberInfo.classType, classType)) {
                setSymbolAccessed(AnalyzerNodeInfo.getFileInfo(errorNode), memberInfo.symbol, errorNode);
            }
            // Special-case `__init_subclass` and `__class_getitem__` because
            // these are always treated as class methods even if they're not
            // decorated as such.
            if (memberName === '__init_subclass__' || memberName === '__class_getitem__') {
                if ((0, types_1.isFunction)(type) && !types_1.FunctionType.isClassMethod(type)) {
                    type = types_1.FunctionType.cloneWithNewFlags(type, type.details.flags | 2 /* FunctionTypeFlags.ClassMethod */);
                }
            }
        }
        // If the member is a descriptor object, apply the descriptor protocol
        // now. If the member is an instance or class method, bind the method.
        let isDescriptorError = false;
        let isAsymmetricAccessor = false;
        let isDescriptorApplied = false;
        let memberAccessDeprecationInfo;
        type = (0, typeUtils_1.mapSubtypes)(type, (subtype) => {
            const concreteSubtype = makeTopLevelTypeVarsConcrete(subtype);
            const isClassMember = !memberInfo || memberInfo.isClassMember;
            let resultType;
            if ((0, types_1.isClass)(concreteSubtype) && isClassMember && errorNode) {
                const descResult = applyDescriptorAccessMethod(subtype, concreteSubtype, memberInfo, classType, selfType, flags, errorNode, memberName, usage, diag);
                if (descResult.isAsymmetricAccessor) {
                    isAsymmetricAccessor = true;
                }
                if (descResult.memberAccessDeprecationInfo) {
                    memberAccessDeprecationInfo = descResult.memberAccessDeprecationInfo;
                }
                if (descResult.typeErrors) {
                    isDescriptorError = true;
                }
                if (descResult.isDescriptorApplied) {
                    isDescriptorApplied = true;
                }
                resultType = descResult.type;
            }
            else if ((0, types_1.isFunction)(concreteSubtype) || (0, types_1.isOverloadedFunction)(concreteSubtype)) {
                const typeResult = bindMethodForMemberAccess(subtype, concreteSubtype, memberInfo, classType, selfType, flags, memberName, usage, diag, recursionCount);
                resultType = typeResult.type;
                if (typeResult.typeErrors) {
                    isDescriptorError = true;
                }
            }
            else {
                resultType = subtype;
            }
            // If this is a "set" or "delete" operation, we have a bit more work to do.
            if (usage.method === 'get') {
                return resultType;
            }
            // Check for an attempt to overwrite or delete a ClassVar member from an instance.
            if (!isDescriptorApplied &&
                memberInfo &&
                (0, symbolUtils_1.isEffectivelyClassVar)(memberInfo.symbol, types_1.ClassType.isDataClass(classType)) &&
                (flags & 128 /* MemberAccessFlags.DisallowClassVarWrites */) !== 0) {
                diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.memberSetClassVar().format({ name: memberName }));
                isDescriptorError = true;
            }
            // Check for an attempt to overwrite or delete a final member variable.
            const finalVarTypeDecl = memberInfo === null || memberInfo === void 0 ? void 0 : memberInfo.symbol.getDeclarations().find((decl) => isFinalVariableDeclaration(decl));
            if (finalVarTypeDecl &&
                errorNode &&
                !ParseTreeUtils.isNodeContainedWithin(errorNode, finalVarTypeDecl.node)) {
                // If a Final instance variable is declared in the class body but is
                // being assigned within an __init__ method, it's allowed.
                const enclosingFunctionNode = ParseTreeUtils.getEnclosingFunction(errorNode);
                if (!enclosingFunctionNode ||
                    enclosingFunctionNode.name.value !== '__init__' ||
                    finalVarTypeDecl.inferredTypeSource !== undefined ||
                    (0, types_1.isInstantiableClass)(classType)) {
                    diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocMessage.finalReassigned().format({ name: memberName }));
                    isDescriptorError = true;
                }
            }
            // Check for an attempt to overwrite or delete an instance variable that is
            // read-only (e.g. in a named tuple).
            if ((memberInfo === null || memberInfo === void 0 ? void 0 : memberInfo.isInstanceMember) &&
                (0, types_1.isClass)(memberInfo.classType) &&
                types_1.ClassType.isReadOnlyInstanceVariables(memberInfo.classType)) {
                diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.readOnlyAttribute().format({ name: memberName }));
                isDescriptorError = true;
            }
            return resultType;
        });
        if (!isDescriptorError && usage.method === 'set' && usage.setType) {
            if (errorNode && memberInfo.symbol.hasTypedDeclarations()) {
                // This is an assignment to a member with a declared type. Apply
                // narrowing logic based on the assigned type. Skip this for
                // descriptor-based accesses.
                narrowedTypeForSet = isDescriptorApplied
                    ? usage.setType.type
                    : narrowTypeBasedOnAssignment(errorNode, type, usage.setType).type;
            }
            // Verify that the assigned type is compatible.
            if (!assignType(type, usage.setType.type, diag === null || diag === void 0 ? void 0 : diag.createAddendum())) {
                if (!usage.setType.isIncomplete) {
                    diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.memberAssignment().format({
                        type: printType(usage.setType.type),
                        name: memberName,
                        classType: printObjectTypeForClass(classType),
                    }));
                }
                // Do not narrow the type in this case. Assume the declared type.
                narrowedTypeForSet = type;
                isDescriptorError = true;
            }
            if ((0, types_1.isInstantiableClass)(memberInfo.classType) &&
                types_1.ClassType.isDataClassFrozen(memberInfo.classType) &&
                isAccessedThroughObject) {
                diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.dataClassFrozen().format({
                    name: printType(types_1.ClassType.cloneAsInstance(memberInfo.classType)),
                }));
                isDescriptorError = true;
            }
        }
        return {
            symbol: memberInfo.symbol,
            type,
            isTypeIncomplete,
            isDescriptorError,
            isClassMember: !memberInfo.isInstanceMember,
            isClassVar: memberInfo.isClassVar,
            classType: memberInfo.classType,
            isAsymmetricAccessor,
            narrowedTypeForSet,
            memberAccessDeprecationInfo,
        };
    }
    // Applies descriptor access methods "__get__", "__set__", or "__delete__"
    // if they apply.
    function applyDescriptorAccessMethod(memberType, concreteMemberType, memberInfo, classType, selfType, flags, errorNode, memberName, usage, diag) {
        var _a, _b, _c, _d, _e, _f, _g;
        const isAccessedThroughObject = types_1.TypeBase.isInstance(classType);
        let accessMethodName;
        if (usage.method === 'get') {
            accessMethodName = '__get__';
        }
        else if (usage.method === 'set') {
            accessMethodName = '__set__';
        }
        else {
            accessMethodName = '__delete__';
        }
        const methodTypeResult = getTypeOfBoundMember(errorNode, concreteMemberType, accessMethodName, 
        /* usage */ undefined, diag === null || diag === void 0 ? void 0 : diag.createAddendum(), 16 /* MemberAccessFlags.SkipInstanceMembers */ | 512 /* MemberAccessFlags.SkipAttributeAccessOverride */);
        if (!methodTypeResult || methodTypeResult.typeErrors) {
            // Provide special error messages for properties.
            if (types_1.ClassType.isPropertyClass(concreteMemberType)) {
                if (usage.method !== 'get') {
                    const message = usage.method === 'set'
                        ? localize_1.LocAddendum.propertyMissingSetter()
                        : localize_1.LocAddendum.propertyMissingDeleter();
                    diag === null || diag === void 0 ? void 0 : diag.addMessage(message.format({ name: memberName }));
                    return { type: types_1.AnyType.create(), typeErrors: true };
                }
            }
            return { type: memberType };
        }
        const methodClassType = methodTypeResult.classType;
        let methodType = methodTypeResult.type;
        if (methodTypeResult.typeErrors || !methodClassType) {
            return { type: types_1.UnknownType.create(), typeErrors: true };
        }
        if (!(0, types_1.isFunction)(methodType) && !(0, types_1.isOverloadedFunction)(methodType)) {
            if ((0, types_1.isAnyOrUnknown)(methodType)) {
                return { type: methodType };
            }
            // TODO - emit an error for this condition.
            return { type: memberType, typeErrors: true };
        }
        // Special-case logic for properties.
        if (types_1.ClassType.isPropertyClass(concreteMemberType) &&
            memberInfo &&
            (0, types_1.isInstantiableClass)(memberInfo.classType) &&
            methodType) {
            // If the property is being accessed from a protocol class (not an instance),
            // flag this as an error because a property within a protocol is meant to be
            // interpreted as a read-only attribute rather than a protocol, so accessing
            // it directly from the class has an ambiguous meaning.
            if ((flags & 16 /* MemberAccessFlags.SkipInstanceMembers */) !== 0 && types_1.ClassType.isProtocolClass(classType)) {
                diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.propertyAccessFromProtocolClass());
                return { type: memberType, typeErrors: true };
            }
            // Infer return types before specializing. Otherwise a generic inferred
            // return type won't be properly specialized.
            inferReturnTypeIfNecessary(methodType);
            // This specialization is required specifically for properties, which should be
            // generic but are not defined that way. Because of this, we use type variables
            // in the synthesized methods (e.g. __get__) for the property class that are
            // defined in the class that declares the fget method.
            let accessMethodClass;
            if (usage.method === 'get') {
                accessMethodClass = (_a = concreteMemberType.fgetInfo) === null || _a === void 0 ? void 0 : _a.classType;
            }
            else if (usage.method === 'set') {
                accessMethodClass = (_b = concreteMemberType.fsetInfo) === null || _b === void 0 ? void 0 : _b.classType;
            }
            else {
                accessMethodClass = (_c = concreteMemberType.fdelInfo) === null || _c === void 0 ? void 0 : _c.classType;
            }
            if (accessMethodClass) {
                const typeVarContext = new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(accessMethodClass));
                accessMethodClass = (0, typeUtils_1.selfSpecializeClass)(accessMethodClass);
                assignType(types_1.ClassType.cloneAsInstance(accessMethodClass), types_1.ClassType.cloneAsInstance(memberInfo.classType), 
                /* diag */ undefined, typeVarContext);
                accessMethodClass = (0, typeUtils_1.applySolvedTypeVars)(accessMethodClass, typeVarContext);
                const specializedType = (0, typeUtils_1.partiallySpecializeType)(methodType, accessMethodClass, selfType ? (0, typeUtils_1.convertToInstantiable)(selfType) : classType);
                if ((0, types_1.isFunction)(specializedType) || (0, types_1.isOverloadedFunction)(specializedType)) {
                    methodType = specializedType;
                }
            }
        }
        // Determine if we're calling __set__ on an asymmetric descriptor or property.
        let isAsymmetricAccessor = false;
        if (usage.method === 'set' && (0, types_1.isClass)(methodClassType)) {
            if (isAsymmetricDescriptorClass(methodClassType)) {
                isAsymmetricAccessor = true;
            }
        }
        if (!methodType) {
            diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.descriptorAccessBindingFailed().format({
                name: accessMethodName,
                className: printType((0, typeUtils_1.convertToInstance)(methodClassType)),
            }));
            return {
                type: types_1.UnknownType.create(),
                typeErrors: true,
                isDescriptorApplied: true,
                isAsymmetricAccessor,
            };
        }
        // Simulate a call to the access method.
        const argList = [];
        // Provide "obj" argument.
        let objArgType;
        if (types_1.ClassType.isClassProperty(concreteMemberType)) {
            // Handle "class properties" as a special case. We need to pass
            // the class rather than the object instance in this case.
            objArgType = isAccessedThroughObject ? types_1.ClassType.cloneAsInstantiable(classType) : classType;
        }
        else if (isAccessedThroughObject) {
            objArgType = selfType !== null && selfType !== void 0 ? selfType : types_1.ClassType.cloneAsInstance(classType);
        }
        else {
            objArgType = getNoneType();
        }
        argList.push({
            argumentCategory: 0 /* ArgumentCategory.Simple */,
            typeResult: { type: objArgType },
        });
        if (usage.method === 'get') {
            let classArgType;
            if (selfType) {
                classArgType = (0, typeUtils_1.convertToInstantiable)(selfType);
            }
            else {
                classArgType = isAccessedThroughObject ? types_1.ClassType.cloneAsInstantiable(classType) : classType;
            }
            // Provide "owner" argument.
            argList.push({
                argumentCategory: 0 /* ArgumentCategory.Simple */,
                typeResult: { type: classArgType },
            });
        }
        else if (usage.method === 'set') {
            // Provide "value" argument.
            argList.push({
                argumentCategory: 0 /* ArgumentCategory.Simple */,
                typeResult: {
                    type: (_e = (_d = usage.setType) === null || _d === void 0 ? void 0 : _d.type) !== null && _e !== void 0 ? _e : types_1.UnknownType.create(),
                    isIncomplete: !!((_f = usage.setType) === null || _f === void 0 ? void 0 : _f.isIncomplete),
                },
            });
        }
        // Suppress diagnostics for these method calls because they would be redundant.
        const callResult = suppressDiagnostics(errorNode, () => {
            return validateCallArguments(errorNode, argList, { type: methodType }, 
            /* typeVarContext */ undefined, 
            /* skipUnknownArgCheck */ true, 
            /* inferenceContext */ undefined, 
            /* signatureTracker */ undefined);
        }, (suppressedDiags) => {
            // If diagnostics were recorded when suppressed, add them to the
            // diagnostic as messages.
            if (diag) {
                suppressedDiags.forEach((message) => {
                    diag === null || diag === void 0 ? void 0 : diag.addMessageMultiline(message);
                });
            }
        });
        // Collect deprecation information associated with the member access method.
        let deprecationInfo;
        if (callResult.overloadsUsedForCall && callResult.overloadsUsedForCall.length >= 1) {
            const overloadUsed = callResult.overloadsUsedForCall[0];
            if (overloadUsed.details.deprecatedMessage) {
                deprecationInfo = {
                    deprecationMessage: overloadUsed.details.deprecatedMessage,
                    accessType: types_1.ClassType.isPropertyClass(concreteMemberType) ? 'property' : 'descriptor',
                    accessMethod: usage.method,
                };
            }
        }
        if (!callResult.argumentErrors) {
            return {
                // For set or delete, always return Any.
                type: usage.method === 'get' ? (_g = callResult.returnType) !== null && _g !== void 0 ? _g : types_1.UnknownType.create() : types_1.AnyType.create(),
                isDescriptorApplied: true,
                isAsymmetricAccessor,
                memberAccessDeprecationInfo: deprecationInfo,
            };
        }
        return {
            type: types_1.UnknownType.create(),
            typeErrors: true,
            isDescriptorApplied: true,
            isAsymmetricAccessor,
            memberAccessDeprecationInfo: deprecationInfo,
        };
    }
    function bindMethodForMemberAccess(type, concreteType, memberInfo, classType, selfType, flags, memberName, usage, diag, recursionCount = 0) {
        // Check for an attempt to overwrite a final method.
        if (usage.method === 'set') {
            const impl = (0, types_1.isFunction)(concreteType)
                ? concreteType
                : types_1.OverloadedFunctionType.getImplementation(concreteType);
            if (impl && types_1.FunctionType.isFinal(impl) && memberInfo && (0, types_1.isClass)(memberInfo.classType)) {
                diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocMessage.finalMethodOverride().format({
                    name: memberName,
                    className: memberInfo.classType.details.name,
                }));
                return { type: types_1.UnknownType.create(), typeErrors: true };
            }
        }
        // If this function is an instance member (e.g. a lambda that was
        // assigned to an instance variable), don't perform any binding.
        if (types_1.TypeBase.isInstance(classType)) {
            if (!memberInfo || memberInfo.isInstanceMember) {
                return { type: type };
            }
        }
        const boundType = bindFunctionToClassOrObject(classType, concreteType, memberInfo && (0, types_1.isInstantiableClass)(memberInfo.classType) ? memberInfo.classType : undefined, (flags & 256 /* MemberAccessFlags.TreatConstructorAsClassMethod */) !== 0, selfType && (0, types_1.isClass)(selfType) ? types_1.ClassType.cloneIncludeSubclasses(selfType) : selfType, diag, recursionCount);
        return { type: boundType !== null && boundType !== void 0 ? boundType : types_1.UnknownType.create(), typeErrors: !boundType };
    }
    function isAsymmetricDescriptorClass(classType) {
        var _a;
        // If the value has already been cached in this type, return the cached value.
        if (classType.isAsymmetricDescriptor !== undefined) {
            return classType.isAsymmetricDescriptor;
        }
        let isAsymmetric = false;
        const getterSymbolResult = (0, typeUtils_1.lookUpClassMember)(classType, '__get__', 2 /* MemberAccessFlags.SkipBaseClasses */);
        const setterSymbolResult = (0, typeUtils_1.lookUpClassMember)(classType, '__set__', 2 /* MemberAccessFlags.SkipBaseClasses */);
        if (!getterSymbolResult || !setterSymbolResult) {
            isAsymmetric = false;
        }
        else {
            const getterType = getEffectiveTypeOfSymbol(getterSymbolResult.symbol);
            const setterType = getEffectiveTypeOfSymbol(setterSymbolResult.symbol);
            // If either the setter or getter is an overload (or some other non-function type),
            // conservatively assume that it's not asymmetric.
            if ((0, types_1.isFunction)(getterType) && (0, types_1.isFunction)(setterType)) {
                // If there's no declared return type on the getter, assume it's symmetric.
                if (setterType.details.parameters.length >= 3 && getterType.details.declaredReturnType) {
                    const setterValueType = types_1.FunctionType.getEffectiveParameterType(setterType, 2);
                    const getterReturnType = (_a = types_1.FunctionType.getEffectiveReturnType(getterType)) !== null && _a !== void 0 ? _a : types_1.UnknownType.create();
                    if (!(0, types_1.isTypeSame)(setterValueType, getterReturnType)) {
                        isAsymmetric = true;
                    }
                }
            }
        }
        // Cache the value for next time.
        classType.isAsymmetricDescriptor = isAsymmetric;
        return isAsymmetric;
    }
    function isClassWithAsymmetricAttributeAccessor(classType) {
        var _a;
        // If the value has already been cached in this type, return the cached value.
        if (classType.isAsymmetricAttributeAccessor !== undefined) {
            return classType.isAsymmetricAttributeAccessor;
        }
        let isAsymmetric = false;
        const getterSymbolResult = (0, typeUtils_1.lookUpClassMember)(classType, '__getattr__', 2 /* MemberAccessFlags.SkipBaseClasses */);
        const setterSymbolResult = (0, typeUtils_1.lookUpClassMember)(classType, '__setattr__', 2 /* MemberAccessFlags.SkipBaseClasses */);
        if (!getterSymbolResult || !setterSymbolResult) {
            isAsymmetric = false;
        }
        else {
            const getterType = getEffectiveTypeOfSymbol(getterSymbolResult.symbol);
            const setterType = getEffectiveTypeOfSymbol(setterSymbolResult.symbol);
            // If either the setter or getter is an overload (or some other non-function type),
            // conservatively assume that it's not asymmetric.
            if ((0, types_1.isFunction)(getterType) && (0, types_1.isFunction)(setterType)) {
                // If there's no declared return type on the getter, assume it's symmetric.
                if (setterType.details.parameters.length >= 3 && getterType.details.declaredReturnType) {
                    const setterValueType = types_1.FunctionType.getEffectiveParameterType(setterType, 2);
                    const getterReturnType = (_a = types_1.FunctionType.getEffectiveReturnType(getterType)) !== null && _a !== void 0 ? _a : types_1.UnknownType.create();
                    if (!(0, types_1.isTypeSame)(setterValueType, getterReturnType)) {
                        isAsymmetric = true;
                    }
                }
            }
        }
        // Cache the value for next time.
        classType.isAsymmetricAttributeAccessor = isAsymmetric;
        return isAsymmetric;
    }
    // Applies the __getattr__, __setattr__ or __delattr__ method if present.
    // If it's not applicable, returns undefined.
    function applyAttributeAccessOverride(errorNode, classType, usage, memberName, selfType) {
        var _a, _b, _c, _d, _e;
        const getAttributeAccessMember = (name) => {
            var _a;
            return (_a = getTypeOfBoundMember(errorNode, classType, name, 
            /* usage */ undefined, 
            /* diag */ undefined, 16 /* MemberAccessFlags.SkipInstanceMembers */ |
                4 /* MemberAccessFlags.SkipObjectBaseClass */ |
                8 /* MemberAccessFlags.SkipTypeBaseClass */ |
                512 /* MemberAccessFlags.SkipAttributeAccessOverride */, selfType)) === null || _a === void 0 ? void 0 : _a.type;
        };
        let accessMemberType;
        if (usage.method === 'get') {
            accessMemberType = (_a = getAttributeAccessMember('__getattribute__')) !== null && _a !== void 0 ? _a : getAttributeAccessMember('__getattr__');
        }
        else if (usage.method === 'set') {
            accessMemberType = getAttributeAccessMember('__setattr__');
        }
        else {
            (0, debug_1.assert)(usage.method === 'del');
            accessMemberType = getAttributeAccessMember('__delattr__');
        }
        if (!accessMemberType) {
            return undefined;
        }
        const argList = [];
        // Provide "name" argument.
        argList.push({
            argumentCategory: 0 /* ArgumentCategory.Simple */,
            typeResult: {
                type: strClass && (0, types_1.isInstantiableClass)(strClass)
                    ? types_1.ClassType.cloneWithLiteral(types_1.ClassType.cloneAsInstance(strClass), memberName)
                    : types_1.AnyType.create(),
            },
        });
        if (usage.method === 'set') {
            // Provide "value" argument.
            argList.push({
                argumentCategory: 0 /* ArgumentCategory.Simple */,
                typeResult: {
                    type: (_c = (_b = usage.setType) === null || _b === void 0 ? void 0 : _b.type) !== null && _c !== void 0 ? _c : types_1.UnknownType.create(),
                    isIncomplete: !!((_d = usage.setType) === null || _d === void 0 ? void 0 : _d.isIncomplete),
                },
            });
        }
        if (!(0, types_1.isFunction)(accessMemberType) && !(0, types_1.isOverloadedFunction)(accessMemberType)) {
            if ((0, types_1.isAnyOrUnknown)(accessMemberType)) {
                return { type: accessMemberType };
            }
            // TODO - emit an error for this condition.
            return undefined;
        }
        const typeVarContext = new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(accessMemberType));
        const callResult = validateCallArguments(errorNode, argList, { type: accessMemberType }, typeVarContext, 
        /* skipUnknownArgCheck */ true, 
        /* inferenceContext */ undefined, 
        /* signatureTracker */ undefined);
        let isAsymmetricAccessor = false;
        if (usage.method === 'set') {
            isAsymmetricAccessor = isClassWithAsymmetricAttributeAccessor(classType);
        }
        return {
            type: (_e = callResult.returnType) !== null && _e !== void 0 ? _e : types_1.UnknownType.create(),
            typeErrors: callResult.argumentErrors,
            isAsymmetricAccessor,
        };
    }
    function getTypeOfIndex(node, flags = 0 /* EvalFlags.None */) {
        const baseTypeResult = getTypeOfExpression(node.baseExpression, flags | 2 /* EvalFlags.IndexBaseDefaults */);
        // If this is meant to be a type and the base expression is a string expression,
        // emit an error because this is an illegal annotation form and will generate a
        // runtime exception.
        if (flags & 128 /* EvalFlags.InstantiableType */) {
            if (node.baseExpression.nodeType === 48 /* ParseNodeType.StringList */) {
                addError(localize_1.LocMessage.stringNotSubscriptable(), node.baseExpression);
            }
        }
        // Check for builtin classes that will generate runtime exceptions if subscripted.
        if ((flags & 4 /* EvalFlags.ForwardRefs */) === 0) {
            // We can skip this check if the class is used within a PEP 526 variable
            // type annotation within a class or function. For some undocumented reason,
            // they don't result in runtime exceptions when used in this manner.
            let skipSubscriptCheck = (flags & 32768 /* EvalFlags.VarTypeAnnotation */) !== 0;
            if (skipSubscriptCheck) {
                const scopeNode = ParseTreeUtils.getExecutionScopeNode(node);
                if ((scopeNode === null || scopeNode === void 0 ? void 0 : scopeNode.nodeType) === 36 /* ParseNodeType.Module */) {
                    skipSubscriptCheck = false;
                }
            }
            if (!skipSubscriptCheck) {
                const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
                if ((0, types_1.isInstantiableClass)(baseTypeResult.type) &&
                    types_1.ClassType.isBuiltIn(baseTypeResult.type) &&
                    !baseTypeResult.type.aliasName) {
                    const minPythonVersion = nonSubscriptableBuiltinTypes.get(baseTypeResult.type.details.fullName);
                    if (minPythonVersion !== undefined &&
                        fileInfo.executionEnvironment.pythonVersion.isLessThan(minPythonVersion) &&
                        !fileInfo.isStubFile) {
                        addError(localize_1.LocMessage.classNotRuntimeSubscriptable().format({
                            name: baseTypeResult.type.aliasName || baseTypeResult.type.details.name,
                        }), node.baseExpression);
                    }
                }
            }
        }
        const indexTypeResult = getTypeOfIndexWithBaseType(node, baseTypeResult, { method: 'get' }, flags);
        if ((0, codeFlowTypes_1.isCodeFlowSupportedForReference)(node)) {
            // We limit type narrowing for index expressions to built-in types that are
            // known to have symmetric __getitem__ and __setitem__ methods (i.e. the value
            // passed to __setitem__ is the same type as the value returned by __getitem__).
            let baseTypeSupportsIndexNarrowing = !(0, types_1.isAny)(baseTypeResult.type);
            mapSubtypesExpandTypeVars(baseTypeResult.type, /* options */ undefined, (subtype) => {
                if (!(0, types_1.isClassInstance)(subtype) ||
                    !(types_1.ClassType.isBuiltIn(subtype) || types_1.ClassType.isTypedDictClass(subtype))) {
                    baseTypeSupportsIndexNarrowing = false;
                }
                return undefined;
            });
            if (baseTypeSupportsIndexNarrowing) {
                // Before performing code flow analysis, update the cache to prevent recursion.
                writeTypeCache(node, { ...indexTypeResult, isIncomplete: true }, flags);
                // See if we can refine the type based on code flow analysis.
                const codeFlowTypeResult = getFlowTypeOfReference(node, /* startNode */ undefined, {
                    targetSymbolId: symbol_1.indeterminateSymbolId,
                    typeAtStart: {
                        type: indexTypeResult.type,
                        isIncomplete: !!baseTypeResult.isIncomplete || !!indexTypeResult.isIncomplete,
                    },
                    skipConditionalNarrowing: (flags & 256 /* EvalFlags.TypeExpression */) !== 0,
                });
                if (codeFlowTypeResult.type) {
                    indexTypeResult.type = codeFlowTypeResult.type;
                }
                if (codeFlowTypeResult.isIncomplete) {
                    indexTypeResult.isIncomplete = true;
                }
            }
        }
        if (baseTypeResult.isIncomplete) {
            indexTypeResult.isIncomplete = true;
        }
        return indexTypeResult;
    }
    // If the list of type parameters includes a TypeVarTuple, we may need to adjust
    // the supplied type arguments to map to the type parameter list.
    function adjustTypeArgumentsForVariadicTypeVar(typeArgs, typeParameters, errorNode) {
        const variadicIndex = typeParameters.findIndex((param) => (0, types_1.isVariadicTypeVar)(param));
        // Is there a *tuple[T, ...] somewhere in the type arguments that we can expand if needed?
        let srcUnboundedTupleType;
        let srcUnboundedTupleIndex = typeArgs.findIndex((arg) => {
            if ((0, types_1.isUnpackedClass)(arg.type) &&
                arg.type.tupleTypeArguments &&
                arg.type.tupleTypeArguments.length === 1 &&
                arg.type.tupleTypeArguments[0].isUnbounded) {
                srcUnboundedTupleType = arg.type.tupleTypeArguments[0].type;
                return true;
            }
            return false;
        });
        if (srcUnboundedTupleType &&
            srcUnboundedTupleIndex >= 0 &&
            variadicIndex >= 0 &&
            typeArgs.length < typeParameters.length) {
            // "Smear" the tuple type across type argument slots prior to the variadic type var.
            while (variadicIndex > srcUnboundedTupleIndex) {
                typeArgs = [
                    ...typeArgs.slice(0, srcUnboundedTupleIndex),
                    { node: typeArgs[srcUnboundedTupleIndex].node, type: srcUnboundedTupleType },
                    ...typeArgs.slice(srcUnboundedTupleIndex),
                ];
                srcUnboundedTupleIndex++;
            }
            // "Smear" the tuple type across type argument slots following the variadic type var.
            while (typeArgs.length < typeParameters.length) {
                typeArgs = [
                    ...typeArgs.slice(0, srcUnboundedTupleIndex + 1),
                    { node: typeArgs[srcUnboundedTupleIndex].node, type: srcUnboundedTupleType },
                    ...typeArgs.slice(srcUnboundedTupleIndex + 1),
                ];
            }
        }
        // Do we need to adjust the type arguments to map to a variadic type
        // param somewhere in the list?
        if (variadicIndex >= 0) {
            const variadicTypeVar = typeParameters[variadicIndex];
            // If the type param list ends with a ParamSpec with a default value,
            // we can ignore it for purposes of finding type args that map to the
            // TypeVarTuple.
            let typeParamCount = typeParameters.length;
            while (typeParamCount > 0) {
                const lastTypeParam = typeParameters[typeParamCount - 1];
                if (!lastTypeParam.details.isParamSpec || !lastTypeParam.details.isDefaultExplicit) {
                    break;
                }
                typeParamCount--;
            }
            if (variadicIndex < typeArgs.length) {
                // If there are typeArg lists at the end, these should map to ParamSpecs rather
                // than the TypeVarTuple, so exclude them.
                let variadicEndIndex = variadicIndex + 1 + typeArgs.length - typeParamCount;
                while (variadicEndIndex > variadicIndex) {
                    if (!typeArgs[variadicEndIndex - 1].typeList) {
                        break;
                    }
                    variadicEndIndex--;
                }
                const variadicTypeResults = typeArgs.slice(variadicIndex, variadicEndIndex);
                // If the type args consist of a lone variadic type variable, don't wrap it in a tuple.
                if (variadicTypeResults.length === 1 && (0, types_1.isVariadicTypeVar)(variadicTypeResults[0].type)) {
                    validateVariadicTypeVarIsUnpacked(variadicTypeResults[0].type, variadicTypeResults[0].node);
                }
                else {
                    variadicTypeResults.forEach((arg, index) => {
                        validateTypeArg(arg, {
                            allowEmptyTuple: index === 0,
                            allowVariadicTypeVar: true,
                            allowUnpackedTuples: true,
                        });
                    });
                    const variadicTypes = [];
                    if (variadicTypeResults.length !== 1 || !variadicTypeResults[0].isEmptyTupleShorthand) {
                        variadicTypeResults.forEach((typeResult) => {
                            if ((0, types_1.isUnpackedClass)(typeResult.type) && typeResult.type.tupleTypeArguments) {
                                (0, collectionUtils_1.appendArray)(variadicTypes, typeResult.type.tupleTypeArguments);
                            }
                            else {
                                variadicTypes.push({
                                    type: (0, typeUtils_1.convertToInstance)(typeResult.type),
                                    isUnbounded: false,
                                });
                            }
                        });
                    }
                    const tupleObject = makeTupleObject(variadicTypes, /* isUnpackedTuple */ true);
                    typeArgs = [
                        ...typeArgs.slice(0, variadicIndex),
                        { node: typeArgs[variadicIndex].node, type: tupleObject },
                        ...typeArgs.slice(variadicEndIndex, typeArgs.length),
                    ];
                }
            }
            else if (!variadicTypeVar.details.isDefaultExplicit) {
                // Add an empty tuple that maps to the TypeVarTuple type parameter.
                typeArgs.push({
                    node: errorNode,
                    type: makeTupleObject([], /* isUnpackedTuple */ true),
                });
            }
        }
        return typeArgs;
    }
    // If the variadic type variable is not unpacked, report an error.
    function validateVariadicTypeVarIsUnpacked(type, node) {
        if (!type.isVariadicUnpacked) {
            addError(localize_1.LocMessage.unpackedTypeVarTupleExpected().format({
                name1: type.details.name,
                name2: type.details.name,
            }), node);
            return false;
        }
        return true;
    }
    // Handles index expressions that are providing type arguments for a
    // generic type alias.
    function createSpecializedTypeAlias(node, baseType, flags) {
        var _a, _b, _c;
        if (!((_a = baseType.typeAliasInfo) === null || _a === void 0 ? void 0 : _a.typeParameters) ||
            (baseType.typeAliasInfo.typeParameters.length === 0 && baseType.typeAliasInfo.typeArguments)) {
            return undefined;
        }
        // If this is not instantiable, then the index expression isn't a specialization.
        if (!types_1.TypeBase.isInstantiable(baseType)) {
            return undefined;
        }
        // If this is already specialized, the index expression isn't a specialization.
        if (baseType.typeAliasInfo.typeArguments) {
            return undefined;
        }
        const typeParameters = baseType.typeAliasInfo.typeParameters;
        let typeArgs = adjustTypeArgumentsForVariadicTypeVar(getTypeArgs(node, flags), typeParameters, node);
        // PEP 612 says that if the class has only one type parameter consisting
        // of a ParamSpec, the list of arguments does not need to be enclosed in
        // a list. We'll handle that case specially here. Presumably this applies to
        // type aliases as well.
        if (typeParameters.length === 1 && typeParameters[0].details.isParamSpec && typeArgs) {
            if (typeArgs.every((typeArg) => !(0, typeUtils_1.isEllipsisType)(typeArg.type) && !typeArg.typeList && !(0, types_1.isParamSpec)(typeArg.type))) {
                typeArgs = [
                    {
                        type: types_1.UnknownType.create(),
                        node: typeArgs[0].node,
                        typeList: typeArgs,
                    },
                ];
            }
        }
        let minTypeArgCount = typeParameters.length;
        const firstDefaultParamIndex = typeParameters.findIndex((param) => !!param.details.isDefaultExplicit);
        if (firstDefaultParamIndex >= 0) {
            minTypeArgCount = firstDefaultParamIndex;
        }
        if (typeArgs.length > typeParameters.length) {
            addError(localize_1.LocMessage.typeArgsTooMany().format({
                name: printType(baseType),
                expected: typeParameters.length,
                received: typeArgs.length,
            }), typeArgs[typeParameters.length].node);
        }
        else if (typeArgs.length < minTypeArgCount) {
            addError(localize_1.LocMessage.typeArgsTooFew().format({
                name: printType(baseType),
                expected: typeParameters.length,
                received: typeArgs.length,
            }), node.items[node.items.length - 1]);
        }
        // Handle the mypy_extensions.FlexibleAlias type specially.
        if ((0, types_1.isInstantiableClass)(baseType) &&
            baseType.details.fullName === 'mypy_extensions.FlexibleAlias' &&
            typeArgs.length >= 1) {
            return { node, type: typeArgs[0].type };
        }
        const typeVarContext = new typeVarContext_1.TypeVarContext(baseType.typeAliasInfo.typeVarScopeId);
        const diag = new diagnostic_1.DiagnosticAddendum();
        typeParameters.forEach((param, index) => {
            if (param.details.isParamSpec && index < typeArgs.length) {
                const typeArgType = typeArgs[index].type;
                const typeList = typeArgs[index].typeList;
                if (typeList) {
                    const functionType = types_1.FunctionType.createSynthesizedInstance('', 65536 /* FunctionTypeFlags.ParamSpecValue */);
                    typeList.forEach((paramType, paramIndex) => {
                        types_1.FunctionType.addParameter(functionType, {
                            category: 0 /* ParameterCategory.Simple */,
                            name: `__p${paramIndex}`,
                            isNameSynthesized: true,
                            type: (0, typeUtils_1.convertToInstance)(paramType.type),
                            hasDeclaredType: true,
                        });
                    });
                    if (typeList.length > 0) {
                        types_1.FunctionType.addPositionOnlyParameterSeparator(functionType);
                    }
                    (0, constraintSolver_1.assignTypeToTypeVar)(evaluatorInterface, param, functionType, diag, typeVarContext, 256 /* AssignTypeFlags.RetainLiteralsForTypeVar */);
                }
                else if ((0, types_1.isParamSpec)(typeArgType)) {
                    (0, constraintSolver_1.assignTypeToTypeVar)(evaluatorInterface, param, (0, typeUtils_1.convertToInstance)(typeArgType), diag, typeVarContext, 256 /* AssignTypeFlags.RetainLiteralsForTypeVar */);
                }
                else if ((0, types_1.isInstantiableClass)(typeArgType) && types_1.ClassType.isBuiltIn(typeArgType, 'Concatenate')) {
                    const concatTypeArgs = typeArgType.typeArguments;
                    const functionType = types_1.FunctionType.createInstance('', '', '', 0 /* FunctionTypeFlags.None */);
                    if (concatTypeArgs && concatTypeArgs.length > 0) {
                        concatTypeArgs.forEach((typeArg, index) => {
                            if (index === concatTypeArgs.length - 1) {
                                types_1.FunctionType.addPositionOnlyParameterSeparator(functionType);
                                if ((0, types_1.isParamSpec)(typeArg)) {
                                    types_1.FunctionType.addParamSpecVariadics(functionType, typeArg);
                                }
                                else if ((0, typeUtils_1.isEllipsisType)(typeArg)) {
                                    types_1.FunctionType.addDefaultParameters(functionType);
                                    functionType.details.flags |= 32768 /* FunctionTypeFlags.GradualCallableForm */;
                                }
                            }
                            else {
                                types_1.FunctionType.addParameter(functionType, {
                                    category: 0 /* ParameterCategory.Simple */,
                                    name: `__p${index}`,
                                    isNameSynthesized: true,
                                    hasDeclaredType: true,
                                    type: typeArg,
                                });
                            }
                        });
                    }
                    (0, constraintSolver_1.assignTypeToTypeVar)(evaluatorInterface, param, functionType, diag, typeVarContext, 256 /* AssignTypeFlags.RetainLiteralsForTypeVar */);
                }
                else if ((0, typeUtils_1.isEllipsisType)(typeArgType)) {
                    const functionType = types_1.FunctionType.createSynthesizedInstance('', 65536 /* FunctionTypeFlags.ParamSpecValue */ | 32768 /* FunctionTypeFlags.GradualCallableForm */);
                    types_1.FunctionType.addDefaultParameters(functionType);
                    (0, constraintSolver_1.assignTypeToTypeVar)(evaluatorInterface, param, functionType, diag, typeVarContext);
                }
                else {
                    addError(localize_1.LocMessage.typeArgListExpected(), typeArgs[index].node);
                }
            }
            else {
                if (index < typeArgs.length && typeArgs[index].typeList) {
                    addError(localize_1.LocMessage.typeArgListNotAllowed(), typeArgs[index].node);
                }
                let typeArgType;
                if (index < typeArgs.length) {
                    typeArgType = (0, typeUtils_1.convertToInstance)(typeArgs[index].type);
                }
                else if (param.details.isDefaultExplicit) {
                    typeArgType = (0, typeUtils_1.applySolvedTypeVars)(param, typeVarContext, {
                        unknownIfNotFound: true,
                        tupleClassType: getTupleClassType(),
                    });
                }
                else {
                    typeArgType = types_1.UnknownType.create();
                }
                if ((flags & 16384 /* EvalFlags.EnforceVarianceConsistency */) !== 0) {
                    const usageVariances = inferTypeParameterVarianceForTypeAlias(baseType);
                    if (usageVariances && index < usageVariances.length) {
                        const usageVariance = usageVariances[index];
                        if (!(0, typeUtils_1.isVarianceOfTypeArgumentCompatible)(typeArgType, usageVariance)) {
                            const messageDiag = diag.createAddendum();
                            messageDiag.addMessage(localize_1.LocAddendum.varianceMismatchForTypeAlias().format({
                                typeVarName: printType(typeArgType),
                                typeAliasParam: printType(typeParameters[index]),
                            }));
                            messageDiag.addTextRange(typeArgs[index].node);
                        }
                    }
                }
                if ((0, types_1.isUnpacked)(typeArgType) && !(0, types_1.isVariadicTypeVar)(param)) {
                    const messageDiag = diag.createAddendum();
                    messageDiag.addMessage(localize_1.LocMessage.unpackedArgInTypeArgument());
                    messageDiag.addTextRange(typeArgs[index].node);
                    typeArgType = types_1.UnknownType.create();
                }
                (0, constraintSolver_1.assignTypeToTypeVar)(evaluatorInterface, param, typeArgType, diag, typeVarContext, 256 /* AssignTypeFlags.RetainLiteralsForTypeVar */);
            }
        });
        if (!diag.isEmpty()) {
            addError(localize_1.LocMessage.typeNotSpecializable().format({ type: printType(baseType) }) + diag.getString(), node, (_b = diag.getEffectiveTextRange()) !== null && _b !== void 0 ? _b : node);
        }
        const primarySignatureContext = typeVarContext.getPrimarySignature();
        const aliasTypeArgs = [];
        (_c = baseType.typeAliasInfo.typeParameters) === null || _c === void 0 ? void 0 : _c.forEach((typeParam) => {
            let typeVarType;
            if ((0, types_1.isParamSpec)(typeParam)) {
                const paramSpecType = primarySignatureContext.getParamSpecType(typeParam);
                typeVarType = paramSpecType ? (0, typeUtils_1.convertParamSpecValueToType)(paramSpecType) : types_1.UnknownType.create();
                if (!typeVarType) {
                    typeVarType = (0, typeUtils_1.getUnknownTypeForParamSpec)();
                    primarySignatureContext.setTypeVarType(typeParam, typeVarType);
                }
            }
            else {
                typeVarType = primarySignatureContext.getTypeVarType(typeParam);
                if (!typeVarType) {
                    typeVarType = types_1.UnknownType.create();
                    primarySignatureContext.setTypeVarType(typeParam, typeVarType);
                }
            }
            aliasTypeArgs.push(typeVarType);
        });
        const type = types_1.TypeBase.cloneForTypeAlias((0, typeUtils_1.applySolvedTypeVars)(baseType, typeVarContext), baseType.typeAliasInfo.name, baseType.typeAliasInfo.fullName, baseType.typeAliasInfo.moduleName, baseType.typeAliasInfo.fileUri, baseType.typeAliasInfo.typeVarScopeId, baseType.typeAliasInfo.isPep695Syntax, baseType.typeAliasInfo.typeParameters, aliasTypeArgs);
        return { type, node };
    }
    function getTypeOfIndexWithBaseType(node, baseTypeResult, usage, flags) {
        // Handle the case where we're specializing a generic type alias.
        const typeAliasResult = createSpecializedTypeAlias(node, baseTypeResult.type, flags);
        if (typeAliasResult) {
            return typeAliasResult;
        }
        if ((0, types_1.isTypeVar)(baseTypeResult.type) && (0, typeUtils_1.isTypeAliasPlaceholder)(baseTypeResult.type)) {
            const typeArgTypes = getTypeArgs(node, flags).map((t) => (0, typeUtils_1.convertToInstance)(t.type));
            const type = types_1.TypeBase.cloneForTypeAlias(baseTypeResult.type, baseTypeResult.type.details.recursiveTypeAliasName, '', '', uri_1.Uri.empty(), baseTypeResult.type.details.recursiveTypeAliasScopeId, !!baseTypeResult.type.details.recursiveTypeAliasIsPep695Syntax, baseTypeResult.type.details.recursiveTypeParameters, typeArgTypes);
            return { type };
        }
        let isIncomplete = baseTypeResult.isIncomplete;
        let isRequired = false;
        let isNotRequired = false;
        let isReadOnly = false;
        const type = mapSubtypesExpandTypeVars(baseTypeResult.type, 
        /* options */ undefined, (concreteSubtype, unexpandedSubtype) => {
            var _a;
            const selfType = (0, types_1.isTypeVar)(unexpandedSubtype) ? unexpandedSubtype : undefined;
            if ((0, types_1.isAnyOrUnknown)(concreteSubtype)) {
                if ((flags & 256 /* EvalFlags.TypeExpression */) !== 0) {
                    // If we are expecting a type annotation here, assume that
                    // the subscripts are type arguments and evaluate them
                    // accordingly.
                    getTypeArgs(node, flags);
                }
                return concreteSubtype;
            }
            if (flags & 128 /* EvalFlags.InstantiableType */) {
                if ((0, types_1.isTypeVar)(unexpandedSubtype)) {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeVarNotSubscriptable().format({
                        type: printType(unexpandedSubtype),
                    }), node.baseExpression);
                    // Evaluate the index expressions as though they are type arguments for error-reporting.
                    getTypeArgs(node, flags);
                    return types_1.UnknownType.create();
                }
            }
            if ((0, types_1.isInstantiableClass)(concreteSubtype)) {
                // See if the class has a custom metaclass that supports __getitem__, etc.
                if (concreteSubtype.details.effectiveMetaclass &&
                    (0, types_1.isInstantiableClass)(concreteSubtype.details.effectiveMetaclass) &&
                    !types_1.ClassType.isBuiltIn(concreteSubtype.details.effectiveMetaclass, ['type', '_InitVarMeta']) &&
                    (flags & 128 /* EvalFlags.InstantiableType */) === 0) {
                    const itemMethodType = getBoundMagicMethod(concreteSubtype, getIndexAccessMagicMethodName(usage));
                    if ((flags & 256 /* EvalFlags.TypeExpression */) !== 0) {
                        // If the class doesn't derive from Generic, a type argument should not be allowed.
                        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportInvalidTypeArguments, localize_1.LocMessage.typeArgsExpectingNone().format({
                            name: printType(types_1.ClassType.cloneAsInstance(concreteSubtype)),
                        }), node);
                    }
                    if (itemMethodType) {
                        return getTypeOfIndexedObjectOrClass(node, concreteSubtype, selfType, usage).type;
                    }
                }
                // Setting the value of an indexed class will always result
                // in an exception.
                if (usage.method === 'set') {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.genericClassAssigned(), node.baseExpression);
                }
                else if (usage.method === 'del') {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.genericClassDeleted(), node.baseExpression);
                }
                if (types_1.ClassType.isSpecialBuiltIn(concreteSubtype, 'Literal')) {
                    // Special-case Literal types.
                    return createLiteralType(concreteSubtype, node, flags);
                }
                if (types_1.ClassType.isBuiltIn(concreteSubtype, 'InitVar')) {
                    // Special-case InitVar, used in dataclasses.
                    const typeArgs = getTypeArgs(node, flags);
                    if ((flags & 256 /* EvalFlags.TypeExpression */) !== 0) {
                        if ((flags & 32768 /* EvalFlags.VarTypeAnnotation */) === 0) {
                            addError(localize_1.LocMessage.initVarNotAllowed(), node.baseExpression);
                        }
                    }
                    if (typeArgs.length === 1) {
                        return typeArgs[0].type;
                    }
                    else {
                        addError(localize_1.LocMessage.typeArgsMismatchOne().format({ received: typeArgs.length }), node.baseExpression);
                        return types_1.UnknownType.create();
                    }
                }
                if (types_1.ClassType.isEnumClass(concreteSubtype)) {
                    // Special-case Enum types.
                    // TODO - validate that there's only one index entry
                    // that is a str type.
                    // TODO - validate that literal strings are referencing
                    // a known enum member.
                    return types_1.ClassType.cloneAsInstance(concreteSubtype);
                }
                const isAnnotatedClass = (0, types_1.isInstantiableClass)(concreteSubtype) && types_1.ClassType.isBuiltIn(concreteSubtype, 'Annotated');
                const hasCustomClassGetItem = (0, types_1.isInstantiableClass)(concreteSubtype) && types_1.ClassType.hasCustomClassGetItem(concreteSubtype);
                const isGenericClass = ((_a = concreteSubtype.details.typeParameters) === null || _a === void 0 ? void 0 : _a.length) > 0 ||
                    types_1.ClassType.isSpecialBuiltIn(concreteSubtype) ||
                    types_1.ClassType.isBuiltIn(concreteSubtype, 'type') ||
                    types_1.ClassType.isPartiallyEvaluated(concreteSubtype);
                const isFinalAnnotation = (0, types_1.isInstantiableClass)(concreteSubtype) && types_1.ClassType.isBuiltIn(concreteSubtype, 'Final');
                const isClassVarAnnotation = (0, types_1.isInstantiableClass)(concreteSubtype) && types_1.ClassType.isBuiltIn(concreteSubtype, 'ClassVar');
                let typeArgs = getTypeArgs(node, flags, {
                    isAnnotatedClass,
                    hasCustomClassGetItem: hasCustomClassGetItem || !isGenericClass,
                    isFinalAnnotation,
                    isClassVarAnnotation,
                });
                if (!isAnnotatedClass) {
                    typeArgs = adjustTypeArgumentsForVariadicTypeVar(typeArgs, concreteSubtype.details.typeParameters, node);
                }
                // If this is a custom __class_getitem__, there's no need to specialize the class.
                // Just return it as is.
                if (hasCustomClassGetItem) {
                    return concreteSubtype;
                }
                if (concreteSubtype.typeArguments) {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportInvalidTypeArguments, localize_1.LocMessage.classAlreadySpecialized().format({
                        type: printType((0, typeUtils_1.convertToInstance)(concreteSubtype), { expandTypeAlias: true }),
                    }), node.baseExpression);
                    return concreteSubtype;
                }
                const result = createSpecializedClassType(concreteSubtype, typeArgs, flags, node);
                if (result.isRequired) {
                    isRequired = true;
                }
                else if (result.isNotRequired) {
                    isNotRequired = true;
                }
                if (result.isReadOnly) {
                    isReadOnly = true;
                }
                return result.type;
            }
            if ((0, typeUtils_1.isNoneInstance)(concreteSubtype)) {
                if (!isIncomplete) {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportOptionalSubscript, localize_1.LocMessage.noneNotSubscriptable(), node.baseExpression);
                }
                return types_1.UnknownType.create();
            }
            if ((0, types_1.isClassInstance)(concreteSubtype)) {
                const typeResult = getTypeOfIndexedObjectOrClass(node, concreteSubtype, selfType, usage);
                if (typeResult.isIncomplete) {
                    isIncomplete = true;
                }
                return typeResult.type;
            }
            if ((0, types_1.isNever)(concreteSubtype)) {
                return types_1.NeverType.createNever();
            }
            if ((0, types_1.isUnbound)(concreteSubtype)) {
                return types_1.UnknownType.create();
            }
            if (!isIncomplete) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportIndexIssue, localize_1.LocMessage.typeNotSubscriptable().format({ type: printType(concreteSubtype) }), node.baseExpression);
            }
            return types_1.UnknownType.create();
        });
        // In case we didn't walk the list items above, do so now.
        // If we have, this information will be cached.
        if (!baseTypeResult.isIncomplete) {
            node.items.forEach((item) => {
                if (!isTypeCached(item.valueExpression)) {
                    getTypeOfExpression(item.valueExpression, flags & 4 /* EvalFlags.ForwardRefs */);
                }
            });
        }
        return { type, isIncomplete, isReadOnly, isRequired, isNotRequired };
    }
    // Determines the effective variance of the type parameters for a generic
    // type alias. Normally, variance is not important for type aliases, but
    // it can be important in cases where the type alias is used to specify
    // a base class in a class definition.
    function inferTypeParameterVarianceForTypeAlias(type) {
        // If this isn't a generic type alias, there's nothing to do.
        if (!type.typeAliasInfo || !type.typeAliasInfo.typeParameters) {
            return undefined;
        }
        // Is the usage variance info already cached?
        if (type.typeAliasInfo.usageVariance) {
            return type.typeAliasInfo.usageVariance;
        }
        const typeParams = type.typeAliasInfo.typeParameters;
        // Start with all of the usage variances unknown.
        const usageVariances = typeParams.map(() => 1 /* Variance.Unknown */);
        // Prepopulate the cached value for the type alias to handle
        // recursive type aliases.
        type.typeAliasInfo.usageVariance = usageVariances;
        // Traverse the type alias type definition and adjust the usage
        // variances accordingly.
        updateUsageVariancesRecursive(type, typeParams, usageVariances);
        return usageVariances;
    }
    // Looks at uses of the type parameters within the type and adjusts the
    // variances accordingly. For example, if the type is `Mapping[T1, T2]`,
    // then T1 will be set to invariant and T2 will be set to covariant.
    function updateUsageVariancesRecursive(type, typeAliasTypeParams, usageVariances, recursionCount = 0) {
        if (recursionCount > types_1.maxTypeRecursionCount) {
            return;
        }
        recursionCount++;
        // Define a helper function that performs the actual usage variant update.
        function updateUsageVarianceForType(type, variance) {
            (0, typeUtils_1.doForEachSubtype)(type, (subtype) => {
                const typeParamIndex = typeAliasTypeParams.findIndex((param) => (0, types_1.isTypeSame)(param, subtype));
                if (typeParamIndex >= 0) {
                    usageVariances[typeParamIndex] = (0, typeUtils_1.combineVariances)(usageVariances[typeParamIndex], variance);
                }
                else {
                    updateUsageVariancesRecursive(subtype, typeAliasTypeParams, usageVariances, recursionCount);
                }
            });
        }
        (0, typeUtils_1.doForEachSubtype)(type, (subtype) => {
            if (subtype.category === 4 /* TypeCategory.Function */) {
                if (subtype.specializedTypes) {
                    subtype.specializedTypes.parameterTypes.forEach((paramType) => {
                        updateUsageVarianceForType(paramType, 4 /* Variance.Contravariant */);
                    });
                    const returnType = subtype.specializedTypes.returnType;
                    if (returnType) {
                        updateUsageVarianceForType(returnType, 3 /* Variance.Covariant */);
                    }
                }
            }
            else if (subtype.category === 6 /* TypeCategory.Class */) {
                if (subtype.typeArguments) {
                    // If the class includes type parameters that uses auto variance,
                    // compute the calculated variance.
                    inferTypeParameterVarianceForClass(subtype);
                    // Is the class specialized using any type arguments that correspond to
                    // the type alias' type parameters?
                    subtype.typeArguments.forEach((typeArg, classParamIndex) => {
                        var _a;
                        if ((0, typeUtils_1.isTupleClass)(subtype)) {
                            updateUsageVarianceForType(typeArg, 3 /* Variance.Covariant */);
                        }
                        else if (classParamIndex < subtype.details.typeParameters.length) {
                            const classTypeParam = subtype.details.typeParameters[classParamIndex];
                            if ((0, types_1.isUnpackedClass)(typeArg) && typeArg.tupleTypeArguments) {
                                typeArg.tupleTypeArguments.forEach((tupleTypeArg) => {
                                    updateUsageVarianceForType(tupleTypeArg.type, 2 /* Variance.Invariant */);
                                });
                            }
                            else {
                                updateUsageVarianceForType(typeArg, (_a = classTypeParam.computedVariance) !== null && _a !== void 0 ? _a : classTypeParam.details.declaredVariance);
                            }
                        }
                    });
                }
            }
        });
    }
    function makeTupleObject(typeArgs, isUnpackedTuple = false) {
        if (tupleClass && (0, types_1.isInstantiableClass)(tupleClass)) {
            return (0, typeUtils_1.convertToInstance)((0, typeUtils_1.specializeTupleClass)(tupleClass, typeArgs, /* isTypeArgumentExplicit */ true, isUnpackedTuple));
        }
        return types_1.UnknownType.create();
    }
    function getIndexAccessMagicMethodName(usage) {
        if (usage.method === 'get') {
            return '__getitem__';
        }
        else if (usage.method === 'set') {
            return '__setitem__';
        }
        else {
            (0, debug_1.assert)(usage.method === 'del');
            return '__delitem__';
        }
    }
    function getTypeOfIndexedObjectOrClass(node, baseType, selfType, usage) {
        var _a, _b, _c, _d;
        // Handle index operations for TypedDict classes specially.
        if ((0, types_1.isClassInstance)(baseType) && types_1.ClassType.isTypedDictClass(baseType)) {
            const typeFromTypedDict = (0, typedDicts_1.getTypeOfIndexedTypedDict)(evaluatorInterface, node, baseType, usage);
            if (typeFromTypedDict) {
                return typeFromTypedDict;
            }
        }
        const magicMethodName = getIndexAccessMagicMethodName(usage);
        const itemMethodType = getBoundMagicMethod(baseType, magicMethodName, selfType);
        if (!itemMethodType) {
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportIndexIssue, localize_1.LocMessage.methodNotDefinedOnType().format({
                name: magicMethodName,
                type: printType(baseType),
            }), node.baseExpression);
            return { type: types_1.UnknownType.create() };
        }
        // Handle the special case where the object is a tuple and
        // the index is a constant number (integer) or a slice with integer
        // start and end values. In these cases, we can determine
        // the exact type by indexing into the tuple type array.
        if (node.items.length === 1 &&
            !node.trailingComma &&
            !node.items[0].name &&
            node.items[0].argumentCategory === 0 /* ArgumentCategory.Simple */ &&
            (0, types_1.isClassInstance)(baseType)) {
            const index0Expr = node.items[0].valueExpression;
            const valueType = getTypeOfExpression(index0Expr).type;
            if ((0, types_1.isClassInstance)(valueType) &&
                types_1.ClassType.isBuiltIn(valueType, 'int') &&
                (0, typeUtils_1.isLiteralType)(valueType) &&
                typeof valueType.literalValue === 'number') {
                const indexValue = valueType.literalValue;
                const tupleType = (0, typeUtils_1.getSpecializedTupleType)(baseType);
                if (tupleType && tupleType.tupleTypeArguments) {
                    if ((0, typeUtils_1.isTupleIndexUnambiguous)(tupleType, indexValue)) {
                        if (indexValue >= 0 && indexValue < tupleType.tupleTypeArguments.length) {
                            return { type: tupleType.tupleTypeArguments[indexValue].type };
                        }
                        else if (indexValue < 0 && tupleType.tupleTypeArguments.length + indexValue >= 0) {
                            return {
                                type: tupleType.tupleTypeArguments[tupleType.tupleTypeArguments.length + indexValue]
                                    .type,
                            };
                        }
                    }
                }
            }
            else if ((0, types_1.isClassInstance)(valueType) && types_1.ClassType.isBuiltIn(valueType, 'slice')) {
                const tupleType = (0, typeUtils_1.getSpecializedTupleType)(baseType);
                if (tupleType && index0Expr.nodeType === 46 /* ParseNodeType.Slice */) {
                    const slicedTupleType = getSlicedTupleType(tupleType, index0Expr);
                    if (slicedTupleType) {
                        return { type: slicedTupleType };
                    }
                }
            }
        }
        // Follow PEP 637 rules for positional and keyword arguments.
        const positionalArgs = node.items.filter((item) => item.argumentCategory === 0 /* ArgumentCategory.Simple */ && !item.name);
        const unpackedListArgs = node.items.filter((item) => item.argumentCategory === 1 /* ArgumentCategory.UnpackedList */);
        const keywordArgs = node.items.filter((item) => item.argumentCategory === 0 /* ArgumentCategory.Simple */ && !!item.name);
        const unpackedDictArgs = node.items.filter((item) => item.argumentCategory === 2 /* ArgumentCategory.UnpackedDictionary */);
        let positionalIndexType;
        let isPositionalIndexTypeIncomplete = false;
        if (positionalArgs.length === 1 && unpackedListArgs.length === 0 && !node.trailingComma) {
            // Handle the common case where there is a single positional argument.
            const typeResult = getTypeOfExpression(positionalArgs[0].valueExpression);
            positionalIndexType = typeResult.type;
            if (typeResult.isIncomplete) {
                isPositionalIndexTypeIncomplete = true;
            }
        }
        else if (positionalArgs.length === 0 && unpackedListArgs.length === 0) {
            // Handle the case where there are no positionals provided but there are keywords.
            positionalIndexType = makeTupleObject([]);
        }
        else {
            // Package up all of the positionals into a tuple.
            const tupleTypeArgs = [];
            positionalArgs.forEach((arg) => {
                const typeResult = getTypeOfExpression(arg.valueExpression);
                tupleTypeArgs.push({ type: typeResult.type, isUnbounded: false });
                if (typeResult.isIncomplete) {
                    isPositionalIndexTypeIncomplete = true;
                }
            });
            unpackedListArgs.forEach((arg) => {
                var _a, _b;
                const typeResult = getTypeOfExpression(arg.valueExpression);
                if (typeResult.isIncomplete) {
                    isPositionalIndexTypeIncomplete = true;
                }
                const iterableType = (_b = (_a = getTypeOfIterator(typeResult, /* isAsync */ false, arg.valueExpression)) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : types_1.UnknownType.create();
                tupleTypeArgs.push({ type: iterableType, isUnbounded: true });
            });
            positionalIndexType = makeTupleObject(tupleTypeArgs);
        }
        const argList = [
            {
                argumentCategory: 0 /* ArgumentCategory.Simple */,
                typeResult: { type: positionalIndexType, isIncomplete: isPositionalIndexTypeIncomplete },
            },
        ];
        if (usage.method === 'set') {
            let setType = (_b = (_a = usage.setType) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : types_1.AnyType.create();
            // Expand constrained type variables.
            if ((0, types_1.isTypeVar)(setType) && setType.details.constraints.length > 0) {
                const conditionFilter = (0, types_1.isClassInstance)(baseType) ? baseType.condition : undefined;
                setType = makeTopLevelTypeVarsConcrete(setType, 
                /* makeParamSpecsConcrete */ undefined, conditionFilter);
            }
            argList.push({
                argumentCategory: 0 /* ArgumentCategory.Simple */,
                typeResult: {
                    type: setType,
                    isIncomplete: !!((_c = usage.setType) === null || _c === void 0 ? void 0 : _c.isIncomplete),
                },
            });
        }
        keywordArgs.forEach((arg) => {
            argList.push({
                argumentCategory: 0 /* ArgumentCategory.Simple */,
                valueExpression: arg.valueExpression,
                node: arg,
                name: arg.name,
            });
        });
        unpackedDictArgs.forEach((arg) => {
            argList.push({
                argumentCategory: 2 /* ArgumentCategory.UnpackedDictionary */,
                valueExpression: arg.valueExpression,
                node: arg,
            });
        });
        const callResult = validateCallArguments(node, argList, { type: itemMethodType }, 
        /* typeVarContext */ undefined, 
        /* skipUnknownArgCheck */ true, 
        /* inferenceContext */ undefined, 
        /* signatureTracker */ undefined);
        return {
            type: (_d = callResult.returnType) !== null && _d !== void 0 ? _d : types_1.UnknownType.create(),
            isIncomplete: !!callResult.isTypeIncomplete,
        };
    }
    // Given a tuple type and a slice expression, determines the resulting
    // type if it can be determined. If not, it returns undefined.
    function getSlicedTupleType(tupleType, sliceNode) {
        // We don't handle step values.
        if (sliceNode.stepValue || !tupleType.tupleTypeArguments) {
            return undefined;
        }
        const tupleTypeArgs = tupleType.tupleTypeArguments;
        const startValue = getTupleSliceParameter(sliceNode.startValue, 0, tupleTypeArgs);
        const endValue = getTupleSliceParameter(sliceNode.endValue, tupleTypeArgs.length, tupleTypeArgs);
        if (startValue === undefined || endValue === undefined || endValue < startValue) {
            return undefined;
        }
        const slicedTypeArgs = tupleTypeArgs.slice(startValue, endValue);
        return makeTupleObject(slicedTypeArgs);
    }
    function getTupleSliceParameter(expression, defaultValue, tupleTypeArgs) {
        let value = defaultValue;
        if (expression) {
            const valType = getTypeOfExpression(expression).type;
            if (!(0, types_1.isClassInstance)(valType) || !types_1.ClassType.isBuiltIn(valType, 'int') || !(0, typeUtils_1.isLiteralType)(valType)) {
                return undefined;
            }
            value = valType.literalValue;
            const unboundedIndex = tupleTypeArgs.findIndex((typeArg) => typeArg.isUnbounded || (0, types_1.isVariadicTypeVar)(typeArg.type));
            if (value < 0) {
                value = tupleTypeArgs.length + value;
                if (unboundedIndex >= 0 && value <= unboundedIndex) {
                    return undefined;
                }
                else if (value < 0) {
                    return 0;
                }
            }
            else {
                if (unboundedIndex >= 0 && value > unboundedIndex) {
                    return undefined;
                }
                else if (value > tupleTypeArgs.length) {
                    return tupleTypeArgs.length;
                }
            }
        }
        return value;
    }
    function getTypeArgs(node, flags, options) {
        const typeArgs = [];
        let adjFlags = flags;
        if (options === null || options === void 0 ? void 0 : options.isFinalAnnotation) {
            adjFlags |= 131072 /* EvalFlags.NoClassVar */ | 16 /* EvalFlags.NoFinal */;
        }
        else if (options === null || options === void 0 ? void 0 : options.isClassVarAnnotation) {
            adjFlags |= 131072 /* EvalFlags.NoClassVar */;
            // If the annotation is a variable within the body of a dataclass, a
            // Final is allowed within the ClassVar annotation. In all other cases,
            // it's disallowed.
            let disallowFinal = true;
            const enclosingClassNode = ParseTreeUtils.getEnclosingClass(node, /* stopeAtFunction */ true);
            if (enclosingClassNode) {
                const classTypeInfo = getTypeOfClass(enclosingClassNode);
                if (classTypeInfo && types_1.ClassType.isDataClass(classTypeInfo.classType)) {
                    disallowFinal = false;
                }
            }
            if (disallowFinal) {
                adjFlags |= 16 /* EvalFlags.NoFinal */;
            }
        }
        else {
            adjFlags &= ~(2 /* EvalFlags.NoSpecialize */ |
                32 /* EvalFlags.NoParamSpec */ |
                64 /* EvalFlags.NoTypeVarTuple */ |
                1048576 /* EvalFlags.AllowRequired */ |
                16384 /* EvalFlags.EnforceVarianceConsistency */);
            if (!(options === null || options === void 0 ? void 0 : options.isAnnotatedClass)) {
                adjFlags |= 131072 /* EvalFlags.NoClassVar */ | 16 /* EvalFlags.NoFinal */;
            }
            adjFlags |= 2097152 /* EvalFlags.AllowUnpackedTuple */ | 134217728 /* EvalFlags.AllowConcatenate */;
        }
        // Create a local function that validates a single type argument.
        const getTypeArgTypeResult = (expr, argIndex) => {
            let typeResult;
            // If it's a custom __class_getitem__, none of the arguments should be
            // treated as types.
            if (options === null || options === void 0 ? void 0 : options.hasCustomClassGetItem) {
                adjFlags =
                    32 /* EvalFlags.NoParamSpec */ | 64 /* EvalFlags.NoTypeVarTuple */ | 2 /* EvalFlags.NoSpecialize */ | 131072 /* EvalFlags.NoClassVar */;
                typeResult = {
                    ...getTypeOfExpression(expr, adjFlags),
                    node: expr,
                };
            }
            else if ((options === null || options === void 0 ? void 0 : options.isAnnotatedClass) && argIndex > 0) {
                // If it's an Annotated[a, b, c], only the first index should be
                // treated as a type.The others can be regular(non - type) objects.
                adjFlags =
                    32 /* EvalFlags.NoParamSpec */ | 64 /* EvalFlags.NoTypeVarTuple */ | 2 /* EvalFlags.NoSpecialize */ | 131072 /* EvalFlags.NoClassVar */;
                if ((0, analyzerFileInfo_1.isAnnotationEvaluationPostponed)(AnalyzerNodeInfo.getFileInfo(node))) {
                    adjFlags |= 4 /* EvalFlags.ForwardRefs */;
                }
                typeResult = {
                    ...getTypeOfExpression(expr, adjFlags),
                    node: expr,
                };
            }
            else {
                typeResult = getTypeArg(expr, adjFlags);
            }
            return typeResult;
        };
        // A tuple is treated the same as a list of items in the index.
        if (node.items.length === 1 &&
            !node.trailingComma &&
            !node.items[0].name &&
            node.items[0].valueExpression.nodeType === 52 /* ParseNodeType.Tuple */) {
            node.items[0].valueExpression.expressions.forEach((item, index) => {
                typeArgs.push(getTypeArgTypeResult(item, index));
            });
            // Set the node's type so it isn't reevaluated later.
            setTypeResultForNode(node.items[0].valueExpression, { type: types_1.UnknownType.create() });
        }
        else {
            node.items.forEach((arg, index) => {
                const typeResult = getTypeArgTypeResult(arg.valueExpression, index);
                if (arg.argumentCategory !== 0 /* ArgumentCategory.Simple */) {
                    if (arg.argumentCategory === 1 /* ArgumentCategory.UnpackedList */) {
                        if (!(options === null || options === void 0 ? void 0 : options.isAnnotatedClass) || index === 0) {
                            if ((0, types_1.isVariadicTypeVar)(typeResult.type) && !typeResult.type.isVariadicUnpacked) {
                                typeResult.type = types_1.TypeVarType.cloneForUnpacked(typeResult.type);
                            }
                            else if ((0, types_1.isInstantiableClass)(typeResult.type) &&
                                !typeResult.type.includeSubclasses &&
                                (0, typeUtils_1.isTupleClass)(typeResult.type)) {
                                typeResult.type = types_1.ClassType.cloneForUnpacked(typeResult.type);
                            }
                            else {
                                addError(localize_1.LocMessage.unpackNotAllowed(), arg.valueExpression);
                            }
                        }
                    }
                }
                if (arg.name) {
                    addError(localize_1.LocMessage.keywordArgInTypeArgument(), arg.valueExpression);
                }
                if (arg.valueExpression.nodeType !== 0 /* ParseNodeType.Error */ ||
                    arg.valueExpression.category !== 3 /* ErrorExpressionCategory.MissingIndexOrSlice */) {
                    typeArgs.push(typeResult);
                }
            });
        }
        return typeArgs;
    }
    function getTypeArg(node, flags) {
        let typeResult;
        let adjustedFlags = flags | 128 /* EvalFlags.InstantiableType */ | 1 /* EvalFlags.ConvertEllipsisToAny */ | 8 /* EvalFlags.StrLiteralAsType */;
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        if (fileInfo.isStubFile) {
            adjustedFlags |= 4 /* EvalFlags.ForwardRefs */;
        }
        if (node.nodeType === 34 /* ParseNodeType.List */) {
            typeResult = {
                type: types_1.UnknownType.create(),
                typeList: node.entries.map((entry) => {
                    return { ...getTypeOfExpression(entry, adjustedFlags), node: entry };
                }),
                node,
            };
            // Set the node's type so it isn't reevaluated later.
            setTypeResultForNode(node, { type: types_1.UnknownType.create() });
        }
        else {
            typeResult = { ...getTypeOfExpression(node, adjustedFlags), node };
            if (node.nodeType === 18 /* ParseNodeType.Dictionary */) {
                addError(localize_1.LocMessage.dictInAnnotation(), node);
            }
            if ((flags & 131072 /* EvalFlags.NoClassVar */) !== 0) {
                // "ClassVar" is not allowed as a type argument.
                if ((0, types_1.isClass)(typeResult.type) && types_1.ClassType.isBuiltIn(typeResult.type, 'ClassVar')) {
                    addError(localize_1.LocMessage.classVarNotAllowed(), node);
                }
            }
        }
        return typeResult;
    }
    function getTypeOfTuple(node, flags, inferenceContext, signatureTracker) {
        var _a;
        if ((flags & 256 /* EvalFlags.TypeExpression */) !== 0 && ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.nodeType) !== 1 /* ParseNodeType.Argument */) {
            // This is allowed inside of an index trailer, specifically
            // to support Tuple[()], which is the documented way to annotate
            // a zero-length tuple.
            const diag = new diagnostic_1.DiagnosticAddendum();
            diag.addMessage(localize_1.LocAddendum.useTupleInstead());
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportInvalidTypeForm, localize_1.LocMessage.tupleInAnnotation() + diag.getString(), node);
            return { type: types_1.UnknownType.create() };
        }
        if ((flags & 128 /* EvalFlags.InstantiableType */) !== 0 && node.expressions.length === 0 && !inferenceContext) {
            return { type: makeTupleObject([]), isEmptyTupleShorthand: true };
        }
        flags &= ~(256 /* EvalFlags.TypeExpression */ | 8 /* EvalFlags.StrLiteralAsType */ | 128 /* EvalFlags.InstantiableType */);
        // If the expected type is a union, recursively call for each of the subtypes
        // to find one that matches.
        let expectedType = inferenceContext === null || inferenceContext === void 0 ? void 0 : inferenceContext.expectedType;
        let expectedTypeContainsAny = inferenceContext && (0, types_1.isAny)(inferenceContext.expectedType);
        if (inferenceContext && (0, types_1.isUnion)(inferenceContext.expectedType)) {
            let matchingSubtype;
            (0, typeUtils_1.doForEachSubtype)(inferenceContext.expectedType, (subtype) => {
                if ((0, types_1.isAny)(subtype)) {
                    expectedTypeContainsAny = true;
                }
                if (!matchingSubtype) {
                    const subtypeResult = useSpeculativeMode(node, () => {
                        return getTypeOfTupleWithContext(node, flags, (0, typeUtils_1.makeInferenceContext)(subtype), 
                        /* signatureTracker */ undefined);
                    });
                    if (subtypeResult && assignType(subtype, subtypeResult.type)) {
                        matchingSubtype = subtype;
                    }
                }
            }, 
            /* sortSubtypes */ true);
            expectedType = matchingSubtype;
        }
        let expectedTypeDiagAddendum;
        if (expectedType) {
            const result = getTypeOfTupleWithContext(node, flags, (0, typeUtils_1.makeInferenceContext)(expectedType), signatureTracker);
            if (result && !result.typeErrors) {
                return result;
            }
            expectedTypeDiagAddendum = result === null || result === void 0 ? void 0 : result.expectedTypeDiagAddendum;
        }
        const typeResult = getTypeOfTupleInferred(node, flags);
        // If there was an expected type of Any, replace the resulting type
        // with Any rather than return a type with unknowns.
        if (expectedTypeContainsAny) {
            typeResult.type = types_1.AnyType.create();
        }
        return { ...typeResult, expectedTypeDiagAddendum };
    }
    function getTypeOfTupleWithContext(node, flags, inferenceContext, signatureTracker) {
        inferenceContext.expectedType = (0, typeUtils_1.transformPossibleRecursiveTypeAlias)(inferenceContext.expectedType);
        if (!(0, types_1.isClassInstance)(inferenceContext.expectedType)) {
            return undefined;
        }
        if (!tupleClass || !(0, types_1.isInstantiableClass)(tupleClass)) {
            return undefined;
        }
        // Build an array of expected types.
        let expectedTypes = [];
        if ((0, typeUtils_1.isTupleClass)(inferenceContext.expectedType) && inferenceContext.expectedType.tupleTypeArguments) {
            expectedTypes = inferenceContext.expectedType.tupleTypeArguments.map((t) => (0, typeUtils_1.transformPossibleRecursiveTypeAlias)(t.type));
            const unboundedIndex = inferenceContext.expectedType.tupleTypeArguments.findIndex((t) => t.isUnbounded);
            if (unboundedIndex >= 0) {
                if (expectedTypes.length > node.expressions.length) {
                    expectedTypes.splice(unboundedIndex, 1);
                }
                else {
                    while (expectedTypes.length < node.expressions.length) {
                        expectedTypes.splice(unboundedIndex, 0, expectedTypes[unboundedIndex]);
                    }
                }
            }
        }
        else {
            const tupleTypeVarContext = new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(tupleClass));
            if (!(0, constraintSolver_1.addConstraintsForExpectedType)(evaluatorInterface, types_1.ClassType.cloneAsInstance(tupleClass), inferenceContext.expectedType, tupleTypeVarContext, ParseTreeUtils.getTypeVarScopesForNode(node), node.start)) {
                return undefined;
            }
            const specializedTuple = (0, typeUtils_1.applySolvedTypeVars)(tupleClass, tupleTypeVarContext);
            if (!specializedTuple.typeArguments || specializedTuple.typeArguments.length !== 1) {
                return undefined;
            }
            const homogenousType = (0, typeUtils_1.transformPossibleRecursiveTypeAlias)(specializedTuple.typeArguments[0]);
            for (let i = 0; i < node.expressions.length; i++) {
                expectedTypes.push(homogenousType);
            }
        }
        const entryTypeResults = node.expressions.map((expr, index) => getTypeOfExpression(expr, flags | 268435456 /* EvalFlags.StripTupleLiterals */, (0, typeUtils_1.makeInferenceContext)(index < expectedTypes.length ? expectedTypes[index] : undefined, inferenceContext.isTypeIncomplete), signatureTracker));
        const isIncomplete = entryTypeResults.some((result) => result.isIncomplete);
        const type = makeTupleObject(buildTupleTypesList(entryTypeResults, /* stripLiterals */ false));
        // Copy any expected type diag addenda for precision error reporting.
        let expectedTypeDiagAddendum;
        if (entryTypeResults.some((result) => result.expectedTypeDiagAddendum)) {
            expectedTypeDiagAddendum = new diagnostic_1.DiagnosticAddendum();
            entryTypeResults.forEach((result) => {
                if (result.expectedTypeDiagAddendum) {
                    expectedTypeDiagAddendum.addAddendum(result.expectedTypeDiagAddendum);
                }
            });
        }
        return { type, expectedTypeDiagAddendum, isIncomplete };
    }
    function getTypeOfTupleInferred(node, flags) {
        const entryTypeResults = node.expressions.map((expr) => getTypeOfExpression(expr, flags | 268435456 /* EvalFlags.StripTupleLiterals */));
        const isIncomplete = entryTypeResults.some((result) => result.isIncomplete);
        const type = makeTupleObject(buildTupleTypesList(entryTypeResults, (flags & 268435456 /* EvalFlags.StripTupleLiterals */) !== 0));
        if (isIncomplete) {
            if ((0, typeUtils_1.getContainerDepth)(type) > maxInferredContainerDepth) {
                return { type: types_1.UnknownType.create() };
            }
        }
        return { type, isIncomplete };
    }
    function buildTupleTypesList(entryTypeResults, stripLiterals) {
        const entryTypes = [];
        for (const typeResult of entryTypeResults) {
            let possibleUnpackedTuple;
            if (typeResult.unpackedType) {
                possibleUnpackedTuple = typeResult.unpackedType;
            }
            else if ((0, types_1.isUnpacked)(typeResult.type)) {
                possibleUnpackedTuple = typeResult.type;
            }
            // Is this an unpacked tuple? If so, we can append the individual
            // unpacked entries onto the new tuple. If it's not an upacked tuple
            // but some other iterator (e.g. a List), we won't know the number of
            // items, so we'll need to leave the Tuple open-ended.
            if (possibleUnpackedTuple &&
                (0, types_1.isClassInstance)(possibleUnpackedTuple) &&
                possibleUnpackedTuple.tupleTypeArguments) {
                const typeArgs = possibleUnpackedTuple.tupleTypeArguments;
                if (!typeArgs) {
                    entryTypes.push({ type: types_1.UnknownType.create(), isUnbounded: true });
                }
                else {
                    (0, collectionUtils_1.appendArray)(entryTypes, typeArgs);
                }
            }
            else if ((0, types_1.isNever)(typeResult.type) && typeResult.isIncomplete && !typeResult.unpackedType) {
                entryTypes.push({ type: types_1.UnknownType.create(/* isIncomplete */ true), isUnbounded: false });
            }
            else {
                const entryType = stripLiterals ? stripLiteralValue(typeResult.type) : typeResult.type;
                entryTypes.push({ type: entryType, isUnbounded: !!typeResult.unpackedType });
            }
        }
        // If there are multiple unbounded entries, combine all of them into a single
        // unbounded entry to avoid violating the invariant that there can be at most
        // one unbounded entry in a tuple.
        if (entryTypes.filter((t) => t.isUnbounded).length > 1) {
            const firstUnboundedEntryIndex = entryTypes.findIndex((t) => t.isUnbounded);
            const removedEntries = entryTypes.splice(firstUnboundedEntryIndex);
            entryTypes.push({ type: (0, types_1.combineTypes)(removedEntries.map((t) => t.type)), isUnbounded: true });
        }
        return entryTypes;
    }
    function getTypeOfCall(node, flags, inferenceContext, signatureTracker) {
        var _a;
        let baseTypeResult;
        // Check for the use of `type(x)` within a type annotation. This isn't
        // allowed, and it's a common mistake, so we want to emit a diagnostic
        // that guides the user to the right solution.
        if ((flags & 256 /* EvalFlags.TypeExpression */) !== 0 &&
            node.leftExpression.nodeType === 38 /* ParseNodeType.Name */ &&
            node.leftExpression.value === 'type') {
            const diag = new diagnostic_1.DiagnosticAddendum();
            diag.addMessage(localize_1.LocAddendum.useTypeInstead());
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportInvalidTypeForm, localize_1.LocMessage.typeCallNotAllowed() + diag.getString(), node);
        }
        // Handle immediate calls of lambdas specially.
        if (node.leftExpression.nodeType === 33 /* ParseNodeType.Lambda */) {
            baseTypeResult = getTypeOfLambdaForCall(node, inferenceContext);
        }
        else {
            baseTypeResult = getTypeOfExpression(node.leftExpression, 2 /* EvalFlags.CallBaseDefaults */ | (flags & 4 /* EvalFlags.ForwardRefs */));
        }
        const argList = ParseTreeUtils.getArgumentsByRuntimeOrder(node).map((arg) => {
            const functionArg = {
                valueExpression: arg.valueExpression,
                argumentCategory: arg.argumentCategory,
                node: arg,
                name: arg.name,
            };
            return functionArg;
        });
        let typeResult = { type: types_1.UnknownType.create() };
        // If the inference context has an associated signature tracker, make sure
        // the base type of this call is not the same as one of the tracked signatures.
        // This is important for nested generic calls (e.g. "foo(foo(x))").
        if (signatureTracker) {
            baseTypeResult.type = (0, typeUtils_1.ensureFunctionSignaturesAreUnique)(baseTypeResult.type, signatureTracker, node.start);
        }
        if (!(0, typeUtils_1.isTypeAliasPlaceholder)(baseTypeResult.type)) {
            if (node.leftExpression.nodeType === 38 /* ParseNodeType.Name */ && node.leftExpression.value === 'super') {
                // Handle the built-in "super" call specially.
                typeResult = getTypeOfSuperCall(node);
            }
            else if ((0, types_1.isAnyOrUnknown)(baseTypeResult.type) &&
                node.leftExpression.nodeType === 38 /* ParseNodeType.Name */ &&
                node.leftExpression.value === 'reveal_type') {
                // Handle the implicit "reveal_type" call.
                typeResult = getTypeOfRevealType(node, inferenceContext, signatureTracker);
            }
            else if ((0, types_1.isFunction)(baseTypeResult.type) && baseTypeResult.type.details.builtInName === 'reveal_type') {
                // Handle the "typing.reveal_type" call.
                typeResult = getTypeOfRevealType(node, inferenceContext, signatureTracker);
            }
            else if ((0, types_1.isFunction)(baseTypeResult.type) && baseTypeResult.type.details.builtInName === 'assert_type') {
                // Handle the "typing.assert_type" call.
                typeResult = getTypeOfAssertType(node, inferenceContext, signatureTracker);
            }
            else if ((0, types_1.isAnyOrUnknown)(baseTypeResult.type) &&
                node.leftExpression.nodeType === 38 /* ParseNodeType.Name */ &&
                node.leftExpression.value === 'reveal_locals') {
                if (node.arguments.length === 0) {
                    // Handle the special-case "reveal_locals" call.
                    typeResult.type = getTypeOfRevealLocals(node);
                }
                else {
                    addError(localize_1.LocMessage.revealLocalsArgs(), node);
                }
            }
            else {
                const callResult = validateCallArguments(node, argList, baseTypeResult, 
                /* typeVarContext */ undefined, 
                /* skipUnknownArgCheck */ false, inferenceContext, signatureTracker);
                typeResult.type = (_a = callResult.returnType) !== null && _a !== void 0 ? _a : types_1.UnknownType.create();
                if (callResult.argumentErrors) {
                    typeResult.typeErrors = true;
                }
                else {
                    typeResult.overloadsUsedForCall = callResult.overloadsUsedForCall;
                }
                if (callResult.isTypeIncomplete) {
                    typeResult.isIncomplete = true;
                }
            }
            if (baseTypeResult.isIncomplete) {
                typeResult.isIncomplete = true;
            }
        }
        else {
            typeResult.isIncomplete = true;
        }
        // Don't bother evaluating the arguments if we're speculatively evaluating the call
        // or the base type is incomplete.
        if (!isSpeculativeModeInUse(node) && !baseTypeResult.isIncomplete) {
            // Touch all of the args so they're marked accessed even if there were errors.
            // We skip this if it's a TypeVar() call in the typing.pyi module because
            // this results in a cyclical type resolution problem whereby we try to
            // retrieve the str class, which inherits from Sequence, which inherits from
            // Iterable, which uses a TypeVar. Without this, Iterable and Sequence classes
            // have invalid type parameters.
            const isCyclicalTypeVarCall = (0, types_1.isInstantiableClass)(baseTypeResult.type) &&
                types_1.ClassType.isBuiltIn(baseTypeResult.type, 'TypeVar') &&
                AnalyzerNodeInfo.getFileInfo(node).isTypingStubFile;
            if (!isCyclicalTypeVarCall) {
                argList.forEach((arg) => {
                    if (arg.valueExpression &&
                        arg.valueExpression.nodeType !== 48 /* ParseNodeType.StringList */ &&
                        !isTypeCached(arg.valueExpression)) {
                        getTypeOfExpression(arg.valueExpression);
                    }
                });
            }
        }
        if ((flags & 256 /* EvalFlags.TypeExpression */) !== 0) {
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportInvalidTypeForm, localize_1.LocMessage.typeAnnotationCall(), node);
            typeResult = { type: types_1.UnknownType.create() };
        }
        return typeResult;
    }
    // This function is used in cases where a lambda is defined and immediately
    // called. In this case, we can't use normal bidirectional type inference
    // to determine the lambda's type. It needs to be inferred from the argument
    // types instead.
    function getTypeOfLambdaForCall(node, inferenceContext) {
        (0, debug_1.assert)(node.leftExpression.nodeType === 33 /* ParseNodeType.Lambda */);
        const expectedType = types_1.FunctionType.createSynthesizedInstance('');
        expectedType.details.declaredReturnType = inferenceContext
            ? inferenceContext.expectedType
            : types_1.UnknownType.create();
        let isArgTypeIncomplete = false;
        node.arguments.forEach((arg, index) => {
            const argTypeResult = getTypeOfExpression(arg.valueExpression);
            if (argTypeResult.isIncomplete) {
                isArgTypeIncomplete = true;
            }
            types_1.FunctionType.addParameter(expectedType, {
                category: 0 /* ParameterCategory.Simple */,
                name: `p${index.toString()}`,
                type: argTypeResult.type,
                hasDeclaredType: true,
            });
        });
        // If the lambda's param list ends with a "/" positional parameter separator,
        // add a corresponding separator to the expected type.
        const lambdaParams = node.leftExpression.parameters;
        if (lambdaParams.length > 0) {
            const lastParam = lambdaParams[lambdaParams.length - 1];
            if (lastParam.category === 0 /* ParameterCategory.Simple */ && !lastParam.name) {
                types_1.FunctionType.addPositionOnlyParameterSeparator(expectedType);
            }
        }
        function getLambdaType() {
            return getTypeOfExpression(node.leftExpression, 2 /* EvalFlags.CallBaseDefaults */, (0, typeUtils_1.makeInferenceContext)(expectedType));
        }
        // If one or more of the arguments are incomplete, use speculative mode
        // for the lambda evaluation because it may need to be reevaluated once
        // the arg types are complete.
        let typeResult = isArgTypeIncomplete || isSpeculativeModeInUse(node) || (inferenceContext === null || inferenceContext === void 0 ? void 0 : inferenceContext.isTypeIncomplete)
            ? useSpeculativeMode(node.leftExpression, getLambdaType)
            : getLambdaType();
        // If bidirectional type inference failed, use normal type inference instead.
        if (typeResult.typeErrors) {
            typeResult = getTypeOfExpression(node.leftExpression, 2 /* EvalFlags.CallBaseDefaults */);
        }
        return typeResult;
    }
    function getTypeOfAssertType(node, inferenceContext, signatureTracker) {
        if (node.arguments.length !== 2 ||
            node.arguments[0].argumentCategory !== 0 /* ArgumentCategory.Simple */ ||
            node.arguments[0].name !== undefined ||
            node.arguments[0].argumentCategory !== 0 /* ArgumentCategory.Simple */ ||
            node.arguments[1].name !== undefined) {
            addError(localize_1.LocMessage.assertTypeArgs(), node);
            return { type: types_1.UnknownType.create() };
        }
        const arg0TypeResult = getTypeOfExpression(node.arguments[0].valueExpression, 
        /* flags */ undefined, inferenceContext, signatureTracker);
        if (arg0TypeResult.isIncomplete) {
            return { type: types_1.UnknownType.create(/* isIncomplete */ true), isIncomplete: true };
        }
        const assertedType = (0, typeUtils_1.convertToInstance)(getTypeOfArgumentExpectingType(node.arguments[1]).type);
        if (!(0, types_1.isTypeSame)(assertedType, arg0TypeResult.type, { treatAnySameAsUnknown: true, ignorePseudoGeneric: true })) {
            const srcDestTypes = printSrcDestTypes(arg0TypeResult.type, assertedType, { expandTypeAlias: true });
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportAssertTypeFailure, localize_1.LocMessage.assertTypeTypeMismatch().format({
                expected: srcDestTypes.destType,
                received: srcDestTypes.sourceType,
            }), node.arguments[0].valueExpression);
        }
        return { type: arg0TypeResult.type };
    }
    function getTypeOfRevealType(node, inferenceContext, signatureTracker) {
        let arg0Value;
        let expectedRevealTypeNode;
        let expectedRevealType;
        let expectedTextNode;
        let expectedText;
        // Make sure there is only one positional argument passed as arg 0.
        node.arguments.forEach((arg, index) => {
            if (index === 0) {
                if (arg.argumentCategory === 0 /* ArgumentCategory.Simple */ && !arg.name) {
                    arg0Value = arg.valueExpression;
                }
            }
            else if (arg.argumentCategory !== 0 /* ArgumentCategory.Simple */ || !arg.name) {
                arg0Value = undefined;
            }
            else if (arg.name.value === 'expected_text') {
                expectedTextNode = arg.valueExpression;
                const expectedTextType = getTypeOfExpression(arg.valueExpression).type;
                if (!(0, types_1.isClassInstance)(expectedTextType) ||
                    !types_1.ClassType.isBuiltIn(expectedTextType, 'str') ||
                    typeof expectedTextType.literalValue !== 'string') {
                    addError(localize_1.LocMessage.revealTypeExpectedTextArg(), arg.valueExpression);
                }
                else {
                    expectedText = expectedTextType.literalValue;
                }
            }
            else if (arg.name.value === 'expected_type') {
                expectedRevealTypeNode = arg.valueExpression;
                expectedRevealType = (0, typeUtils_1.convertToInstance)(getTypeOfArgumentExpectingType(arg).type);
            }
        });
        if (!arg0Value) {
            addError(localize_1.LocMessage.revealTypeArgs(), node);
            return { type: types_1.UnknownType.create() };
        }
        const typeResult = getTypeOfExpression(arg0Value, /* flags */ undefined, inferenceContext, signatureTracker);
        const type = typeResult.type;
        const exprString = ParseTreeUtils.printExpression(arg0Value);
        const typeString = printType(type, { expandTypeAlias: true });
        if (!typeResult.isIncomplete) {
            if (expectedText !== undefined) {
                if (expectedText !== typeString) {
                    addError(localize_1.LocMessage.revealTypeExpectedTextMismatch().format({
                        expected: expectedText,
                        received: typeString,
                    }), expectedTextNode !== null && expectedTextNode !== void 0 ? expectedTextNode : arg0Value);
                }
            }
            if (expectedRevealType) {
                if (!(0, types_1.isTypeSame)(expectedRevealType, type, { ignorePseudoGeneric: true })) {
                    const expectedRevealTypeText = printType(expectedRevealType);
                    addError(localize_1.LocMessage.revealTypeExpectedTypeMismatch().format({
                        expected: expectedRevealTypeText,
                        received: typeString,
                    }), expectedRevealTypeNode !== null && expectedRevealTypeNode !== void 0 ? expectedRevealTypeNode : arg0Value);
                }
            }
            addInformation(localize_1.LocAddendum.typeOfSymbol().format({ name: exprString, type: typeString }), node.arguments[0]);
        }
        return { type, isIncomplete: typeResult.isIncomplete };
    }
    function getTypeOfRevealLocals(node) {
        let curNode = node;
        let scope;
        while (curNode) {
            scope = ScopeUtils.getScopeForNode(curNode);
            // Stop when we get a valid scope that's not a list comprehension
            // scope. That includes lambdas, functions, classes, and modules.
            if (scope && scope.type !== 1 /* ScopeType.Comprehension */) {
                break;
            }
            curNode = curNode.parent;
        }
        const infoMessages = [];
        if (scope) {
            scope.symbolTable.forEach((symbol, name) => {
                if (!symbol.isIgnoredForProtocolMatch()) {
                    const typeOfSymbol = getEffectiveTypeOfSymbol(symbol);
                    infoMessages.push(localize_1.LocAddendum.typeOfSymbol().format({
                        name,
                        type: printType(typeOfSymbol, { expandTypeAlias: true }),
                    }));
                }
            });
        }
        if (infoMessages.length > 0) {
            addInformation(infoMessages.join('\n'), node);
        }
        else {
            addInformation(localize_1.LocMessage.revealLocalsNone(), node);
        }
        return getNoneType();
    }
    function getTypeOfSuperCall(node) {
        var _a;
        if (node.arguments.length > 2) {
            addError(localize_1.LocMessage.superCallArgCount(), node.arguments[2]);
        }
        const enclosingFunction = ParseTreeUtils.getEnclosingFunctionEvaluationScope(node);
        const enclosingClass = enclosingFunction ? ParseTreeUtils.getEnclosingClass(enclosingFunction) : undefined;
        const enclosingClassType = enclosingClass ? (_a = getTypeOfClass(enclosingClass)) === null || _a === void 0 ? void 0 : _a.classType : undefined;
        // Determine which class the "super" call is applied to. If
        // there is no first argument, then the class is implicit.
        let targetClassType;
        if (node.arguments.length > 0) {
            targetClassType = getTypeOfExpression(node.arguments[0].valueExpression).type;
            const concreteTargetClassType = makeTopLevelTypeVarsConcrete(targetClassType);
            if (!(0, types_1.isAnyOrUnknown)(concreteTargetClassType) &&
                !(0, types_1.isInstantiableClass)(concreteTargetClassType) &&
                !(0, typeUtils_1.isMetaclassInstance)(concreteTargetClassType)) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportArgumentType, localize_1.LocMessage.superCallFirstArg().format({ type: printType(targetClassType) }), node.arguments[0].valueExpression);
            }
        }
        else {
            if (enclosingClassType) {
                targetClassType = enclosingClassType !== null && enclosingClassType !== void 0 ? enclosingClassType : types_1.UnknownType.create();
                // Zero-argument forms of super are not allowed within static methods.
                // This results in a runtime exception.
                if (enclosingFunction) {
                    const functionInfo = (0, decorators_1.getFunctionInfoFromDecorators)(evaluatorInterface, enclosingFunction, 
                    /* isInClass */ true);
                    if (((functionInfo === null || functionInfo === void 0 ? void 0 : functionInfo.flags) & 4 /* FunctionTypeFlags.StaticMethod */) !== 0) {
                        addError(localize_1.LocMessage.superCallZeroArgFormStaticMethod(), node.leftExpression);
                    }
                }
            }
            else {
                addError(localize_1.LocMessage.superCallZeroArgForm(), node.leftExpression);
                targetClassType = types_1.UnknownType.create();
            }
        }
        const concreteTargetClassType = makeTopLevelTypeVarsConcrete(targetClassType);
        // Determine whether to further narrow the type.
        let bindToType;
        if (node.arguments.length > 1) {
            const secondArgType = makeTopLevelTypeVarsConcrete(getTypeOfExpression(node.arguments[1].valueExpression).type);
            let reportError = false;
            if ((0, types_1.isAnyOrUnknown)(secondArgType)) {
                // Ignore unknown or any types.
            }
            else if ((0, types_1.isClassInstance)(secondArgType)) {
                if ((0, types_1.isInstantiableClass)(concreteTargetClassType)) {
                    if (!(0, typeUtils_1.derivesFromClassRecursive)(types_1.ClassType.cloneAsInstantiable(secondArgType), concreteTargetClassType, 
                    /* ignoreUnknown */ true)) {
                        reportError = true;
                    }
                }
                bindToType = secondArgType;
            }
            else if ((0, types_1.isInstantiableClass)(secondArgType)) {
                if ((0, types_1.isInstantiableClass)(concreteTargetClassType)) {
                    if (!types_1.ClassType.isBuiltIn(concreteTargetClassType, 'type') &&
                        !(0, typeUtils_1.derivesFromClassRecursive)(secondArgType, concreteTargetClassType, /* ignoreUnknown */ true)) {
                        reportError = true;
                    }
                }
                bindToType = secondArgType;
            }
            else {
                reportError = true;
            }
            if (reportError) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportArgumentType, localize_1.LocMessage.superCallSecondArg().format({ type: printType(targetClassType) }), node.arguments[1].valueExpression);
                return { type: types_1.UnknownType.create() };
            }
        }
        else if (enclosingClassType) {
            bindToType = types_1.ClassType.cloneAsInstance(enclosingClassType);
            // Get the type from the self or cls parameter if it is explicitly annotated.
            // If it's a TypeVar, change the bindToType into a conditional type.
            const enclosingMethod = ParseTreeUtils.getEnclosingFunction(node);
            let implicitBindToType;
            if (enclosingMethod) {
                const methodTypeInfo = getTypeOfFunction(enclosingMethod);
                if (methodTypeInfo) {
                    const methodType = methodTypeInfo.functionType;
                    if (types_1.FunctionType.isClassMethod(methodType) ||
                        types_1.FunctionType.isConstructorMethod(methodType) ||
                        types_1.FunctionType.isInstanceMethod(methodType)) {
                        if (methodType.details.parameters.length > 0 &&
                            methodType.details.parameters[0].hasDeclaredType) {
                            implicitBindToType = makeTopLevelTypeVarsConcrete(methodType.details.parameters[0].type);
                        }
                    }
                }
            }
            if (bindToType && implicitBindToType) {
                const typeCondition = (0, typeUtils_1.getTypeCondition)(implicitBindToType);
                if (typeCondition) {
                    bindToType = (0, typeUtils_1.addConditionToType)(bindToType, typeCondition);
                }
                else if ((0, types_1.isClass)(implicitBindToType)) {
                    bindToType = implicitBindToType;
                }
            }
        }
        // Determine whether super() should return an instance of the class or
        // the class itself. It depends on whether the super() call is located
        // within an instance method or not.
        let resultIsInstance = true;
        if (node.arguments.length <= 1) {
            const enclosingMethod = ParseTreeUtils.getEnclosingFunction(node);
            if (enclosingMethod) {
                const methodType = getTypeOfFunction(enclosingMethod);
                if (methodType) {
                    if (types_1.FunctionType.isStaticMethod(methodType.functionType) ||
                        types_1.FunctionType.isConstructorMethod(methodType.functionType) ||
                        types_1.FunctionType.isClassMethod(methodType.functionType)) {
                        resultIsInstance = false;
                    }
                }
            }
        }
        // Python docs indicate that super() isn't valid for
        // operations other than member accesses or attribute lookups.
        const parentNode = node.parent;
        if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.nodeType) === 35 /* ParseNodeType.MemberAccess */) {
            const memberName = parentNode.memberName.value;
            let effectiveTargetClass = (0, types_1.isClass)(concreteTargetClassType) ? concreteTargetClassType : undefined;
            // If the bind-to type is a protocol, don't use the effective target class.
            // This pattern is used for mixins, where the mixin type is a protocol class
            // that is used to decorate the "self" or "cls" parameter.
            let isProtocolClass = false;
            if (bindToType &&
                types_1.ClassType.isProtocolClass(bindToType) &&
                effectiveTargetClass &&
                !types_1.ClassType.isSameGenericClass(bindToType, effectiveTargetClass)) {
                isProtocolClass = true;
                effectiveTargetClass = undefined;
            }
            const lookupResults = bindToType
                ? (0, typeUtils_1.lookUpClassMember)(bindToType, memberName, 0 /* MemberAccessFlags.Default */, effectiveTargetClass)
                : undefined;
            let resultType;
            if (lookupResults && (0, types_1.isInstantiableClass)(lookupResults.classType)) {
                resultType = lookupResults.classType;
                if (isProtocolClass) {
                    // If the bindToType is a protocol class, set the "include subclasses" flag
                    // so we don't enforce that called methods are implemented within the protocol.
                    resultType = types_1.ClassType.cloneIncludeSubclasses(resultType);
                }
            }
            else if (effectiveTargetClass &&
                !(0, types_1.isAnyOrUnknown)(effectiveTargetClass) &&
                !(0, typeUtils_1.derivesFromAnyOrUnknown)(effectiveTargetClass)) {
                resultType = objectClass !== null && objectClass !== void 0 ? objectClass : types_1.UnknownType.create();
            }
            else {
                resultType = types_1.UnknownType.create();
            }
            return {
                type: resultIsInstance ? (0, typeUtils_1.convertToInstance)(resultType, /* includeSubclasses */ false) : resultType,
                bindToSelfType: bindToType
                    ? types_1.TypeBase.cloneForCondition((0, typeUtils_1.synthesizeTypeVarForSelfCls)(types_1.ClassType.cloneIncludeSubclasses(bindToType, /* includeSubclasses */ false), 
                    /* isClsParam */ false), bindToType.condition)
                    : undefined,
            };
        }
        // Handle the super() call when used outside of a member access expression.
        if ((0, types_1.isInstantiableClass)(concreteTargetClassType)) {
            // We don't know which member is going to be accessed, so we cannot
            // deterministically determine the correct type in this case. We'll
            // use a heuristic that produces the "correct" (desired) behavior in
            // most cases. If there's a bindToType and the targetClassType is one
            // of the base classes of the bindToType, we'll return the next base
            // class.
            if (bindToType) {
                let nextBaseClassType;
                if (types_1.ClassType.isSameGenericClass(bindToType, concreteTargetClassType)) {
                    if (bindToType.details.baseClasses.length > 0) {
                        nextBaseClassType = bindToType.details.baseClasses[0];
                    }
                }
                else {
                    const baseClassIndex = bindToType.details.baseClasses.findIndex((baseClass) => (0, types_1.isClass)(baseClass) &&
                        types_1.ClassType.isSameGenericClass(baseClass, concreteTargetClassType));
                    if (baseClassIndex >= 0 && baseClassIndex < bindToType.details.baseClasses.length - 1) {
                        nextBaseClassType = bindToType.details.baseClasses[baseClassIndex + 1];
                    }
                }
                if (nextBaseClassType) {
                    if ((0, types_1.isInstantiableClass)(nextBaseClassType)) {
                        nextBaseClassType = (0, typeUtils_1.specializeForBaseClass)(bindToType, nextBaseClassType);
                    }
                    return { type: resultIsInstance ? (0, typeUtils_1.convertToInstance)(nextBaseClassType) : nextBaseClassType };
                }
                // There's not much we can say about the type. Simply return object or type.
                if (typeClass && (0, types_1.isInstantiableClass)(typeClass)) {
                    return {
                        type: resultIsInstance ? getObjectType() : (0, typeUtils_1.convertToInstance)(typeClass),
                    };
                }
            }
            else {
                // If the class derives from one or more unknown classes,
                // return unknown here to prevent spurious errors.
                if (concreteTargetClassType.details.mro.some((mroBase) => (0, types_1.isAnyOrUnknown)(mroBase))) {
                    return { type: types_1.UnknownType.create() };
                }
                const baseClasses = concreteTargetClassType.details.baseClasses;
                if (baseClasses.length > 0) {
                    const baseClassType = baseClasses[0];
                    if ((0, types_1.isInstantiableClass)(baseClassType)) {
                        return {
                            type: resultIsInstance ? types_1.ClassType.cloneAsInstance(baseClassType) : baseClassType,
                        };
                    }
                }
            }
        }
        return { type: types_1.UnknownType.create() };
    }
    // Attempts to find an overloaded function for each set of argument
    // types in the expandedArgTypes list. If an argument type is undefined,
    // its type is evaluated from the argument's expression using the
    // corresponding parameter's expected type. The first time this is called,
    // there will be only one argument list in expandedArgTypes, and all entries
    // (one for each argument) will be undefined. On subsequent calls, this
    // list will grow to include union expansions.
    function validateOverloadsWithExpandedTypes(errorNode, expandedArgTypes, argParamMatches, typeVarContext, skipUnknownArgCheck, inferenceContext, signatureTracker) {
        var _a, _b;
        const returnTypes = [];
        const matchedOverloads = [];
        let isTypeIncomplete = false;
        let overloadsUsedForCall = [];
        let isDefinitiveMatchFound = false;
        for (let expandedTypesIndex = 0; expandedTypesIndex < expandedArgTypes.length; expandedTypesIndex++) {
            let matchedOverload;
            const argTypeOverride = expandedArgTypes[expandedTypesIndex];
            const hasArgTypeOverride = argTypeOverride.some((a) => a !== undefined);
            let possibleMatchResults = [];
            let possibleMatchInvolvesIncompleteUnknown = false;
            isDefinitiveMatchFound = false;
            for (let overloadIndex = 0; overloadIndex < argParamMatches.length; overloadIndex++) {
                const overload = argParamMatches[overloadIndex].overload;
                let matchResults = argParamMatches[overloadIndex];
                if (hasArgTypeOverride) {
                    matchResults = { ...argParamMatches[overloadIndex] };
                    matchResults.argParams = matchResults.argParams.map((argParam, argIndex) => {
                        if (!argTypeOverride[argIndex]) {
                            return argParam;
                        }
                        const argParamCopy = { ...argParam };
                        argParamCopy.argType = argTypeOverride[argIndex];
                        return argParamCopy;
                    });
                }
                // Clone the typeVarContext so we don't modify the original.
                const effectiveTypeVarContext = (_a = typeVarContext === null || typeVarContext === void 0 ? void 0 : typeVarContext.clone()) !== null && _a !== void 0 ? _a : new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(overload));
                effectiveTypeVarContext.addSolveForScope((0, typeUtils_1.getTypeVarScopeIds)(overload));
                effectiveTypeVarContext.unlock();
                // Use speculative mode so we don't output any diagnostics or
                // record any final types in the type cache.
                const callResult = useSpeculativeMode(errorNode, () => {
                    return validateArgTypesWithContext(errorNode, matchResults, effectiveTypeVarContext, 
                    /* skipUnknownArgCheck */ true, inferenceContext, signatureTracker);
                });
                if (callResult.isTypeIncomplete) {
                    isTypeIncomplete = true;
                }
                if (!callResult.argumentErrors && callResult.returnType) {
                    overloadsUsedForCall.push(overload);
                    matchedOverload = overload;
                    const matchedOverloadInfo = {
                        overload: matchedOverload,
                        matchResults,
                        typeVarContext: effectiveTypeVarContext,
                        returnType: callResult.returnType,
                        argResults: (_b = callResult.argResults) !== null && _b !== void 0 ? _b : [],
                    };
                    matchedOverloads.push(matchedOverloadInfo);
                    if (callResult.anyOrUnknownArgument) {
                        possibleMatchResults.push(matchedOverloadInfo);
                        if ((0, typeUtils_1.isIncompleteUnknown)(callResult.anyOrUnknownArgument)) {
                            possibleMatchInvolvesIncompleteUnknown = true;
                        }
                    }
                    else {
                        returnTypes.push(callResult.returnType);
                        isDefinitiveMatchFound = true;
                        break;
                    }
                }
            }
            // If we didn't find a definitive match that doesn't depend on
            // an Any or Unknown argument, fall back on the possible match.
            // If there were multiple possible matches, evaluate the type as
            // Unknown, but include the "possible types" to allow for completion
            // suggestions.
            if (!isDefinitiveMatchFound && possibleMatchResults.length > 0) {
                possibleMatchResults = filterOverloadMatchesForAnyArgs(possibleMatchResults);
                // Did the filtering produce a single result? If so, we're done.
                if (possibleMatchResults.length === 1) {
                    overloadsUsedForCall = [possibleMatchResults[0].overload];
                    returnTypes.push(possibleMatchResults[0].returnType);
                }
                else {
                    // Eliminate any return types that are subsumed by other return types.
                    let dedupedMatchResults = [];
                    let dedupedResultsIncludeAny = false;
                    possibleMatchResults.forEach((result) => {
                        let isSubtypeSubsumed = false;
                        for (let dedupedIndex = 0; dedupedIndex < dedupedMatchResults.length; dedupedIndex++) {
                            if (assignType(dedupedMatchResults[dedupedIndex], result.returnType)) {
                                const anyOrUnknown = (0, typeUtils_1.containsAnyOrUnknown)(dedupedMatchResults[dedupedIndex], 
                                /* recurse */ false);
                                if (!anyOrUnknown) {
                                    isSubtypeSubsumed = true;
                                }
                                else if ((0, types_1.isAny)(anyOrUnknown)) {
                                    dedupedResultsIncludeAny = true;
                                }
                                break;
                            }
                            else if (assignType(result.returnType, dedupedMatchResults[dedupedIndex])) {
                                const anyOrUnknown = (0, typeUtils_1.containsAnyOrUnknown)(result.returnType, /* recurse */ false);
                                if (!anyOrUnknown) {
                                    dedupedMatchResults[dedupedIndex] = types_1.NeverType.createNever();
                                }
                                else if ((0, types_1.isAny)(anyOrUnknown)) {
                                    dedupedResultsIncludeAny = true;
                                }
                                break;
                            }
                        }
                        if (!isSubtypeSubsumed) {
                            dedupedMatchResults.push(result.returnType);
                        }
                    });
                    dedupedMatchResults = dedupedMatchResults.filter((t) => !(0, types_1.isNever)(t));
                    const combinedTypes = (0, types_1.combineTypes)(dedupedMatchResults);
                    let returnType = combinedTypes;
                    if (dedupedMatchResults.length > 1) {
                        // If one or more of the deduped types is Any or contains Any,
                        // we will assume that the person who defined the overload really
                        // wanted Any rather than Unknown. In cases where the deduped types
                        // simply contains conflicting results without an Any, we'll use
                        // an UnknownType.
                        if (dedupedResultsIncludeAny) {
                            returnType = types_1.AnyType.create();
                        }
                        else {
                            returnType = types_1.UnknownType.createPossibleType(combinedTypes, possibleMatchInvolvesIncompleteUnknown);
                        }
                    }
                    returnTypes.push(returnType);
                }
            }
            if (!matchedOverload) {
                return { argumentErrors: true, isTypeIncomplete, overloadsUsedForCall };
            }
        }
        // We found a match for all of the expanded argument lists. Copy the
        // resulting type var context back into the caller's type var context.
        // Use the type var context from the last matched overload because it
        // includes the type var solutions for all earlier matched overloads.
        if (typeVarContext && isDefinitiveMatchFound) {
            typeVarContext.copyFromClone(matchedOverloads[matchedOverloads.length - 1].typeVarContext);
        }
        // And run through the first expanded argument list one more time to
        // populate the type cache.
        const finalTypeVarContext = typeVarContext !== null && typeVarContext !== void 0 ? typeVarContext : matchedOverloads[0].typeVarContext;
        finalTypeVarContext.unlock();
        finalTypeVarContext.addSolveForScope((0, typeUtils_1.getTypeVarScopeId)(matchedOverloads[0].overload));
        const finalCallResult = validateArgTypesWithContext(errorNode, matchedOverloads[0].matchResults, finalTypeVarContext, skipUnknownArgCheck, inferenceContext, signatureTracker);
        if (finalCallResult.isTypeIncomplete) {
            isTypeIncomplete = true;
        }
        return {
            argumentErrors: finalCallResult.argumentErrors,
            anyOrUnknownArgument: finalCallResult.anyOrUnknownArgument,
            returnType: (0, types_1.combineTypes)(returnTypes),
            isTypeIncomplete,
            specializedInitSelfType: finalCallResult.specializedInitSelfType,
            overloadsUsedForCall,
        };
    }
    // This function determines whether multiple incompatible overloads match
    // due to an Any or Unknown argument type.
    function filterOverloadMatchesForAnyArgs(matches) {
        if (matches.length < 2) {
            return matches;
        }
        // If the relevance of some matches differs, filter out the ones that
        // are lower relevance. This favors *args parameters in cases where
        // a *args argument is used.
        if (matches[0].matchResults.relevance !== matches[matches.length - 1].matchResults.relevance) {
            matches = matches.filter((m) => m.matchResults.relevance === matches[0].matchResults.relevance);
            if (matches.length < 2) {
                return matches;
            }
        }
        // If all of the return types match, select the first one.
        if ((0, typeUtils_1.areTypesSame)(matches.map((match) => match.returnType), { treatAnySameAsUnknown: true })) {
            return [matches[0]];
        }
        const firstArgResults = matches[0].argResults;
        if (!firstArgResults) {
            return matches;
        }
        let foundAmbiguousAnyArg = false;
        for (let i = 0; i < firstArgResults.length; i++) {
            // If the arg is Any or Unknown, see if the corresponding
            // parameter types differ in any way.
            if ((0, types_1.isAnyOrUnknown)(firstArgResults[i].argType)) {
                const paramTypes = matches.map((match) => i < match.matchResults.argParams.length
                    ? match.matchResults.argParams[i].paramType
                    : types_1.UnknownType.create());
                if (!(0, typeUtils_1.areTypesSame)(paramTypes, { treatAnySameAsUnknown: true })) {
                    foundAmbiguousAnyArg = true;
                }
            }
        }
        // If the first overload has a different number of effective arguments
        // than latter overloads, don't filter any of them. This typically means
        // that one of the arguments is an unpacked iterator, and it maps to
        // an indeterminate number of parameters, which means that the overload
        // selection is ambiguous.
        if (foundAmbiguousAnyArg || matches.some((match) => match.argResults.length !== firstArgResults.length)) {
            return matches;
        }
        return [matches[0]];
    }
    function getBestOverloadForArguments(errorNode, typeResult, argList) {
        let overloadIndex = 0;
        let matches = [];
        const signatureTracker = new typeUtils_1.UniqueSignatureTracker();
        // Create a list of potential overload matches based on arguments.
        types_1.OverloadedFunctionType.getOverloads(typeResult.type).forEach((overload) => {
            useSpeculativeMode(errorNode, () => {
                const matchResults = matchArgsToParams(errorNode, argList, { type: overload, isIncomplete: typeResult.isIncomplete }, overloadIndex, 
                /* signatureTracker */ undefined);
                if (!matchResults.argumentErrors) {
                    matches.push(matchResults);
                }
                overloadIndex++;
            });
        });
        matches = sortOverloadsByBestMatch(matches);
        let winningOverloadIndex;
        matches.forEach((match, matchIndex) => {
            if (winningOverloadIndex === undefined) {
                useSpeculativeMode(errorNode, () => {
                    const callResult = validateArgTypes(errorNode, match, new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(match.overload)), signatureTracker, 
                    /* skipUnknownArgCheck */ true);
                    if (callResult && !callResult.argumentErrors) {
                        winningOverloadIndex = matchIndex;
                    }
                });
            }
        });
        return winningOverloadIndex === undefined ? undefined : matches[winningOverloadIndex].overload;
    }
    // Sorts the list of overloads based first on "relevance" and second on order.
    function sortOverloadsByBestMatch(matches) {
        return matches.sort((a, b) => {
            if (a.relevance !== b.relevance) {
                return b.relevance - a.relevance;
            }
            return a.overloadIndex - b.overloadIndex;
        });
    }
    function validateOverloadedFunctionArguments(errorNode, argList, typeResult, typeVarContext, skipUnknownArgCheck, inferenceContext, signatureTracker) {
        let filteredMatchResults = [];
        let contextFreeArgTypes;
        let isTypeIncomplete = !!typeResult.isIncomplete;
        // Start by evaluating the types of the arguments without any expected
        // type. Also, filter the list of overloads based on the number of
        // positional and named arguments that are present. We do all of this
        // speculatively because we don't want to record any types in the type
        // cache or record any diagnostics at this stage.
        useSpeculativeMode(errorNode, () => {
            let overloadIndex = 0;
            types_1.OverloadedFunctionType.getOverloads(typeResult.type).forEach((overload) => {
                // Consider only the functions that have the @overload decorator,
                // not the final function that omits the overload. This is the
                // intended behavior according to PEP 484.
                const matchResults = matchArgsToParams(errorNode, argList, { type: overload, isIncomplete: typeResult.isIncomplete }, overloadIndex, signatureTracker);
                if (!matchResults.argumentErrors) {
                    filteredMatchResults.push(matchResults);
                }
                overloadIndex++;
            });
        });
        filteredMatchResults = sortOverloadsByBestMatch(filteredMatchResults);
        // If there are no possible arg/param matches among the overloads,
        // emit an error that includes the argument types.
        if (filteredMatchResults.length === 0) {
            // Skip the error message if we're in speculative mode because it's very
            // expensive, and we're going to suppress the diagnostic anyway.
            if (!canSkipDiagnosticForNode(errorNode)) {
                const functionName = typeResult.type.overloads[0].details.name || '<anonymous function>';
                const diagAddendum = new diagnostic_1.DiagnosticAddendum();
                const argTypes = argList.map((t) => {
                    const typeString = printType(getTypeOfArgument(t, /* inferenceContext */ undefined, signatureTracker).type);
                    if (t.argumentCategory === 1 /* ArgumentCategory.UnpackedList */) {
                        return `*${typeString}`;
                    }
                    if (t.argumentCategory === 2 /* ArgumentCategory.UnpackedDictionary */) {
                        return `**${typeString}`;
                    }
                    return typeString;
                });
                diagAddendum.addMessage(localize_1.LocAddendum.argumentTypes().format({ types: argTypes.join(', ') }));
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, localize_1.LocMessage.noOverload().format({ name: functionName }) + diagAddendum.getString(), errorNode);
            }
            return { argumentErrors: true, isTypeIncomplete, overloadsUsedForCall: [] };
        }
        // Create a helper function that evaluates the overload that best
        // matches the arg/param lists.
        function evaluateUsingBestMatchingOverload(skipUnknownArgCheck, emitNoOverloadFoundError) {
            // Find the match with the smallest argument match score. If there
            // are more than one with the same score, use the one with the
            // largest index. Later overloads tend to be more general.
            const bestMatch = filteredMatchResults.reduce((previous, current) => {
                if (current.argumentMatchScore === previous.argumentMatchScore) {
                    return current.overloadIndex > previous.overloadIndex ? current : previous;
                }
                return current.argumentMatchScore < previous.argumentMatchScore ? current : previous;
            });
            // If there is more than one filtered match, report that no match
            // was possible and emit a diagnostic that provides the most likely.
            if (emitNoOverloadFoundError) {
                const functionName = bestMatch.overload.details.name || '<anonymous function>';
                const diagnostic = addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, localize_1.LocMessage.noOverload().format({ name: functionName }), errorNode);
                const overrideDecl = bestMatch.overload.details.declaration;
                if (diagnostic && overrideDecl) {
                    diagnostic.addRelatedInfo(localize_1.LocAddendum.overloadIndex().format({ index: bestMatch.overloadIndex + 1 }), overrideDecl.uri, overrideDecl.range);
                }
            }
            const effectiveTypeVarContext = typeVarContext !== null && typeVarContext !== void 0 ? typeVarContext : new typeVarContext_1.TypeVarContext();
            effectiveTypeVarContext.addSolveForScope((0, typeUtils_1.getTypeVarScopeIds)(bestMatch.overload));
            effectiveTypeVarContext.unlock();
            return validateArgTypesWithContext(errorNode, bestMatch, effectiveTypeVarContext, skipUnknownArgCheck, inferenceContext, signatureTracker);
        }
        // If there is only one possible arg/param match among the overloads,
        // use the normal type matching mechanism because it is faster and
        // will provide a clearer error message.
        if (filteredMatchResults.length === 1) {
            return evaluateUsingBestMatchingOverload(
            /* skipUnknownArgCheck */ false, 
            /* emitNoOverloadFoundError */ false);
        }
        let expandedArgTypes = [argList.map((arg) => undefined)];
        while (true) {
            const callResult = validateOverloadsWithExpandedTypes(errorNode, expandedArgTypes, filteredMatchResults, typeVarContext, skipUnknownArgCheck, inferenceContext, signatureTracker);
            if (callResult.isTypeIncomplete) {
                isTypeIncomplete = true;
            }
            if (!callResult.argumentErrors) {
                return callResult;
            }
            // We didn't find an overload match. Try to expand the next union
            // argument type into individual types and retry with the expanded types.
            if (!contextFreeArgTypes) {
                useSpeculativeMode(errorNode, () => {
                    // Evaluate the types of each argument expression without regard to
                    // the context. We'll use this to determine whether we need to do
                    // union expansion.
                    contextFreeArgTypes = argList.map((arg) => {
                        if (arg.typeResult) {
                            return arg.typeResult.type;
                        }
                        if (arg.valueExpression) {
                            const valueExpressionNode = arg.valueExpression;
                            return useSpeculativeMode(valueExpressionNode, () => {
                                return getTypeOfExpression(valueExpressionNode).type;
                            });
                        }
                        return types_1.AnyType.create();
                    });
                });
            }
            expandedArgTypes = expandArgumentUnionTypes(contextFreeArgTypes, expandedArgTypes);
            // Check for combinatoric explosion and break out of loop.
            if (!expandedArgTypes || expandedArgTypes.length > maxOverloadUnionExpansionCount) {
                break;
            }
        }
        // We couldn't find any valid overloads. Skip the error message if we're
        // in speculative mode because it's very expensive, and we're going to
        // suppress the diagnostic anyway.
        if (!canSkipDiagnosticForNode(errorNode) && !isTypeIncomplete) {
            const result = evaluateUsingBestMatchingOverload(
            /* skipUnknownArgCheck */ true, 
            /* emitNoOverloadFoundError */ true);
            // Replace the result with an unknown type since we don't know
            // what overload should have been used.
            result.returnType = types_1.UnknownType.create();
            return { ...result, argumentErrors: true };
        }
        return { argumentErrors: true, isTypeIncomplete, overloadsUsedForCall: [] };
    }
    // Replaces each item in the expandedArgTypes with n items where n is
    // the number of subtypes in a union. The contextFreeArgTypes parameter
    // represents the types of the arguments evaluated with no bidirectional
    // type inference (i.e. without the help of the corresponding parameter's
    // expected type). If the function returns undefined, that indicates that
    // all unions have been expanded, and no more expansion is possible.
    function expandArgumentUnionTypes(contextFreeArgTypes, expandedArgTypes) {
        // Find the rightmost already-expanded argument.
        let indexToExpand = contextFreeArgTypes.length - 1;
        while (indexToExpand >= 0 && !expandedArgTypes[0][indexToExpand]) {
            indexToExpand--;
        }
        // Move to the next candidate for expansion.
        indexToExpand++;
        if (indexToExpand >= contextFreeArgTypes.length) {
            return undefined;
        }
        let unionToExpand;
        while (indexToExpand < contextFreeArgTypes.length) {
            // Is this a union type? If so, we can expand it.
            const argType = contextFreeArgTypes[indexToExpand];
            if ((0, types_1.isUnion)(argType)) {
                unionToExpand = makeTopLevelTypeVarsConcrete(argType);
                break;
            }
            else if ((0, types_1.isTypeVar)(argType) && argType.details.constraints.length > 1) {
                unionToExpand = makeTopLevelTypeVarsConcrete(argType);
                break;
            }
            indexToExpand++;
        }
        // We have nothing left to expand.
        if (!unionToExpand) {
            return undefined;
        }
        // Expand entry indexToExpand.
        const newExpandedArgTypes = [];
        expandedArgTypes.forEach((preExpandedTypes) => {
            (0, typeUtils_1.doForEachSubtype)(unionToExpand, (subtype) => {
                const expandedTypes = [...preExpandedTypes];
                expandedTypes[indexToExpand] = subtype;
                newExpandedArgTypes.push(expandedTypes);
            });
        });
        return newExpandedArgTypes;
    }
    // Validates that the arguments can be assigned to the call's parameter
    // list, specializes the call based on arg types, and returns the
    // specialized type of the return value. If it detects an error along
    // the way, it emits a diagnostic and sets argumentErrors to true.
    function validateCallArguments(errorNode, argList, callTypeResult, typeVarContext, skipUnknownArgCheck, inferenceContext, signatureTracker, recursionCount = 0) {
        let argumentErrors = false;
        let isTypeIncomplete = false;
        let specializedInitSelfType;
        const overloadsUsedForCall = [];
        if (recursionCount > types_1.maxTypeRecursionCount) {
            return { returnType: types_1.UnknownType.create(), argumentErrors: true, overloadsUsedForCall };
        }
        recursionCount++;
        // Special forms are not callable.
        if (callTypeResult.type.specialForm) {
            const exprNode = errorNode.nodeType === 9 /* ParseNodeType.Call */ ? errorNode.leftExpression : errorNode;
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, localize_1.LocMessage.objectNotCallable().format({
                type: printType(callTypeResult.type.specialForm, { expandTypeAlias: true }),
            }), exprNode);
            return { returnType: types_1.UnknownType.create(), argumentErrors: true, overloadsUsedForCall };
        }
        let returnType = mapSubtypesExpandTypeVars(callTypeResult.type, { sortSubtypes: true }, (expandedSubtype, unexpandedSubtype, isLastIteration) => {
            return useSpeculativeMode(isLastIteration ? undefined : errorNode, () => {
                const callResult = validateCallArgumentsForSubtype(errorNode, argList, expandedSubtype, unexpandedSubtype, !!callTypeResult.isIncomplete, typeVarContext, skipUnknownArgCheck, inferenceContext, signatureTracker, recursionCount);
                if (callResult.argumentErrors) {
                    argumentErrors = true;
                }
                if (callResult.isTypeIncomplete) {
                    isTypeIncomplete = true;
                }
                if (callResult.overloadsUsedForCall) {
                    (0, collectionUtils_1.appendArray)(overloadsUsedForCall, callResult.overloadsUsedForCall);
                }
                specializedInitSelfType = callResult.specializedInitSelfType;
                return callResult.returnType;
            }, {
                allowDiagnostics: true,
            });
        });
        // If we ended up with a "Never" type because all code paths returned
        // undefined due to argument errors, transform the result into an Unknown
        // to avoid subsequent false positives.
        if (argumentErrors && (0, types_1.isNever)(returnType) && !returnType.isNoReturn) {
            returnType = types_1.UnknownType.create();
        }
        return {
            argumentErrors,
            returnType,
            isTypeIncomplete,
            specializedInitSelfType,
            overloadsUsedForCall,
        };
    }
    function validateCallArgumentsForSubtype(errorNode, argList, expandedCallType, unexpandedCallType, isCallTypeIncomplete, typeVarContext, skipUnknownArgCheck, inferenceContext, signatureTracker, recursionCount) {
        switch (expandedCallType.category) {
            case 3 /* TypeCategory.Never */:
            case 1 /* TypeCategory.Unknown */:
            case 2 /* TypeCategory.Any */: {
                // Touch all of the args so they're marked accessed. Don't bother
                // doing this if the call type is incomplete because this will need
                // to be done again once it is complete.
                if (!isCallTypeIncomplete) {
                    argList.forEach((arg) => {
                        if (arg.valueExpression && !isSpeculativeModeInUse(arg.valueExpression)) {
                            getTypeOfArgument(arg, /* inferenceContext */ undefined, signatureTracker);
                        }
                    });
                }
                return { returnType: expandedCallType };
            }
            case 4 /* TypeCategory.Function */: {
                return validateCallForFunction(errorNode, argList, expandedCallType, isCallTypeIncomplete, typeVarContext, skipUnknownArgCheck, inferenceContext, signatureTracker);
            }
            case 5 /* TypeCategory.OverloadedFunction */: {
                return validateCallForOverloadedFunction(errorNode, argList, expandedCallType, isCallTypeIncomplete, typeVarContext, skipUnknownArgCheck, inferenceContext, signatureTracker);
            }
            case 6 /* TypeCategory.Class */: {
                if ((0, typeUtils_1.isNoneInstance)(expandedCallType)) {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportOptionalCall, localize_1.LocMessage.noneNotCallable(), errorNode);
                    return { argumentErrors: true };
                }
                if (types_1.TypeBase.isInstantiable(expandedCallType)) {
                    return validateCallForInstantiableClass(errorNode, argList, expandedCallType, unexpandedCallType, skipUnknownArgCheck, inferenceContext, signatureTracker);
                }
                return validateCallForClassInstance(errorNode, argList, expandedCallType, unexpandedCallType, typeVarContext, skipUnknownArgCheck, inferenceContext, signatureTracker, recursionCount);
            }
            // TypeVars should have been expanded in most cases,
            // but we still need to handle the case of Type[T] where
            // T is a constrained type that contains a union. We also
            // need to handle recursive type aliases.
            case 9 /* TypeCategory.TypeVar */: {
                return validateCallArguments(errorNode, argList, { type: (0, typeUtils_1.transformPossibleRecursiveTypeAlias)(expandedCallType), isIncomplete: isCallTypeIncomplete }, typeVarContext, skipUnknownArgCheck, inferenceContext, signatureTracker, recursionCount);
            }
            case 7 /* TypeCategory.Module */: {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, localize_1.LocMessage.moduleNotCallable(), errorNode);
                return { argumentErrors: true };
            }
        }
        return { argumentErrors: true };
    }
    function validateCallForFunction(errorNode, argList, type, isCallTypeIncomplete, typeVarContext, skipUnknownArgCheck, inferenceContext, signatureTracker) {
        var _a;
        if (types_1.TypeBase.isInstantiable(type)) {
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, localize_1.LocMessage.callableNotInstantiable().format({
                type: printType(type),
            }), errorNode);
            return { returnType: undefined, argumentErrors: true };
        }
        let effectiveTypeVarContext = typeVarContext;
        if (!effectiveTypeVarContext) {
            // If a typeVarContext wasn't provided by the caller, allocate one here.
            effectiveTypeVarContext = new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeIds)(type));
        }
        // The stdlib collections/__init__.pyi stub file defines namedtuple
        // as a function rather than a class, so we need to check for it here.
        if (type.details.builtInName === 'namedtuple') {
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportUntypedNamedTuple, localize_1.LocMessage.namedTupleNoTypes(), errorNode);
            const result = {
                returnType: (0, namedTuples_1.createNamedTupleType)(evaluatorInterface, errorNode, argList, /* includesTypes */ false),
            };
            validateArgs(errorNode, argList, { type: type }, effectiveTypeVarContext, skipUnknownArgCheck, inferenceContext, signatureTracker);
            return result;
        }
        // Handle the NewType specially, replacing the normal return type.
        if (type.details.builtInName === 'NewType') {
            return { returnType: createNewType(errorNode, argList) };
        }
        const functionResult = validateArgs(errorNode, argList, { type, isIncomplete: isCallTypeIncomplete }, effectiveTypeVarContext, skipUnknownArgCheck, inferenceContext, signatureTracker);
        let isTypeIncomplete = !!functionResult.isTypeIncomplete;
        let returnType = functionResult.returnType;
        let argumentErrors = !!functionResult.argumentErrors;
        if (!argumentErrors) {
            // Call the function transform logic to handle special-cased functions.
            const transformed = (0, functionTransform_1.applyFunctionTransform)(evaluatorInterface, errorNode, argList, type, {
                argumentErrors: !!functionResult.argumentErrors,
                returnType: (_a = functionResult.returnType) !== null && _a !== void 0 ? _a : types_1.UnknownType.create(isTypeIncomplete),
                isTypeIncomplete,
            });
            returnType = transformed.returnType;
            if (transformed.isTypeIncomplete) {
                isTypeIncomplete = true;
            }
            if (transformed.argumentErrors) {
                argumentErrors = true;
            }
        }
        if (type.details.builtInName === '__import__') {
            // For the special __import__ type, we'll override the return type to be "Any".
            // This is required because we don't know what module was imported, and we don't
            // want to fail type checks when accessing members of the resulting module type.
            returnType = types_1.AnyType.create();
        }
        return {
            returnType,
            isTypeIncomplete,
            argumentErrors,
            overloadsUsedForCall: functionResult.overloadsUsedForCall,
            specializedInitSelfType: functionResult.specializedInitSelfType,
        };
    }
    // Determines whether a symbol is abstract. In an ABC class, this means a function
    // is specifically decorated with @abstractmethod. In a protocol class, the rules
    // are more complicated and depend on whether the method is defined in a stub file.
    function getAbstractSymbolInfo(classType, symbolName) {
        const isProtocolClass = types_1.ClassType.isProtocolClass(classType);
        const symbol = types_1.ClassType.getSymbolTable(classType).get(symbolName);
        if (!symbol) {
            return undefined;
        }
        // Ignore instance variables. Also, ignore named tuple members, which are
        // modeled in pyright as instance variables, but their runtime implementation
        // uses a descriptor object.
        if (!symbol.isClassMember() && !symbol.isNamedTupleMemberMember()) {
            return undefined;
        }
        const lastDecl = (0, symbolUtils_1.getLastTypedDeclarationForSymbol)(symbol);
        if (!lastDecl) {
            return undefined;
        }
        // Handle protocol variables specially.
        if (isProtocolClass && lastDecl.type === 1 /* DeclarationType.Variable */) {
            // If none of the declarations involve assignments, assume it's
            // not implemented in the protocol.
            const allDecls = symbol.getDeclarations();
            if (!allDecls.some((decl) => decl.type === 1 /* DeclarationType.Variable */ && !!decl.inferredTypeSource)) {
                return { symbol, symbolName, classType, hasImplementation: false };
            }
        }
        if (lastDecl.type !== 5 /* DeclarationType.Function */) {
            return undefined;
        }
        let isAbstract = false;
        const lastFunctionInfo = (0, decorators_1.getFunctionInfoFromDecorators)(evaluatorInterface, lastDecl.node, /* isInClass */ true);
        if ((lastFunctionInfo.flags & 8 /* FunctionTypeFlags.AbstractMethod */) !== 0) {
            isAbstract = true;
        }
        const isStubFile = AnalyzerNodeInfo.getFileInfo(lastDecl.node).isStubFile;
        // In an overloaded method, the first overload can also be marked abstract.
        // In stub files, there is no implementation, so this is the only way to mark
        // an overloaded method as abstract.
        const firstDecl = symbol.getDeclarations()[0];
        let firstFunctionInfo;
        if (firstDecl !== lastDecl && firstDecl.type === 5 /* DeclarationType.Function */) {
            firstFunctionInfo = (0, decorators_1.getFunctionInfoFromDecorators)(evaluatorInterface, firstDecl.node, /* isInClass */ true);
            if ((firstFunctionInfo.flags & 8 /* FunctionTypeFlags.AbstractMethod */) !== 0) {
                isAbstract = true;
            }
            // If there's no implementation, assume it's unimplemented.
            if (isProtocolClass && (lastFunctionInfo.flags & 256 /* FunctionTypeFlags.Overloaded */) !== 0) {
                // If this is a protocol class method defined in a stub file and
                // it's not marked abstract, assume it's not abstract and implemented.
                if (isProtocolClass && !isAbstract && isStubFile) {
                    return undefined;
                }
                return { symbol, symbolName, classType, hasImplementation: false };
            }
        }
        // In a non-protocol class, if the method isn't explicitly marked abstract,
        // then it's not abstract.
        if (!isProtocolClass && !isAbstract) {
            return undefined;
        }
        const hasImplementation = !ParseTreeUtils.isSuiteEmpty(lastDecl.node.suite) && !methodAlwaysRaisesNotImplemented(lastDecl);
        // If this is a protocol class, the method isn't explicitly marked
        // as abstract, and there is an implementation, then it's a default
        // implementation, and it's not considered abstract. If it's in a stub
        // file, assume it's implemented in this case.
        if (isProtocolClass && !isAbstract) {
            if (hasImplementation || isStubFile) {
                return undefined;
            }
        }
        return { symbol, symbolName, classType, hasImplementation };
    }
    function validateCallForOverloadedFunction(errorNode, argList, expandedCallType, isCallTypeIncomplete, typeVarContext, skipUnknownArgCheck, inferenceContext, signatureTracker) {
        var _a, _b;
        // Handle the 'cast' call as a special case.
        if (expandedCallType.overloads[0].details.builtInName === 'cast' && argList.length === 2) {
            return { returnType: evaluateCastCall(argList, errorNode) };
        }
        const callResult = validateOverloadedFunctionArguments(errorNode, argList, { type: expandedCallType, isIncomplete: isCallTypeIncomplete }, typeVarContext, skipUnknownArgCheck, inferenceContext, signatureTracker);
        let returnType = (_a = callResult.returnType) !== null && _a !== void 0 ? _a : types_1.UnknownType.create();
        let isTypeIncomplete = !!callResult.isTypeIncomplete;
        let argumentErrors = !!callResult.argumentErrors;
        if (!argumentErrors) {
            // Call the function transform logic to handle special-cased functions.
            const transformed = (0, functionTransform_1.applyFunctionTransform)(evaluatorInterface, errorNode, argList, expandedCallType, {
                argumentErrors: !!callResult.argumentErrors,
                returnType: (_b = callResult.returnType) !== null && _b !== void 0 ? _b : types_1.UnknownType.create(isTypeIncomplete),
                isTypeIncomplete,
            });
            returnType = transformed.returnType;
            if (transformed.isTypeIncomplete) {
                isTypeIncomplete = true;
            }
            if (transformed.argumentErrors) {
                argumentErrors = true;
            }
        }
        return {
            returnType,
            isTypeIncomplete,
            argumentErrors,
            overloadsUsedForCall: callResult.overloadsUsedForCall,
            specializedInitSelfType: callResult.specializedInitSelfType,
        };
    }
    function validateCallForInstantiableClass(errorNode, argList, expandedCallType, unexpandedCallType, skipUnknownArgCheck, inferenceContext, signatureTracker) {
        var _a, _b;
        if (expandedCallType.literalValue !== undefined) {
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, localize_1.LocMessage.literalNotCallable(), errorNode);
            return { returnType: types_1.UnknownType.create(), argumentErrors: true };
        }
        if (types_1.ClassType.isBuiltIn(expandedCallType)) {
            const className = (_a = expandedCallType.aliasName) !== null && _a !== void 0 ? _a : expandedCallType.details.name;
            // Handle a call to a metaclass explicitly.
            if ((0, typeUtils_1.isInstantiableMetaclass)(expandedCallType)) {
                if (expandedCallType.typeArguments && expandedCallType.isTypeArgumentExplicit) {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, localize_1.LocMessage.objectNotCallable().format({
                        type: printType(expandedCallType),
                    }), errorNode);
                    return { returnType: types_1.UnknownType.create(), argumentErrors: true };
                }
                // Validate the constructor arguments.
                (0, constructors_1.validateConstructorArguments)(evaluatorInterface, errorNode, argList, expandedCallType, skipUnknownArgCheck, inferenceContext, signatureTracker);
                // The one-parameter form of "type" returns the class
                // for the specified object.
                if (expandedCallType.details.name === 'type' && argList.length === 1) {
                    const argType = getTypeOfArgument(argList[0], 
                    /* inferenceContext */ undefined, signatureTracker).type;
                    const returnType = (0, typeUtils_1.mapSubtypes)(argType, (subtype) => {
                        if ((0, types_1.isInstantiableClass)(subtype) && subtype.details.effectiveMetaclass) {
                            return subtype.details.effectiveMetaclass;
                        }
                        if ((0, types_1.isNever)(subtype)) {
                            return subtype;
                        }
                        if (types_1.TypeBase.isInstance(subtype)) {
                            if ((0, types_1.isClass)(subtype) || (0, types_1.isTypeVar)(subtype)) {
                                return (0, typeUtils_1.convertToInstantiable)(stripLiteralValue(subtype));
                            }
                            if ((0, types_1.isFunction)(subtype)) {
                                return types_1.FunctionType.cloneAsInstantiable(subtype);
                            }
                        }
                        return types_1.ClassType.cloneForSpecialization(types_1.ClassType.cloneAsInstance(expandedCallType), [types_1.UnknownType.create()], 
                        /* isTypeArgumentExplicit */ true);
                    });
                    return { returnType };
                }
                if (argList.length >= 2) {
                    // The two-parameter form of a call to a metaclass returns a new class
                    // built from the specified base types.
                    return {
                        returnType: createClassFromMetaclass(errorNode, argList, expandedCallType) || types_1.AnyType.create(),
                    };
                }
                // If the parameter to type() is not statically known,
                // fall back to Any.
                return { returnType: types_1.AnyType.create() };
            }
            if (className === 'TypeVar') {
                return {
                    returnType: createTypeVarType(errorNode, expandedCallType, argList),
                };
            }
            if (className === 'TypeVarTuple') {
                return {
                    returnType: createTypeVarTupleType(errorNode, expandedCallType, argList),
                };
            }
            if (className === 'ParamSpec') {
                return {
                    returnType: createParamSpecType(errorNode, expandedCallType, argList),
                };
            }
            if (className === 'TypeAliasType') {
                const newTypeAlias = createTypeAliasType(errorNode, argList);
                if (newTypeAlias) {
                    return { returnType: newTypeAlias };
                }
            }
            if (className === 'NamedTuple') {
                const result = {
                    returnType: (0, namedTuples_1.createNamedTupleType)(evaluatorInterface, errorNode, argList, /* includesTypes */ true),
                };
                const initTypeResult = (0, constructors_1.getBoundInitMethod)(evaluatorInterface, errorNode, types_1.ClassType.cloneAsInstance(expandedCallType), 
                /* diag */ undefined, 0 /* MemberAccessFlags.Default */);
                if (initTypeResult && (0, types_1.isOverloadedFunction)(initTypeResult.type)) {
                    validateOverloadedFunctionArguments(errorNode, argList, { type: initTypeResult.type }, 
                    /* typeVarContext */ undefined, skipUnknownArgCheck, 
                    /* inferenceContext */ undefined, signatureTracker);
                }
                return result;
            }
            if (className === 'NewType') {
                return { returnType: createNewType(errorNode, argList) };
            }
            if (types_1.ClassType.isSpecialFormClass(expandedCallType)) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, localize_1.LocMessage.typeNotIntantiable().format({ type: className }), errorNode);
                return { returnType: types_1.UnknownType.create(), argumentErrors: true };
            }
            if (className === 'TypedDict') {
                return { returnType: (0, typedDicts_1.createTypedDictType)(evaluatorInterface, errorNode, expandedCallType, argList) };
            }
            if (className === 'auto' && argList.length === 0) {
                return { returnType: (0, enums_1.getEnumAutoValueType)(evaluatorInterface, errorNode) };
            }
        }
        // Is it a call to an Enum class factory?
        if ((0, types_1.isClass)(expandedCallType) &&
            expandedCallType.details.effectiveMetaclass &&
            (0, types_1.isClass)(expandedCallType.details.effectiveMetaclass) &&
            (0, enums_1.isEnumMetaclass)(expandedCallType.details.effectiveMetaclass) &&
            !(0, enums_1.isEnumClassWithMembers)(evaluatorInterface, expandedCallType)) {
            return {
                returnType: (_b = (0, enums_1.createEnumType)(evaluatorInterface, errorNode, expandedCallType, argList)) !== null && _b !== void 0 ? _b : (0, typeUtils_1.convertToInstance)(unexpandedCallType),
            };
        }
        if (types_1.ClassType.supportsAbstractMethods(expandedCallType)) {
            const abstractSymbols = getAbstractSymbols(expandedCallType);
            if (abstractSymbols.length > 0 && !expandedCallType.includeSubclasses && !(0, types_1.isTypeVar)(unexpandedCallType)) {
                // If the class is abstract, it can't be instantiated.
                const diagAddendum = new diagnostic_1.DiagnosticAddendum();
                const errorsToDisplay = 2;
                abstractSymbols.forEach((abstractMethod, index) => {
                    if (index === errorsToDisplay) {
                        diagAddendum.addMessage(localize_1.LocAddendum.memberIsAbstractMore().format({
                            count: abstractSymbols.length - errorsToDisplay,
                        }));
                    }
                    else if (index < errorsToDisplay) {
                        if ((0, types_1.isInstantiableClass)(abstractMethod.classType)) {
                            const className = abstractMethod.classType.details.name;
                            diagAddendum.addMessage(localize_1.LocAddendum.memberIsAbstract().format({
                                type: className,
                                name: abstractMethod.symbolName,
                            }));
                        }
                    }
                });
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportAbstractUsage, localize_1.LocMessage.instantiateAbstract().format({
                    type: expandedCallType.details.name,
                }) + diagAddendum.getString(), errorNode);
            }
        }
        if (types_1.ClassType.isProtocolClass(expandedCallType) && !expandedCallType.includeSubclasses) {
            // If the class is a protocol, it can't be instantiated.
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportAbstractUsage, localize_1.LocMessage.instantiateProtocol().format({
                type: expandedCallType.details.name,
            }), errorNode);
        }
        // Assume this is a call to the constructor.
        const constructorResult = (0, constructors_1.validateConstructorArguments)(evaluatorInterface, errorNode, argList, expandedCallType, skipUnknownArgCheck, inferenceContext, signatureTracker);
        const overloadsUsedForCall = constructorResult.overloadsUsedForCall;
        const argumentErrors = constructorResult.argumentErrors;
        const isTypeIncomplete = constructorResult.isTypeIncomplete;
        let returnType = constructorResult.returnType;
        // If the expandedCallType originated from a TypeVar, convert
        // the constructed type back to the TypeVar. For example, if
        // we have `cls: Type[_T]` followed by `_T()`.
        if ((0, types_1.isTypeVar)(unexpandedCallType)) {
            returnType = (0, typeUtils_1.convertToInstance)(unexpandedCallType);
        }
        // If we instantiated the "deprecated" class, attach the deprecation
        // message to the instance.
        if (errorNode.nodeType === 9 /* ParseNodeType.Call */ &&
            returnType &&
            (0, types_1.isClassInstance)(returnType) &&
            types_1.ClassType.isBuiltIn(returnType, 'deprecated')) {
            returnType = types_1.ClassType.cloneForDeprecatedInstance(returnType, (0, decorators_1.getDeprecatedMessageFromCall)(errorNode));
        }
        // If we instantiated a type, transform it into a class.
        // This can happen if someone directly instantiates a metaclass
        // deriving from type.
        if (returnType &&
            (0, types_1.isClassInstance)(returnType) &&
            returnType.details.mro.some((baseClass) => (0, types_1.isInstantiableClass)(baseClass) && types_1.ClassType.isBuiltIn(baseClass, 'type'))) {
            let newClassName = '__class_' + returnType.details.name;
            if (argList.length === 3) {
                const firstArgType = getTypeOfArgument(argList[0], 
                /* inferenceContext */ undefined, signatureTracker).type;
                if ((0, types_1.isClassInstance)(firstArgType) &&
                    types_1.ClassType.isBuiltIn(firstArgType, 'str') &&
                    typeof firstArgType.literalValue === 'string') {
                    newClassName = firstArgType.literalValue;
                }
            }
            const newClassType = types_1.ClassType.createInstantiable(newClassName, '', '', AnalyzerNodeInfo.getFileInfo(errorNode).fileUri, 0 /* ClassTypeFlags.None */, ParseTreeUtils.getTypeSourceId(errorNode), types_1.ClassType.cloneAsInstantiable(returnType), types_1.ClassType.cloneAsInstantiable(returnType));
            newClassType.details.baseClasses.push(getBuiltInType(errorNode, 'object'));
            newClassType.details.effectiveMetaclass = expandedCallType;
            newClassType.details.declaration = returnType.details.declaration;
            (0, typeUtils_1.computeMroLinearization)(newClassType);
            returnType = newClassType;
        }
        return { returnType, overloadsUsedForCall, argumentErrors, isTypeIncomplete };
    }
    function validateCallForClassInstance(errorNode, argList, expandedCallType, unexpandedCallType, typeVarContext, skipUnknownArgCheck, inferenceContext, signatureTracker, recursionCount) {
        var _a;
        const callDiag = new diagnostic_1.DiagnosticAddendum();
        const callMethodResult = getTypeOfBoundMember(errorNode, expandedCallType, '__call__', 
        /* usage */ undefined, callDiag, 16 /* MemberAccessFlags.SkipInstanceMembers */ | 512 /* MemberAccessFlags.SkipAttributeAccessOverride */, 
        /* selfType */ undefined, recursionCount);
        const callMethodType = callMethodResult === null || callMethodResult === void 0 ? void 0 : callMethodResult.type;
        if (!callMethodType || callMethodResult.typeErrors) {
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, localize_1.LocMessage.objectNotCallable().format({
                type: printType(expandedCallType),
            }) + callDiag.getString(), errorNode);
            return { returnType: types_1.UnknownType.create(), argumentErrors: true };
        }
        const callResult = validateCallArguments(errorNode, argList, { type: callMethodType }, typeVarContext, skipUnknownArgCheck, inferenceContext, signatureTracker, recursionCount);
        let returnType = (_a = callResult.returnType) !== null && _a !== void 0 ? _a : types_1.UnknownType.create();
        if ((0, types_1.isTypeVar)(unexpandedCallType) &&
            types_1.TypeBase.isInstantiable(unexpandedCallType) &&
            (0, types_1.isClass)(expandedCallType) &&
            types_1.ClassType.isBuiltIn(expandedCallType, 'type')) {
            // Handle the case where a type[T] is being called. We presume this
            // will instantiate an object of type T.
            returnType = (0, typeUtils_1.convertToInstance)(unexpandedCallType);
        }
        return {
            returnType,
            argumentErrors: callResult.argumentErrors,
            overloadsUsedForCall: callResult.overloadsUsedForCall,
        };
    }
    // Evaluates the type of the "cast" call.
    function evaluateCastCall(argList, errorNode) {
        // Verify that the cast is necessary.
        const castToType = getTypeOfArgumentExpectingType(argList[0], { enforceTypeAnnotationRules: true }).type;
        let castFromType = getTypeOfArgument(argList[1], 
        /* inferenceContext */ undefined, 
        /* signatureTracker */ undefined).type;
        if (castFromType.specialForm) {
            castFromType = castFromType.specialForm;
        }
        if (types_1.TypeBase.isInstantiable(castToType) && !(0, types_1.isUnknown)(castToType)) {
            if ((0, types_1.isTypeSame)((0, typeUtils_1.convertToInstance)(castToType), castFromType, {
                ignorePseudoGeneric: true,
            })) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportUnnecessaryCast, localize_1.LocMessage.unnecessaryCast().format({
                    type: printType(castFromType),
                }), errorNode);
            }
        }
        return (0, typeUtils_1.convertToInstance)(castToType);
    }
    // Expands any unpacked tuples within an argument list.
    function expandArgList(argList, signatureTracker) {
        var _a;
        const expandedArgList = [];
        for (const arg of argList) {
            if (arg.argumentCategory === 1 /* ArgumentCategory.UnpackedList */) {
                const argType = getTypeOfArgument(arg, /* inferenceContext */ undefined, signatureTracker).type;
                // If this is a tuple with specified element types, use those
                // specified types rather than using the more generic iterator
                // type which will be a union of all element types.
                const combinedArgType = (0, typeUtils_1.combineSameSizedTuples)(makeTopLevelTypeVarsConcrete(argType), tupleClass);
                if ((0, types_1.isClassInstance)(combinedArgType) && (0, typeUtils_1.isTupleClass)(combinedArgType)) {
                    const tupleTypeArgs = (_a = combinedArgType.tupleTypeArguments) !== null && _a !== void 0 ? _a : [];
                    if (tupleTypeArgs.length !== 1 || !tupleTypeArgs[0].isUnbounded) {
                        for (const tupleTypeArg of tupleTypeArgs) {
                            if (tupleTypeArg.isUnbounded) {
                                expandedArgList.push({
                                    ...arg,
                                    argumentCategory: 1 /* ArgumentCategory.UnpackedList */,
                                    valueExpression: undefined,
                                    typeResult: {
                                        type: makeTupleObject([tupleTypeArg]),
                                    },
                                });
                            }
                            else {
                                expandedArgList.push({
                                    ...arg,
                                    argumentCategory: 0 /* ArgumentCategory.Simple */,
                                    valueExpression: undefined,
                                    typeResult: {
                                        type: tupleTypeArg.type,
                                    },
                                });
                            }
                        }
                        continue;
                    }
                }
            }
            expandedArgList.push(arg);
        }
        return expandedArgList;
    }
    // Matches the arguments passed to a function to the corresponding parameters in that
    // function. This matching is done based on positions and keywords. Type evaluation and
    // validation is left to the caller.
    // This logic is based on PEP 3102: https://www.python.org/dev/peps/pep-3102/
    function matchArgsToParams(errorNode, argList, typeResult, overloadIndex, signatureTracker) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const overload = typeResult.type;
        const paramDetails = (0, parameterUtils_1.getParameterListDetails)(overload);
        const paramSpec = types_1.FunctionType.getParamSpecFromArgsKwargs(overload);
        let argIndex = 0;
        let matchedUnpackedListOfUnknownLength = false;
        let reportedArgError = false;
        let isTypeIncomplete = !!typeResult.isIncomplete;
        let isVariadicTypeVarFullyMatched = false;
        // Expand any unpacked tuples in the arg list.
        argList = expandArgList(argList, signatureTracker);
        // Build a map of parameters by name.
        const paramMap = new Map();
        paramDetails.params.forEach((paramInfo) => {
            (0, debug_1.assert)(paramInfo !== undefined, 'paramInfo is undefined for param name map');
            const param = paramInfo.param;
            if (param.name && param.category === 0 /* ParameterCategory.Simple */) {
                paramMap.set(param.name, {
                    argsNeeded: param.category === 0 /* ParameterCategory.Simple */ && !param.hasDefault ? 1 : 0,
                    argsReceived: 0,
                    isPositionalOnly: paramInfo.kind === parameterUtils_1.ParameterKind.Positional,
                });
            }
        });
        let positionalOnlyLimitIndex = paramDetails.positionOnlyParamCount;
        let positionParamLimitIndex = (_a = paramDetails.firstKeywordOnlyIndex) !== null && _a !== void 0 ? _a : paramDetails.params.length;
        const varArgListParamIndex = paramDetails.argsIndex;
        const varArgDictParamIndex = paramDetails.kwargsIndex;
        // Is this an function that uses the *args and **kwargs
        // from a param spec? If so, we need to treat all positional parameters
        // prior to the *args as positional-only according to PEP 612.
        let paramSpecArgList;
        let paramSpecTarget;
        let hasParamSpecArgsKwargs = false;
        // Determine how many positional args are being passed before
        // we see a keyword arg.
        let positionalArgCount = argList.findIndex((arg) => arg.argumentCategory === 2 /* ArgumentCategory.UnpackedDictionary */ || arg.name !== undefined);
        if (positionalArgCount < 0) {
            positionalArgCount = argList.length;
        }
        if (varArgListParamIndex !== undefined && varArgDictParamIndex !== undefined) {
            (0, debug_1.assert)(paramDetails.params[varArgListParamIndex], 'varArgListParamIndex params entry is undefined');
            const varArgListParam = paramDetails.params[varArgListParamIndex].param;
            (0, debug_1.assert)(paramDetails.params[varArgDictParamIndex], 'varArgDictParamIndex params entry is undefined');
            const varArgDictParam = paramDetails.params[varArgDictParamIndex].param;
            if ((0, types_1.isParamSpec)(varArgListParam.type) &&
                varArgListParam.type.paramSpecAccess === 'args' &&
                (0, types_1.isParamSpec)(varArgDictParam.type) &&
                varArgDictParam.type.paramSpecAccess === 'kwargs' &&
                varArgListParam.type.details.name === varArgDictParam.type.details.name) {
                hasParamSpecArgsKwargs = true;
                // Does this function define the param spec, or is it an inner
                // function nested within another function that defines the param
                // spec? We need to handle these two cases differently.
                const paramSpecScopeId = varArgListParam.type.scopeId;
                if ((_b = (0, typeUtils_1.getTypeVarScopeIds)(overload)) === null || _b === void 0 ? void 0 : _b.some((id) => id === paramSpecScopeId)) {
                    paramSpecArgList = [];
                    paramSpecTarget = types_1.TypeVarType.cloneForParamSpecAccess(varArgListParam.type, /* access */ undefined);
                }
                else {
                    positionalOnlyLimitIndex = varArgListParamIndex;
                    positionalArgCount = varArgListParamIndex;
                    positionParamLimitIndex = varArgListParamIndex;
                }
            }
        }
        else if (paramSpec) {
            if ((_c = (0, typeUtils_1.getTypeVarScopeIds)(overload)) === null || _c === void 0 ? void 0 : _c.some((id) => id === paramSpec.scopeId)) {
                hasParamSpecArgsKwargs = true;
                paramSpecArgList = [];
                paramSpecTarget = paramSpec;
            }
        }
        // If there are keyword arguments present after a *args argument,
        // the keyword arguments may target one or more parameters that are positional.
        // In this case, we will limit the number of positional parameters so the
        // *args doesn't consume them all.
        if (argList.some((arg) => arg.argumentCategory === 1 /* ArgumentCategory.UnpackedList */)) {
            argList.forEach((arg) => {
                if (arg.name) {
                    const keywordParamIndex = paramDetails.params.findIndex((paramInfo) => {
                        (0, debug_1.assert)(paramInfo, 'paramInfo entry is undefined fork kwargs check');
                        return (paramInfo.param.name === arg.name.value &&
                            paramInfo.param.category === 0 /* ParameterCategory.Simple */);
                    });
                    // Is this a parameter that can be interpreted as either a keyword or a positional?
                    // If so, we'll treat it as a keyword parameter in this case because it's being
                    // targeted by a keyword argument.
                    if (keywordParamIndex >= 0 && keywordParamIndex >= positionalOnlyLimitIndex) {
                        if (positionParamLimitIndex < 0 || keywordParamIndex < positionParamLimitIndex) {
                            positionParamLimitIndex = keywordParamIndex;
                        }
                    }
                }
            });
        }
        // If we didn't see any special cases, then all parameters are positional.
        if (positionParamLimitIndex < 0) {
            positionParamLimitIndex = paramDetails.params.length;
        }
        let validateArgTypeParams = [];
        let activeParam;
        function trySetActive(arg, param) {
            if (arg.active) {
                activeParam = param;
            }
        }
        const foundUnpackedListArg = argList.find((arg) => arg.argumentCategory === 1 /* ArgumentCategory.UnpackedList */) !== undefined;
        // Map the positional args to parameters.
        let paramIndex = 0;
        while (argIndex < positionalArgCount) {
            if (argIndex < positionalOnlyLimitIndex && argList[argIndex].name) {
                const nameNode = argList[argIndex].name;
                if (nameNode) {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, localize_1.LocMessage.argPositional(), nameNode);
                    reportedArgError = true;
                }
            }
            const remainingArgCount = positionalArgCount - argIndex;
            const remainingParamCount = positionParamLimitIndex - paramIndex - 1;
            if (paramIndex >= positionParamLimitIndex) {
                if (paramSpecArgList) {
                    // Push the remaining positional args onto the param spec arg list.
                    while (argIndex < positionalArgCount) {
                        paramSpecArgList.push(argList[argIndex]);
                        argIndex++;
                    }
                }
                else {
                    let tooManyPositionals = false;
                    if (foundUnpackedListArg && argList[argIndex].argumentCategory === 1 /* ArgumentCategory.UnpackedList */) {
                        // If this is an unpacked iterable, we will conservatively assume that it
                        // might have zero iterations unless we can tell from its type that it
                        // definitely has at least one iterable value.
                        const argType = getTypeOfArgument(argList[argIndex], 
                        /* inferenceContext */ undefined, signatureTracker).type;
                        if ((0, types_1.isClassInstance)(argType) &&
                            (0, typeUtils_1.isTupleClass)(argType) &&
                            !(0, typeUtils_1.isUnboundedTupleClass)(argType) &&
                            argType.tupleTypeArguments !== undefined &&
                            argType.tupleTypeArguments.length > 0) {
                            tooManyPositionals = true;
                        }
                    }
                    else {
                        tooManyPositionals = true;
                    }
                    if (tooManyPositionals) {
                        if (!canSkipDiagnosticForNode(errorNode) && !isTypeIncomplete) {
                            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, positionParamLimitIndex === 1
                                ? localize_1.LocMessage.argPositionalExpectedOne()
                                : localize_1.LocMessage.argPositionalExpectedCount().format({
                                    expected: positionParamLimitIndex,
                                }), (_d = argList[argIndex].valueExpression) !== null && _d !== void 0 ? _d : errorNode);
                        }
                        reportedArgError = true;
                    }
                }
                break;
            }
            if (paramIndex >= paramDetails.params.length) {
                break;
            }
            (0, debug_1.assert)(paramDetails.params[paramIndex], 'paramIndex params entry is undefined');
            const paramType = paramDetails.params[paramIndex].type;
            const paramName = paramDetails.params[paramIndex].param.name;
            const isParamVariadic = paramDetails.params[paramIndex].param.category === 1 /* ParameterCategory.ArgsList */ &&
                (0, types_1.isVariadicTypeVar)(paramType);
            if (argList[argIndex].argumentCategory === 1 /* ArgumentCategory.UnpackedList */) {
                let isArgCompatibleWithVariadic = false;
                const argTypeResult = getTypeOfArgument(argList[argIndex], 
                /* inferenceContext */ undefined, signatureTracker);
                let listElementType;
                let advanceToNextArg = false;
                // Handle the case where *args is being passed to a function defined
                // with a ParamSpec and a Concatenate operator. PEP 612 indicates that
                // all positional parameters specified in the Concatenate must be
                // filled explicitly.
                if (paramIndex < positionParamLimitIndex) {
                    if ((0, types_1.isTypeVar)(argTypeResult.type) &&
                        argTypeResult.type.paramSpecAccess === 'args' &&
                        paramDetails.params[paramIndex].param.category !== 1 /* ParameterCategory.ArgsList */) {
                        if (!canSkipDiagnosticForNode(errorNode) && !isTypeIncomplete) {
                            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, positionParamLimitIndex === 1
                                ? localize_1.LocMessage.argPositionalExpectedOne()
                                : localize_1.LocMessage.argPositionalExpectedCount().format({
                                    expected: positionParamLimitIndex,
                                }), (_e = argList[argIndex].valueExpression) !== null && _e !== void 0 ? _e : errorNode);
                        }
                        reportedArgError = true;
                    }
                }
                const argType = argTypeResult.type;
                if (isParamVariadic && (0, types_1.isUnpackedVariadicTypeVar)(argType)) {
                    // Allow an unpacked variadic type variable to satisfy an
                    // unpacked variadic type variable.
                    listElementType = argType;
                    isArgCompatibleWithVariadic = true;
                    advanceToNextArg = true;
                    isVariadicTypeVarFullyMatched = true;
                }
                else if ((0, types_1.isClassInstance)(argType) &&
                    (0, typeUtils_1.isTupleClass)(argType) &&
                    argType.tupleTypeArguments &&
                    argType.tupleTypeArguments.length === 1 &&
                    (0, types_1.isUnpackedVariadicTypeVar)(argType.tupleTypeArguments[0].type)) {
                    // Handle the case where an unpacked variadic type var has
                    // been packaged into a tuple.
                    listElementType = argType.tupleTypeArguments[0].type;
                    isArgCompatibleWithVariadic = true;
                    advanceToNextArg = true;
                    isVariadicTypeVarFullyMatched = true;
                }
                else if (isParamVariadic && (0, types_1.isClassInstance)(argType) && (0, typeUtils_1.isTupleClass)(argType)) {
                    // Handle the case where an unpacked tuple argument is
                    // matched to a TypeVarTuple parameter.
                    isArgCompatibleWithVariadic = true;
                    advanceToNextArg = true;
                    // Determine whether we should treat the variadic type as fully matched.
                    // This depends on how many args and unmatched parameters exist.
                    if (remainingArgCount < remainingParamCount) {
                        isVariadicTypeVarFullyMatched = true;
                    }
                    listElementType = types_1.ClassType.cloneForUnpacked(argType);
                }
                else if ((0, types_1.isParamSpec)(argType) && argType.paramSpecAccess === 'args') {
                    listElementType = undefined;
                }
                else {
                    listElementType = (_f = getTypeOfIterator({ type: argType, isIncomplete: argTypeResult.isIncomplete }, 
                    /* isAsync */ false, errorNode, 
                    /* emitNotIterableError */ false)) === null || _f === void 0 ? void 0 : _f.type;
                    if (paramDetails.params[paramIndex].param.category !== 1 /* ParameterCategory.ArgsList */) {
                        matchedUnpackedListOfUnknownLength = true;
                    }
                }
                const funcArg = listElementType
                    ? {
                        argumentCategory: 0 /* ArgumentCategory.Simple */,
                        typeResult: { type: listElementType, isIncomplete: argTypeResult.isIncomplete },
                    }
                    : { ...argList[argIndex] };
                if (argTypeResult.isIncomplete) {
                    isTypeIncomplete = true;
                }
                // It's not allowed to use unpacked arguments with a variadic *args
                // parameter unless the argument is a variadic arg as well.
                if (isParamVariadic && !isArgCompatibleWithVariadic) {
                    if (!canSkipDiagnosticForNode(errorNode) && !isTypeIncomplete) {
                        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, localize_1.LocMessage.unpackedArgWithVariadicParam(), argList[argIndex].valueExpression || errorNode);
                    }
                    reportedArgError = true;
                }
                else {
                    if (paramSpecArgList) {
                        paramSpecArgList.push(argList[argIndex]);
                    }
                    if (funcArg) {
                        validateArgTypeParams.push({
                            paramCategory: paramDetails.params[paramIndex].param.category,
                            paramType,
                            requiresTypeVarMatching: (0, typeUtils_1.requiresSpecialization)(paramType),
                            argument: funcArg,
                            errorNode: (_g = argList[argIndex].valueExpression) !== null && _g !== void 0 ? _g : errorNode,
                            paramName,
                            isParamNameSynthesized: paramDetails.params[paramIndex].param.isNameSynthesized,
                            mapsToVarArgList: isParamVariadic && remainingArgCount > remainingParamCount,
                        });
                    }
                }
                trySetActive(argList[argIndex], paramDetails.params[paramIndex].param);
                // Note that the parameter has received an argument.
                if (paramName &&
                    paramDetails.params[paramIndex].param.category === 0 /* ParameterCategory.Simple */ &&
                    paramMap.has(paramName)) {
                    paramMap.get(paramName).argsReceived++;
                }
                if (advanceToNextArg || paramDetails.params[paramIndex].param.category === 1 /* ParameterCategory.ArgsList */) {
                    argIndex++;
                }
                if (isVariadicTypeVarFullyMatched ||
                    paramDetails.params[paramIndex].param.category !== 1 /* ParameterCategory.ArgsList */) {
                    paramIndex++;
                }
            }
            else if (paramDetails.params[paramIndex].param.category === 1 /* ParameterCategory.ArgsList */) {
                trySetActive(argList[argIndex], paramDetails.params[paramIndex].param);
                if (paramSpecArgList) {
                    paramSpecArgList.push(argList[argIndex]);
                    argIndex++;
                }
                else {
                    let paramCategory = paramDetails.params[paramIndex].param.category;
                    let effectiveParamType = paramType;
                    const paramName = paramDetails.params[paramIndex].param.name;
                    if ((0, types_1.isUnpackedClass)(paramType) &&
                        paramType.tupleTypeArguments &&
                        paramType.tupleTypeArguments.length > 0) {
                        effectiveParamType = paramType.tupleTypeArguments[0].type;
                    }
                    paramCategory = (0, types_1.isVariadicTypeVar)(effectiveParamType)
                        ? 1 /* ParameterCategory.ArgsList */
                        : 0 /* ParameterCategory.Simple */;
                    if (remainingArgCount <= remainingParamCount) {
                        if (remainingArgCount < remainingParamCount) {
                            if (!canSkipDiagnosticForNode(errorNode) && !isTypeIncomplete) {
                                // Have we run out of arguments and still have parameters left to fill?
                                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, remainingArgCount === 1
                                    ? localize_1.LocMessage.argMorePositionalExpectedOne()
                                    : localize_1.LocMessage.argMorePositionalExpectedCount().format({
                                        expected: remainingArgCount,
                                    }), argList[argIndex].valueExpression || errorNode);
                            }
                            reportedArgError = true;
                        }
                        paramIndex++;
                    }
                    else {
                        validateArgTypeParams.push({
                            paramCategory,
                            paramType: effectiveParamType,
                            requiresTypeVarMatching: (0, typeUtils_1.requiresSpecialization)(paramType),
                            argument: argList[argIndex],
                            errorNode: argList[argIndex].valueExpression || errorNode,
                            paramName,
                            isParamNameSynthesized: paramDetails.params[paramIndex].param.isNameSynthesized,
                            mapsToVarArgList: true,
                        });
                        argIndex++;
                    }
                }
            }
            else {
                const paramName = paramDetails.params[paramIndex].param.name;
                validateArgTypeParams.push({
                    paramCategory: paramDetails.params[paramIndex].param.category,
                    paramType,
                    requiresTypeVarMatching: (0, typeUtils_1.requiresSpecialization)(paramType),
                    argument: argList[argIndex],
                    errorNode: argList[argIndex].valueExpression || errorNode,
                    paramName,
                    isParamNameSynthesized: paramDetails.params[paramIndex].param.isNameSynthesized,
                });
                trySetActive(argList[argIndex], paramDetails.params[paramIndex].param);
                // Note that the parameter has received an argument.
                if (paramName && paramMap.has(paramName)) {
                    paramMap.get(paramName).argsReceived++;
                }
                argIndex++;
                paramIndex++;
            }
        }
        // If there weren't enough positional arguments to populate all of the
        // positional-only parameters and the next positional-only parameter is
        // an unbounded tuple, skip past it.
        let skippedArgsParam = false;
        if (positionalOnlyLimitIndex >= 0 &&
            paramIndex < positionalOnlyLimitIndex &&
            paramIndex < paramDetails.params.length &&
            paramDetails.params[paramIndex].param.category === 1 /* ParameterCategory.ArgsList */ &&
            !(0, types_1.isParamSpec)(paramDetails.params[paramIndex].param.type)) {
            paramIndex++;
            skippedArgsParam = true;
        }
        // Check if there weren't enough positional arguments to populate all of
        // the positional-only parameters.
        if (positionalOnlyLimitIndex >= 0 &&
            paramIndex < positionalOnlyLimitIndex &&
            (!foundUnpackedListArg || hasParamSpecArgsKwargs)) {
            const firstParamWithDefault = paramDetails.params.findIndex((paramInfo) => paramInfo.param.hasDefault);
            const positionOnlyWithoutDefaultsCount = firstParamWithDefault >= 0 && firstParamWithDefault < positionalOnlyLimitIndex
                ? firstParamWithDefault
                : positionalOnlyLimitIndex;
            // Calculate the number of remaining positional parameters to report.
            let argsRemainingCount = positionOnlyWithoutDefaultsCount - positionalArgCount;
            if (skippedArgsParam) {
                // If we skipped an args parameter above, reduce the count by one
                // because it's permitted to pass zero arguments to *args.
                argsRemainingCount--;
            }
            const firstArgsParam = paramDetails.params.findIndex((paramInfo) => paramInfo.param.category === 1 /* ParameterCategory.ArgsList */ && !(0, types_1.isParamSpec)(paramInfo.param.type));
            if (firstArgsParam >= paramIndex && firstArgsParam < positionalOnlyLimitIndex) {
                // If there is another args parameter beyond the current param index,
                // reduce the count by one because it's permitted to pass zero arguments
                // to *args.
                argsRemainingCount--;
            }
            if (argsRemainingCount > 0) {
                if (!canSkipDiagnosticForNode(errorNode) && !isTypeIncomplete) {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, argsRemainingCount === 1
                        ? localize_1.LocMessage.argMorePositionalExpectedOne()
                        : localize_1.LocMessage.argMorePositionalExpectedCount().format({
                            expected: argsRemainingCount,
                        }), argList.length > positionalArgCount
                        ? argList[positionalArgCount].valueExpression || errorNode
                        : errorNode);
                }
                reportedArgError = true;
            }
        }
        if (!reportedArgError) {
            let unpackedDictionaryArgType;
            // Now consume any keyword arguments.
            while (argIndex < argList.length) {
                if (argList[argIndex].argumentCategory === 2 /* ArgumentCategory.UnpackedDictionary */) {
                    // Verify that the type used in this expression is a SupportsKeysAndGetItem[str, T].
                    const argTypeResult = getTypeOfArgument(argList[argIndex], (0, typeUtils_1.makeInferenceContext)(paramDetails.unpackedKwargsTypedDictType), signatureTracker);
                    const argType = argTypeResult.type;
                    if (argTypeResult.isIncomplete) {
                        isTypeIncomplete = true;
                    }
                    if ((0, types_1.isAnyOrUnknown)(argType)) {
                        unpackedDictionaryArgType = argType;
                    }
                    else if ((0, types_1.isClassInstance)(argType) && types_1.ClassType.isTypedDictClass(argType)) {
                        // Handle the special case where it is a TypedDict and we know which
                        // keys are present.
                        const typedDictEntries = (0, typedDicts_1.getTypedDictMembersForClass)(evaluatorInterface, argType);
                        const diag = new diagnostic_1.DiagnosticAddendum();
                        typedDictEntries.knownItems.forEach((entry, name) => {
                            const paramEntry = paramMap.get(name);
                            if (paramEntry && !paramEntry.isPositionalOnly) {
                                if (paramEntry.argsReceived > 0) {
                                    diag.addMessage(localize_1.LocMessage.paramAlreadyAssigned().format({ name }));
                                }
                                else {
                                    paramEntry.argsReceived++;
                                    const paramInfoIndex = paramDetails.params.findIndex((paramInfo) => paramInfo.param.name === name);
                                    (0, debug_1.assert)(paramInfoIndex >= 0);
                                    const paramType = paramDetails.params[paramInfoIndex].type;
                                    validateArgTypeParams.push({
                                        paramCategory: 0 /* ParameterCategory.Simple */,
                                        paramType,
                                        requiresTypeVarMatching: (0, typeUtils_1.requiresSpecialization)(paramType),
                                        argument: {
                                            argumentCategory: 0 /* ArgumentCategory.Simple */,
                                            typeResult: { type: entry.valueType },
                                        },
                                        errorNode: argList[argIndex].valueExpression || errorNode,
                                        paramName: name,
                                    });
                                }
                            }
                            else if (paramDetails.kwargsIndex !== undefined) {
                                const paramType = paramDetails.params[paramDetails.kwargsIndex].type;
                                validateArgTypeParams.push({
                                    paramCategory: 2 /* ParameterCategory.KwargsDict */,
                                    paramType,
                                    requiresTypeVarMatching: (0, typeUtils_1.requiresSpecialization)(paramType),
                                    argument: {
                                        argumentCategory: 0 /* ArgumentCategory.Simple */,
                                        typeResult: { type: entry.valueType },
                                    },
                                    errorNode: argList[argIndex].valueExpression || errorNode,
                                    paramName: name,
                                });
                                // Remember that this parameter has already received a value.
                                paramMap.set(name, {
                                    argsNeeded: 1,
                                    argsReceived: 1,
                                    isPositionalOnly: false,
                                });
                            }
                            else {
                                // If the function doesn't have a **kwargs parameter, we need to emit an error.
                                // However, it's possible that there was a **kwargs but it was eliminated by
                                // getParameterListDetails because it was associated with an unpacked TypedDict.
                                // In this case, we can skip the error.
                                if (!paramDetails.hasUnpackedTypedDict) {
                                    diag.addMessage(localize_1.LocMessage.paramNameMissing().format({ name }));
                                }
                            }
                        });
                        if (!diag.isEmpty()) {
                            if (!canSkipDiagnosticForNode(errorNode) && !isTypeIncomplete) {
                                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, localize_1.LocMessage.unpackedTypedDictArgument() + diag.getString(), argList[argIndex].valueExpression || errorNode);
                            }
                            reportedArgError = true;
                        }
                    }
                    else if (paramSpec && (0, parameterUtils_1.isParamSpecKwargsArgument)(paramSpec, argType)) {
                        unpackedDictionaryArgType = types_1.AnyType.create();
                        if (!paramSpecArgList) {
                            validateArgTypeParams.push({
                                paramCategory: 2 /* ParameterCategory.KwargsDict */,
                                paramType: paramSpec,
                                requiresTypeVarMatching: false,
                                argument: argList[argIndex],
                                argType: (0, types_1.isParamSpec)(argType) ? undefined : types_1.AnyType.create(),
                                errorNode: argList[argIndex].valueExpression || errorNode,
                            });
                        }
                    }
                    else {
                        const strObjType = getBuiltInObject(errorNode, 'str');
                        if (supportsKeysAndGetItemClass &&
                            (0, types_1.isInstantiableClass)(supportsKeysAndGetItemClass) &&
                            strObjType &&
                            (0, types_1.isClassInstance)(strObjType)) {
                            const mappingTypeVarContext = new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(supportsKeysAndGetItemClass));
                            let isValidMappingType = false;
                            // If this was a TypeVar (e.g. for pseudo-generic classes),
                            // don't emit this error.
                            if ((0, types_1.isTypeVar)(argType)) {
                                isValidMappingType = true;
                            }
                            else if (assignType(types_1.ClassType.cloneAsInstance(supportsKeysAndGetItemClass), argType, 
                            /* diag */ undefined, mappingTypeVarContext)) {
                                const specializedMapping = (0, typeUtils_1.applySolvedTypeVars)(supportsKeysAndGetItemClass, mappingTypeVarContext);
                                const typeArgs = specializedMapping.typeArguments;
                                if (typeArgs && typeArgs.length >= 2) {
                                    if (assignType(strObjType, typeArgs[0])) {
                                        isValidMappingType = true;
                                    }
                                    unpackedDictionaryArgType = typeArgs[1];
                                }
                                else {
                                    isValidMappingType = true;
                                    unpackedDictionaryArgType = types_1.UnknownType.create();
                                }
                            }
                            if (paramDetails.kwargsIndex !== undefined && unpackedDictionaryArgType) {
                                const paramType = paramDetails.params[paramDetails.kwargsIndex].type;
                                validateArgTypeParams.push({
                                    paramCategory: 0 /* ParameterCategory.Simple */,
                                    paramType,
                                    requiresTypeVarMatching: (0, typeUtils_1.requiresSpecialization)(paramType),
                                    argType: unpackedDictionaryArgType,
                                    argument: argList[argIndex],
                                    errorNode: argList[argIndex].valueExpression || errorNode,
                                    paramName: paramDetails.params[paramDetails.kwargsIndex].param.name,
                                });
                            }
                            if (!isValidMappingType) {
                                if (!canSkipDiagnosticForNode(errorNode) && !isTypeIncomplete) {
                                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, localize_1.LocMessage.unpackedDictArgumentNotMapping(), argList[argIndex].valueExpression || errorNode);
                                }
                                reportedArgError = true;
                            }
                        }
                    }
                    if (paramSpecArgList) {
                        paramSpecArgList.push(argList[argIndex]);
                    }
                }
                else {
                    // Protect against the case where a non-keyword argument appears after
                    // a keyword argument. This will have already been reported as a parse
                    // error, but we need to protect against it here.
                    const paramName = argList[argIndex].name;
                    if (paramName) {
                        const paramNameValue = paramName.value;
                        const paramEntry = paramMap.get(paramNameValue);
                        if (paramEntry && !paramEntry.isPositionalOnly) {
                            if (paramEntry.argsReceived > 0) {
                                if (!canSkipDiagnosticForNode(errorNode) && !isTypeIncomplete) {
                                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, localize_1.LocMessage.paramAlreadyAssigned().format({ name: paramNameValue }), paramName);
                                }
                                reportedArgError = true;
                            }
                            else {
                                paramEntry.argsReceived++;
                                const paramInfoIndex = paramDetails.params.findIndex((paramInfo) => paramInfo.param.name === paramNameValue);
                                (0, debug_1.assert)(paramInfoIndex >= 0);
                                const paramType = paramDetails.params[paramInfoIndex].type;
                                validateArgTypeParams.push({
                                    paramCategory: 0 /* ParameterCategory.Simple */,
                                    paramType,
                                    requiresTypeVarMatching: (0, typeUtils_1.requiresSpecialization)(paramType),
                                    argument: argList[argIndex],
                                    errorNode: (_h = argList[argIndex].valueExpression) !== null && _h !== void 0 ? _h : errorNode,
                                    paramName: paramNameValue,
                                });
                                trySetActive(argList[argIndex], paramDetails.params[paramInfoIndex].param);
                            }
                        }
                        else if (paramSpecArgList) {
                            paramSpecArgList.push(argList[argIndex]);
                        }
                        else if (paramDetails.kwargsIndex !== undefined) {
                            const paramType = paramDetails.params[paramDetails.kwargsIndex].type;
                            if ((0, types_1.isParamSpec)(paramType)) {
                                if (!canSkipDiagnosticForNode(errorNode) && !isTypeIncomplete) {
                                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, localize_1.LocMessage.paramNameMissing().format({ name: paramName.value }), paramName);
                                }
                                reportedArgError = true;
                            }
                            else {
                                validateArgTypeParams.push({
                                    paramCategory: 2 /* ParameterCategory.KwargsDict */,
                                    paramType,
                                    requiresTypeVarMatching: (0, typeUtils_1.requiresSpecialization)(paramType),
                                    argument: argList[argIndex],
                                    errorNode: (_j = argList[argIndex].valueExpression) !== null && _j !== void 0 ? _j : errorNode,
                                    paramName: paramNameValue,
                                });
                                // Remember that this parameter has already received a value.
                                paramMap.set(paramNameValue, {
                                    argsNeeded: 1,
                                    argsReceived: 1,
                                    isPositionalOnly: false,
                                });
                                (0, debug_1.assert)(paramDetails.params[paramDetails.kwargsIndex], 'paramDetails.kwargsIndex params entry is undefined');
                            }
                            trySetActive(argList[argIndex], paramDetails.params[paramDetails.kwargsIndex].param);
                        }
                        else {
                            if (!canSkipDiagnosticForNode(errorNode) && !isTypeIncomplete) {
                                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, localize_1.LocMessage.paramNameMissing().format({ name: paramName.value }), paramName);
                            }
                            reportedArgError = true;
                        }
                    }
                    else if (argList[argIndex].argumentCategory === 0 /* ArgumentCategory.Simple */) {
                        if (paramSpecArgList) {
                            paramSpecArgList.push(argList[argIndex]);
                        }
                        else {
                            if (!canSkipDiagnosticForNode(errorNode) && !isTypeIncomplete) {
                                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, positionParamLimitIndex === 1
                                    ? localize_1.LocMessage.argPositionalExpectedOne()
                                    : localize_1.LocMessage.argPositionalExpectedCount().format({
                                        expected: positionParamLimitIndex,
                                    }), argList[argIndex].valueExpression || errorNode);
                            }
                            reportedArgError = true;
                        }
                    }
                    else if (argList[argIndex].argumentCategory === 1 /* ArgumentCategory.UnpackedList */) {
                        // Handle the case where a *args: P.args (or *args: Any) is passed as an
                        // argument to a function that accepts a ParamSpec.
                        if (paramSpec) {
                            const argTypeResult = getTypeOfArgument(argList[argIndex], 
                            /* inferenceContext */ undefined, signatureTracker);
                            const argType = argTypeResult.type;
                            if (argTypeResult.isIncomplete) {
                                isTypeIncomplete = true;
                            }
                            if ((0, parameterUtils_1.isParamSpecArgsArgument)(paramSpec, argType)) {
                                validateArgTypeParams.push({
                                    paramCategory: 1 /* ParameterCategory.ArgsList */,
                                    paramType: paramSpec,
                                    requiresTypeVarMatching: false,
                                    argument: argList[argIndex],
                                    argType: (0, types_1.isParamSpec)(argType) ? undefined : types_1.AnyType.create(),
                                    errorNode: (_k = argList[argIndex].valueExpression) !== null && _k !== void 0 ? _k : errorNode,
                                });
                            }
                        }
                    }
                }
                argIndex++;
            }
            // If there are keyword-only parameters that haven't been matched but we
            // have an unpacked dictionary arg, assume that it applies to them.
            if (unpackedDictionaryArgType && (!foundUnpackedListArg || paramDetails.argsIndex !== undefined)) {
                // Don't consider any position-only parameters, since they cannot be matched to
                // **kwargs arguments. Consider parameters that are either positional or keyword
                // if there is no *args argument.
                paramDetails.params.forEach((paramInfo, paramIndex) => {
                    var _a, _b;
                    const param = paramInfo.param;
                    if (paramIndex >= paramDetails.firstPositionOrKeywordIndex &&
                        param.category === 0 /* ParameterCategory.Simple */ &&
                        param.name &&
                        paramMap.has(param.name) &&
                        paramMap.get(param.name).argsReceived === 0) {
                        const paramType = paramDetails.params[paramIndex].type;
                        validateArgTypeParams.push({
                            paramCategory: 0 /* ParameterCategory.Simple */,
                            paramType,
                            requiresTypeVarMatching: (0, typeUtils_1.requiresSpecialization)(paramType),
                            argument: {
                                argumentCategory: 0 /* ArgumentCategory.Simple */,
                                typeResult: { type: unpackedDictionaryArgType },
                            },
                            errorNode: (_b = (_a = argList.find((arg) => arg.argumentCategory === 2 /* ArgumentCategory.UnpackedDictionary */)) === null || _a === void 0 ? void 0 : _a.valueExpression) !== null && _b !== void 0 ? _b : errorNode,
                            paramName: param.name,
                            isParamNameSynthesized: param.isNameSynthesized,
                        });
                        paramMap.get(param.name).argsReceived = 1;
                    }
                });
            }
            // Determine whether there are any parameters that require arguments
            // but have not yet received them. If we received a dictionary argument
            // (i.e. an arg starting with a "**"), we will assume that all parameters
            // are matched.
            if (!unpackedDictionaryArgType && !types_1.FunctionType.isDefaultParameterCheckDisabled(overload)) {
                const unassignedParams = Array.from(paramMap.keys()).filter((name) => {
                    const entry = paramMap.get(name);
                    return !entry || entry.argsReceived < entry.argsNeeded;
                });
                if (unassignedParams.length > 0) {
                    if (!canSkipDiagnosticForNode(errorNode)) {
                        const missingParamNames = unassignedParams.map((p) => `"${p}"`).join(', ');
                        if (!canSkipDiagnosticForNode(errorNode) && !isTypeIncomplete) {
                            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, unassignedParams.length === 1
                                ? localize_1.LocMessage.argMissingForParam().format({ name: missingParamNames })
                                : localize_1.LocMessage.argMissingForParams().format({ names: missingParamNames }), errorNode);
                        }
                    }
                    reportedArgError = true;
                }
                // Add any implicit (default) arguments that are needed for resolving
                // generic types. For example, if the function is defined as
                // def foo(v1: _T = 'default')
                // and _T is a TypeVar, we need to match the TypeVar to the default
                // value's type if it's not provided by the caller.
                paramDetails.params.forEach((paramInfo) => {
                    var _a;
                    const param = paramInfo.param;
                    if (param.category === 0 /* ParameterCategory.Simple */ && param.name) {
                        const entry = paramMap.get(param.name);
                        if (entry.argsNeeded === 0 && entry.argsReceived === 0) {
                            const defaultArgType = (_a = paramInfo.defaultArgType) !== null && _a !== void 0 ? _a : param.defaultType;
                            if (defaultArgType &&
                                !(0, typeUtils_1.isEllipsisType)(defaultArgType) &&
                                (0, typeUtils_1.requiresSpecialization)(param.type)) {
                                validateArgTypeParams.push({
                                    paramCategory: param.category,
                                    paramType: paramInfo.type,
                                    requiresTypeVarMatching: true,
                                    argument: {
                                        argumentCategory: 0 /* ArgumentCategory.Simple */,
                                        typeResult: { type: defaultArgType },
                                    },
                                    isDefaultArg: true,
                                    errorNode,
                                    paramName: param.name,
                                    isParamNameSynthesized: param.isNameSynthesized,
                                });
                            }
                        }
                    }
                });
            }
        }
        // If we're in speculative mode and an arg/param mismatch has already been reported, don't
        // bother doing the extra work here. This occurs frequently when attempting to find the
        // correct overload.
        if (!reportedArgError || !isSpeculativeModeInUse(undefined)) {
            // If there are arguments that map to a variadic *args parameter that hasn't
            // already been matched, see if the type of that *args parameter is a variadic
            // type variable. If so, we'll preprocess those arguments and combine them
            // into a tuple.
            (0, debug_1.assert)(paramDetails.argsIndex === undefined || paramDetails.argsIndex < paramDetails.params.length, 'paramDetails.argsIndex params entry is invalid');
            if (paramDetails.argsIndex !== undefined &&
                paramDetails.argsIndex >= 0 &&
                paramDetails.params[paramDetails.argsIndex].param.hasDeclaredType &&
                !isVariadicTypeVarFullyMatched) {
                const paramType = paramDetails.params[paramDetails.argsIndex].type;
                const variadicArgs = validateArgTypeParams.filter((argParam) => argParam.mapsToVarArgList);
                if ((0, types_1.isVariadicTypeVar)(paramType) && !paramType.isVariadicInUnion) {
                    const tupleTypeArgs = variadicArgs.map((argParam) => {
                        var _a;
                        const argType = getTypeOfArgument(argParam.argument, 
                        /* inferenceContext */ undefined, signatureTracker).type;
                        const containsVariadicTypeVar = (0, types_1.isUnpackedVariadicTypeVar)(argType) ||
                            ((0, types_1.isClassInstance)(argType) &&
                                (0, typeUtils_1.isTupleClass)(argType) &&
                                argType.tupleTypeArguments &&
                                argType.tupleTypeArguments.length === 1 &&
                                (0, types_1.isUnpackedVariadicTypeVar)(argType.tupleTypeArguments[0].type));
                        if (containsVariadicTypeVar &&
                            argParam.argument.argumentCategory !== 1 /* ArgumentCategory.UnpackedList */ &&
                            !argParam.mapsToVarArgList) {
                            if (!canSkipDiagnosticForNode(errorNode) && !isTypeIncomplete) {
                                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, localize_1.LocMessage.typeVarTupleMustBeUnpacked(), (_a = argParam.argument.valueExpression) !== null && _a !== void 0 ? _a : errorNode);
                            }
                            reportedArgError = true;
                        }
                        return {
                            type: argType,
                            isUnbounded: argParam.argument.argumentCategory === 1 /* ArgumentCategory.UnpackedList */,
                        };
                    });
                    let specializedTuple;
                    if (tupleTypeArgs.length === 1 &&
                        !tupleTypeArgs[0].isUnbounded &&
                        ((0, types_1.isUnpackedClass)(tupleTypeArgs[0].type) || (0, types_1.isVariadicTypeVar)(tupleTypeArgs[0].type))) {
                        // If there is a single unpacked tuple or unpacked variadic type variable
                        // (including an unpacked TypeVarTuple union) within this tuple,
                        // simplify the type.
                        specializedTuple = tupleTypeArgs[0].type;
                    }
                    else {
                        specializedTuple = makeTupleObject(tupleTypeArgs, /* isUnpackedTuple */ true);
                    }
                    const combinedArg = {
                        paramCategory: 1 /* ParameterCategory.ArgsList */,
                        paramType,
                        requiresTypeVarMatching: true,
                        argument: {
                            argumentCategory: 0 /* ArgumentCategory.Simple */,
                            typeResult: { type: specializedTuple },
                        },
                        errorNode,
                        paramName: paramDetails.params[paramDetails.argsIndex].param.name,
                        isParamNameSynthesized: paramDetails.params[paramDetails.argsIndex].param.isNameSynthesized,
                        mapsToVarArgList: true,
                    };
                    validateArgTypeParams = [
                        ...validateArgTypeParams.filter((argParam) => !argParam.mapsToVarArgList),
                        combinedArg,
                    ];
                }
            }
        }
        let relevance = 0;
        if (matchedUnpackedListOfUnknownLength) {
            // Lower the relevance if we made assumptions about the length
            // of an unpacked argument. This will favor overloads that
            // associate this case with a *args parameter.
            relevance--;
        }
        // Special-case the builtin isinstance and issubclass functions.
        if (['isinstance', 'issubclass'].some((name) => name === overload.details.builtInName) &&
            validateArgTypeParams.length === 2) {
            validateArgTypeParams[1].isinstanceParam = true;
        }
        return {
            overload,
            overloadIndex,
            argumentErrors: reportedArgError,
            isTypeIncomplete,
            argParams: validateArgTypeParams,
            paramSpecTarget,
            paramSpecArgList,
            activeParam,
            relevance,
            argumentMatchScore: 0,
        };
    }
    // After having matched arguments with parameters, this function evaluates the
    // types of each argument expression and validates that the resulting type is
    // compatible with the declared type of the corresponding parameter.
    function validateArgTypesWithContext(errorNode, matchResults, typeVarContext, skipUnknownArgCheck = false, inferenceContext, signatureTracker) {
        const type = matchResults.overload;
        if (!signatureTracker) {
            signatureTracker = new typeUtils_1.UniqueSignatureTracker();
        }
        matchResults.overload = (0, typeUtils_1.ensureFunctionSignaturesAreUnique)(matchResults.overload, signatureTracker, errorNode.start);
        const returnType = getFunctionEffectiveReturnType(type);
        let expectedType = inferenceContext === null || inferenceContext === void 0 ? void 0 : inferenceContext.expectedType;
        // If the expected type is a union, we don't know which type is expected.
        // We may or may not be able to make use of the expected type. We'll evaluate
        // speculatively to see if using the expected type works.
        if (expectedType && (0, types_1.isUnion)(expectedType)) {
            let assignFlags = 2048 /* AssignTypeFlags.PopulatingExpectedType */;
            if ((0, typeUtils_1.containsLiteralType)(expectedType, /* includeTypeArgs */ true)) {
                assignFlags |= 256 /* AssignTypeFlags.RetainLiteralsForTypeVar */;
            }
            useSpeculativeMode(errorNode, () => {
                const typeVarContextCopy = typeVarContext.clone();
                assignType(returnType, expectedType, 
                /* diag */ undefined, typeVarContextCopy, 
                /* srcTypeVarContext */ undefined, assignFlags);
                const speculativeResults = validateArgTypes(errorNode, matchResults, typeVarContextCopy, signatureTracker, skipUnknownArgCheck);
                if (speculativeResults === null || speculativeResults === void 0 ? void 0 : speculativeResults.argumentErrors) {
                    expectedType = undefined;
                }
            });
        }
        if (expectedType) {
            if ((0, types_1.isAnyOrUnknown)(expectedType) || (0, types_1.isNever)(expectedType)) {
                expectedType = undefined;
            }
        }
        // Can we safely ignore the inference context, either because it's not provided
        // or will have no effect? If so, we can eliminate some extra work.
        if (!expectedType || !returnType || !(0, typeUtils_1.requiresSpecialization)(returnType)) {
            return validateArgTypes(errorNode, matchResults, typeVarContext, signatureTracker, skipUnknownArgCheck);
        }
        return validateArgTypesWithExpectedType(errorNode, matchResults, typeVarContext, skipUnknownArgCheck, expectedType, returnType, signatureTracker);
    }
    function validateArgTypesWithExpectedType(errorNode, matchResults, typeVarContext, skipUnknownArgCheck = false, expectedType, returnType, signatureTracker) {
        const liveTypeVarScopes = ParseTreeUtils.getTypeVarScopesForNode(errorNode);
        let assignFlags = 2048 /* AssignTypeFlags.PopulatingExpectedType */;
        if ((0, typeUtils_1.containsLiteralType)(expectedType, /* includeTypeArgs */ true)) {
            assignFlags |= 256 /* AssignTypeFlags.RetainLiteralsForTypeVar */;
        }
        // Prepopulate the typeVarContext based on the specialized expected type if the
        // callee has a declared return type. This will allow us to more closely match
        // the expected type if possible.
        // Determine which type arguments are needed to match the expected type.
        if ((0, types_1.isClassInstance)(returnType)) {
            // If the return type is a class and the expected type is a union
            // that is type compatible with that class, filter the subtypes in
            // the union to see if we can find one that is potentially compatible.
            if ((0, types_1.isUnion)(expectedType)) {
                const filteredType = (0, typeUtils_1.mapSubtypes)(expectedType, (subtype) => {
                    if (!(0, types_1.isClassInstance)(subtype) || subtype.details.typeParameters.length === 0) {
                        return undefined;
                    }
                    if (types_1.ClassType.isProtocolClass(subtype) ||
                        subtype.details.mro.some((mroClass) => {
                            return ((0, types_1.isClassInstance)(mroClass) &&
                                mroClass.details.typeParameters.length > 0 &&
                                types_1.ClassType.isSameGenericClass(returnType, mroClass));
                        })) {
                        return subtype;
                    }
                    return undefined;
                }, 
                /* sortSubtypes */ true);
                if ((0, types_1.isClassInstance)(filteredType)) {
                    expectedType = filteredType;
                }
            }
            if ((0, types_1.isClassInstance)(expectedType) && !(0, types_1.isTypeSame)(returnType, expectedType)) {
                const tempTypeVarContext = new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(returnType));
                if ((0, constraintSolver_1.addConstraintsForExpectedType)(evaluatorInterface, returnType, expectedType, tempTypeVarContext, liveTypeVarScopes, errorNode.start)) {
                    const genericReturnType = types_1.ClassType.cloneForSpecialization(returnType, 
                    /* typeArguments */ undefined, 
                    /* isTypeArgumentExplicit */ false);
                    expectedType = (0, typeUtils_1.applySolvedTypeVars)(genericReturnType, tempTypeVarContext, {
                        unknownIfNotFound: true,
                        tupleClassType: getTupleClassType(),
                    });
                    assignFlags |= 4096 /* AssignTypeFlags.SkipPopulateUnknownExpectedType */;
                }
            }
        }
        else if ((0, types_1.isFunction)(returnType)) {
            // If the return type is a callable and the expected type is a union that
            // includes one or more non-callables, filter those out.
            if ((0, types_1.isUnion)(expectedType)) {
                expectedType = (0, typeUtils_1.mapSubtypes)(expectedType, (subtype) => {
                    return (0, typeUtils_1.isCallableType)(subtype) ? subtype : undefined;
                });
            }
        }
        expectedType = (0, typeUtils_1.transformExpectedType)(expectedType, liveTypeVarScopes, errorNode.start);
        assignType(returnType, expectedType, 
        /* diag */ undefined, typeVarContext, 
        /* srcTypeVarContext */ undefined, assignFlags);
        return validateArgTypes(errorNode, matchResults, typeVarContext, signatureTracker, skipUnknownArgCheck);
    }
    function validateArgTypes(errorNode, matchResults, typeVarContext, signatureTracker, skipUnknownArgCheck) {
        const type = matchResults.overload;
        let isTypeIncomplete = matchResults.isTypeIncomplete;
        let argumentErrors = false;
        let argumentMatchScore = 0;
        let specializedInitSelfType;
        let anyOrUnknownArgument;
        const typeCondition = (0, typeUtils_1.getTypeCondition)(type);
        const paramSpec = types_1.FunctionType.getParamSpecFromArgsKwargs(type);
        // Check for an attempt to invoke an unimplemented abstract method.
        if (type.boundToType && !type.boundToType.includeSubclasses && type.details.methodClass) {
            const abstractSymbolInfo = getAbstractSymbolInfo(type.details.methodClass, type.details.name);
            if (abstractSymbolInfo && !abstractSymbolInfo.hasImplementation) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportAbstractUsage, localize_1.LocMessage.abstractMethodInvocation().format({
                    method: type.details.name,
                }), errorNode.nodeType === 9 /* ParseNodeType.Call */ ? errorNode.leftExpression : errorNode);
            }
        }
        // The type annotation for the "self" parameter in an __init__ method to
        // can influence the type being constructed.
        if (type.details.name === '__init__' &&
            type.strippedFirstParamType &&
            type.boundToType &&
            (0, types_1.isClassInstance)(type.strippedFirstParamType) &&
            (0, types_1.isClassInstance)(type.boundToType) &&
            types_1.ClassType.isSameGenericClass(type.strippedFirstParamType, type.boundToType) &&
            type.strippedFirstParamType.typeArguments) {
            const typeParams = type.strippedFirstParamType.details.typeParameters;
            specializedInitSelfType = type.strippedFirstParamType;
            type.strippedFirstParamType.typeArguments.forEach((typeArg, index) => {
                if (index < typeParams.length) {
                    const typeParam = typeParams[index];
                    if (!(0, types_1.isTypeSame)(typeParam, typeArg, { ignorePseudoGeneric: true })) {
                        typeVarContext.setTypeVarType(typeParams[index], typeArg);
                    }
                }
            });
        }
        // Special-case a few built-in calls that are often used for
        // casting or checking for unknown types.
        if (['cast', 'isinstance', 'issubclass'].some((name) => name === type.details.builtInName)) {
            skipUnknownArgCheck = true;
        }
        // Run through all args and validate them against their matched parameter.
        // We'll do two passes. The first one will match any type arguments. The second
        // will perform the actual validation. We can skip the first pass if there
        // are no type vars to match.
        const typeVarMatchingCount = matchResults.argParams.filter((arg) => arg.requiresTypeVarMatching).length;
        if (typeVarMatchingCount > 0) {
            // In theory, we may need to do up to n passes where n is the number of
            // arguments that need type var matching. That's because later matches
            // can provide bidirectional type hints for earlier matches. The best
            // example of this is the built-in "map" method whose first parameter is
            // a lambda and second parameter indicates what type the lambda should accept.
            // In practice, we will limit the number of passes to 2 because it can get
            // very expensive to go beyond this, and we don't generally see cases
            // where more than two passes are needed.
            let passCount = Math.min(typeVarMatchingCount, 2);
            for (let i = 0; i < passCount; i++) {
                useSpeculativeMode(errorNode, () => {
                    matchResults.argParams.forEach((argParam) => {
                        if (!argParam.requiresTypeVarMatching) {
                            return;
                        }
                        // Populate the typeVarContext for the argument. If the argument
                        // is an overload function, skip it during the first pass
                        // because the selection of the proper overload may depend
                        // on type arguments supplied by other function arguments.
                        // We set useNarrowBoundOnly to true if this is the first
                        // (but not only) pass through the parameter list because a wide
                        // bound on a TypeVar (if a narrow bound has not yet been
                        // established) will unnecessarily constrain the expected type.
                        // If the param type is a "bare" TypeVar, don't use it as an
                        // expected type during the first pass. This causes problems for
                        // cases where the the call expression result can influence the
                        // type of the TypeVar, such as in the expression "min(1, max(2, 0.5))".
                        const argResult = validateArgType(argParam, typeVarContext, signatureTracker, { type, isIncomplete: matchResults.isTypeIncomplete }, {
                            skipUnknownArgCheck,
                            skipOverloadArg: i === 0,
                            skipBareTypeVarExpectedType: i === 0,
                            useNarrowBoundOnly: passCount > 1 && i === 0,
                            conditionFilter: typeCondition,
                        });
                        if (argResult.isTypeIncomplete) {
                            isTypeIncomplete = true;
                        }
                        // If we skipped an overload arg or a bare type var during the first pass,
                        // add another pass to ensure that we handle all of the type variables.
                        if (i === 0 && (argResult.skippedOverloadArg || argResult.skippedBareTypeVarExpectedType)) {
                            passCount++;
                        }
                    });
                });
            }
            // Lock the type var map so it cannot be modified when revalidating
            // the arguments in a second pass.
            typeVarContext.lock();
        }
        let sawParamSpecArgs = false;
        let sawParamSpecKwargs = false;
        let condition = [];
        const argResults = [];
        matchResults.argParams.forEach((argParam, argParamIndex) => {
            var _a;
            const argResult = validateArgType(argParam, typeVarContext, signatureTracker, { type, isIncomplete: matchResults.isTypeIncomplete }, {
                skipUnknownArgCheck,
                conditionFilter: typeCondition,
            });
            argResults.push(argResult);
            if (!argResult.isCompatible) {
                argumentErrors = true;
                // Add the inverse index so earlier parameters represent larger errors.
                // This will help the heuristics in the overload error paths to pick the
                // most likely intended overload if none of them match.
                argumentMatchScore += 1 + (matchResults.argParams.length - argParamIndex);
            }
            if (argResult.isTypeIncomplete) {
                isTypeIncomplete = true;
            }
            if (argResult.condition) {
                condition = (_a = types_1.TypeCondition.combine(condition, argResult.condition)) !== null && _a !== void 0 ? _a : [];
            }
            if ((0, types_1.isAnyOrUnknown)(argResult.argType)) {
                anyOrUnknownArgument = anyOrUnknownArgument
                    ? (0, typeUtils_1.preserveUnknown)(argResult.argType, anyOrUnknownArgument)
                    : argResult.argType;
            }
            if (paramSpec) {
                if (argParam.argument.argumentCategory === 1 /* ArgumentCategory.UnpackedList */) {
                    if ((0, parameterUtils_1.isParamSpecArgsArgument)(paramSpec, argResult.argType)) {
                        sawParamSpecArgs = true;
                    }
                }
                if (argParam.argument.argumentCategory === 2 /* ArgumentCategory.UnpackedDictionary */) {
                    if ((0, parameterUtils_1.isParamSpecKwargsArgument)(paramSpec, argResult.argType)) {
                        sawParamSpecKwargs = true;
                    }
                }
            }
        });
        let paramSpecTypeVarContext = [];
        // Handle the assignment of additional arguments that map to a param spec.
        if (matchResults.paramSpecArgList && matchResults.paramSpecTarget) {
            const paramSpecArgResult = validateArgTypesForParamSpec(errorNode, matchResults.paramSpecArgList, matchResults.paramSpecTarget, typeVarContext, signatureTracker);
            if (paramSpecArgResult.argumentErrors) {
                argumentErrors = true;
                argumentMatchScore += 1;
            }
            paramSpecTypeVarContext = paramSpecArgResult.typeVarContexts;
        }
        else if (paramSpec) {
            if (!sawParamSpecArgs || !sawParamSpecKwargs) {
                if (!isTypeIncomplete) {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, localize_1.LocMessage.paramSpecArgsMissing().format({ type: printType(paramSpec) }), errorNode);
                }
                argumentErrors = true;
                argumentMatchScore += 1;
            }
        }
        // Calculate the return type.
        let returnType = getFunctionEffectiveReturnType(type, { args: matchResults.argParams, errorNode });
        if (condition.length > 0) {
            returnType = types_1.TypeBase.cloneForCondition(returnType, condition);
        }
        // Determine whether the expression being evaluated is within the current TypeVar
        // scope. If not, then the expression is invoking a function in another scope,
        // and we should eliminate unsolved type variables from union types that appear
        // in the return type. If we're within the same scope, we should retain these
        // extra type variables because they are still potentially relevant within this
        // scope.
        let eliminateUnsolvedInUnions = true;
        let curNode = errorNode;
        while (curNode) {
            const typeVarScopeNode = ParseTreeUtils.getTypeVarScopeNode(curNode);
            if (!typeVarScopeNode) {
                break;
            }
            const typeVarScopeId = ParseTreeUtils.getScopeIdForNode(typeVarScopeNode);
            if (typeVarContext.hasSolveForScope(typeVarScopeId)) {
                eliminateUnsolvedInUnions = false;
            }
            curNode = typeVarScopeNode.parent;
        }
        // If the function is returning a callable, don't eliminate unsolved
        // type vars within a union. There are legit uses for unsolved type vars
        // within a callable.
        if ((0, types_1.isFunction)(returnType) || (0, types_1.isOverloadedFunction)(returnType)) {
            eliminateUnsolvedInUnions = false;
        }
        // We'll leave TypeVars unsolved if the call is a recursive
        // call to a generic function or if this isn't a callable
        // return with type parameters that are rescoped from the original
        // function to the returned callable.
        const unknownIfNotFound = !ParseTreeUtils.getTypeVarScopesForNode(errorNode).some((typeVarScope) => typeVarContext.hasSolveForScope(typeVarScope));
        let specializedReturnType = (0, typeUtils_1.applySolvedTypeVars)(returnType, typeVarContext, {
            unknownIfNotFound,
            tupleClassType: getTupleClassType(),
            unknownExemptTypeVars: getUnknownExemptTypeVarsForReturnType(type, returnType),
            eliminateUnsolvedInUnions,
            applyInScopePlaceholders: true,
        });
        specializedReturnType = (0, typeUtils_1.addConditionToType)(specializedReturnType, typeCondition);
        // If the function includes a ParamSpec and the captured signature(s) includes
        // generic types, we may need to apply those solved TypeVars.
        if (paramSpecTypeVarContext.length > 0) {
            paramSpecTypeVarContext.forEach((paramSpecTypeVarContext) => {
                if (paramSpecTypeVarContext) {
                    specializedReturnType = (0, typeUtils_1.applySolvedTypeVars)(specializedReturnType, paramSpecTypeVarContext);
                    // It's possible that one or more of the TypeVars or ParamSpecs
                    // in the typeVarContext refer to TypeVars that were solved in
                    // the paramSpecTypeVarContext. Apply these solved TypeVars accordingly.
                    (0, typeUtils_1.applySourceContextTypeVars)(typeVarContext, paramSpecTypeVarContext);
                }
            });
        }
        // If the final return type is an unpacked tuple, turn it into a normal (unpacked) tuple.
        if ((0, types_1.isUnpackedClass)(specializedReturnType)) {
            specializedReturnType = types_1.ClassType.cloneForUnpacked(specializedReturnType, /* isUnpackedTuple */ false);
        }
        // Handle 'TypeGuard' and 'TypeIs' specially. We'll transform the return type
        // into a 'bool' object with a type argument that reflects the narrowed type.
        if ((0, types_1.isClassInstance)(specializedReturnType) &&
            types_1.ClassType.isBuiltIn(specializedReturnType, ['TypeGuard', 'TypeIs']) &&
            specializedReturnType.typeArguments &&
            specializedReturnType.typeArguments.length > 0) {
            if (boolClass && (0, types_1.isInstantiableClass)(boolClass)) {
                let typeGuardType = specializedReturnType.typeArguments[0];
                // If the first argument is a simple (non-constrained) TypeVar,
                // associate that TypeVar with the resulting TypeGuard type.
                if (argResults.length > 0) {
                    const arg0Type = argResults[0].argType;
                    if ((0, types_1.isTypeVar)(arg0Type) &&
                        !arg0Type.details.isParamSpec &&
                        arg0Type.details.constraints.length === 0) {
                        typeGuardType = (0, typeUtils_1.addConditionToType)(typeGuardType, [
                            { typeVar: arg0Type, constraintIndex: 0 },
                        ]);
                    }
                }
                const useTypeIsSemantics = types_1.ClassType.isBuiltIn(specializedReturnType, 'TypeIs');
                specializedReturnType = types_1.ClassType.cloneAsInstance(types_1.ClassType.cloneForTypeGuard(boolClass, typeGuardType, useTypeIsSemantics));
            }
        }
        const liveTypeVarScopes = ParseTreeUtils.getTypeVarScopesForNode(errorNode);
        specializedReturnType = adjustCallableReturnType(type, specializedReturnType, liveTypeVarScopes, signatureTracker.getTrackedSignatures());
        if (specializedInitSelfType) {
            specializedInitSelfType = (0, typeUtils_1.applySolvedTypeVars)(specializedInitSelfType, typeVarContext);
        }
        matchResults.argumentMatchScore = argumentMatchScore;
        return {
            argumentErrors,
            argResults,
            anyOrUnknownArgument,
            returnType: specializedReturnType,
            isTypeIncomplete,
            activeParam: matchResults.activeParam,
            specializedInitSelfType,
            overloadsUsedForCall: argumentErrors ? [] : [type],
        };
    }
    // In general, all in-scope type variables left in a return type should be
    // replaced with Unknown. However, if the return type is a callable that uses
    // type vars that are found nowhere within the function's input parameters,
    // we'll treat these as though they're scoped to the callable and leave them
    // unsolved.
    function getUnknownExemptTypeVarsForReturnType(functionType, returnType) {
        if ((0, types_1.isFunction)(returnType) && !returnType.details.name) {
            const returnTypeScopeId = returnType.details.typeVarScopeId;
            // If one or more type vars found within the return type are scoped to
            // the functionType but don't appear anywhere else within the functionType's
            // input parameters, rescope them to the return type callable so they are
            // not replaced with Unknown.
            if (returnTypeScopeId && functionType.details.typeVarScopeId) {
                let typeVarsInReturnType = (0, typeUtils_1.getTypeVarArgumentsRecursive)(returnType);
                // Remove any type variables that appear in the function's input parameters.
                functionType.details.parameters.forEach((param) => {
                    if (param.hasDeclaredType) {
                        const typeVarsInInputParam = (0, typeUtils_1.getTypeVarArgumentsRecursive)(param.type);
                        typeVarsInReturnType = typeVarsInReturnType.filter((returnTypeVar) => !typeVarsInInputParam.some((inputTypeVar) => (0, types_1.isTypeSame)(returnTypeVar, inputTypeVar)));
                    }
                });
                return typeVarsInReturnType;
            }
        }
        return [];
    }
    // If the return type includes a generic Callable type, set the type var
    // scope to the scope of the function it was originally associated with
    // to allow these type vars to be solved. This won't work with overloads
    // or unions of callables. It's intended for a specific use case. We may
    // need to make this more sophisticated in the future.
    // The trackedSignatures parameter supplies a list of function signatures
    // that were used for the function and the arguments passed to it. This is
    // important because the callable return value may be called again with
    // one of these signatures, so we may need to "uniquify" the type parameters
    // to avoid conflicts.
    function adjustCallableReturnType(callableType, returnType, liveTypeVarScopes, trackedSignatures) {
        if ((0, types_1.isFunction)(returnType) && !returnType.details.name && callableType.details.typeVarScopeId) {
            // What type variables are referenced in the callable return type? Do not include any live type variables.
            const typeVarsInReturnType = (0, typeUtils_1.getTypeVarArgumentsRecursive)(returnType).filter((t) => !liveTypeVarScopes.some((scopeId) => t.scopeId === scopeId));
            // If there are no unsolved type variables, we're done. If there are
            // unsolved type variables, treat them as though they are rescoped
            // to the callable.
            if (typeVarsInReturnType.length > 0) {
                return types_1.FunctionType.cloneWithNewTypeVarScopeId(returnType, callableType.details.typeVarScopeId, callableType.details.constructorTypeVarScopeId, typeVarsInReturnType, trackedSignatures);
            }
        }
        return returnType;
    }
    // Tries to assign the call arguments to the function parameter
    // list and reports any mismatches in types or counts. Returns the
    // specialized return type of the call.
    function validateArgs(errorNode, argList, typeResult, typeVarContext, skipUnknownArgCheck = false, inferenceContext, signatureTracker) {
        if (!signatureTracker) {
            signatureTracker = new typeUtils_1.UniqueSignatureTracker();
        }
        typeResult.type = (0, typeUtils_1.ensureFunctionSignaturesAreUnique)(typeResult.type, signatureTracker, errorNode.start);
        const matchResults = matchArgsToParams(errorNode, argList, typeResult, 0, signatureTracker);
        if (matchResults.argumentErrors) {
            // Evaluate types of all args. This will ensure that referenced symbols are
            // not reported as unaccessed.
            argList.forEach((arg) => {
                if (arg.valueExpression && !isSpeculativeModeInUse(arg.valueExpression)) {
                    getTypeOfExpression(arg.valueExpression);
                }
            });
            return {
                argumentErrors: true,
                activeParam: matchResults.activeParam,
                overloadsUsedForCall: [],
            };
        }
        return validateArgTypesWithContext(errorNode, matchResults, typeVarContext, skipUnknownArgCheck, (0, typeUtils_1.makeInferenceContext)(inferenceContext === null || inferenceContext === void 0 ? void 0 : inferenceContext.expectedType, inferenceContext === null || inferenceContext === void 0 ? void 0 : inferenceContext.isTypeIncomplete), signatureTracker);
    }
    // Determines whether the specified argument list satisfies the function
    // signature bound to the specified ParamSpec. Return value indicates success.
    function validateArgTypesForParamSpec(errorNode, argList, paramSpec, destTypeVarContext, signatureTracker) {
        const signatureContexts = destTypeVarContext.getSignatureContexts();
        // Handle the common case where there is only one signature context.
        if (signatureContexts.length === 1) {
            return validateArgTypesForParamSpecSignature(errorNode, argList, paramSpec, signatureContexts[0], signatureTracker);
        }
        const filteredSignatureContexts = [];
        const typeVarContexts = [];
        signatureContexts.forEach((context) => {
            // Use speculative mode to avoid emitting errors or caching types.
            useSpeculativeMode(errorNode, () => {
                const paramSpecArgResult = validateArgTypesForParamSpecSignature(errorNode, argList, paramSpec, context, signatureTracker);
                if (!paramSpecArgResult.argumentErrors) {
                    filteredSignatureContexts.push(context);
                }
                (0, collectionUtils_1.appendArray)(typeVarContexts, paramSpecArgResult.typeVarContexts);
            });
        });
        // Copy back any compatible signature contexts if any were compatible.
        if (filteredSignatureContexts.length > 0) {
            destTypeVarContext.copySignatureContexts(filteredSignatureContexts);
        }
        // Evaluate non-speculatively to produce a final result and cache types.
        const paramSpecArgResult = validateArgTypesForParamSpecSignature(errorNode, argList, paramSpec, filteredSignatureContexts.length > 0 ? filteredSignatureContexts[0] : signatureContexts[0], signatureTracker);
        return { argumentErrors: paramSpecArgResult.argumentErrors, typeVarContexts };
    }
    function validateArgTypesForParamSpecSignature(errorNode, argList, paramSpec, typeVarContext, signatureTracker) {
        var _a;
        let paramSpecType = typeVarContext.getParamSpecType(paramSpec);
        if (!paramSpecType) {
            paramSpecType = (0, typeUtils_1.convertTypeToParamSpecValue)(paramSpec);
        }
        const matchResults = matchArgsToParams(errorNode, argList, { type: paramSpecType }, 0, signatureTracker);
        const functionType = matchResults.overload;
        const srcTypeVarContext = new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeIds)(paramSpecType));
        if (matchResults.argumentErrors) {
            // Evaluate types of all args. This will ensure that referenced symbols are
            // not reported as unaccessed.
            argList.forEach((arg) => {
                if (arg.valueExpression && !isSpeculativeModeInUse(arg.valueExpression)) {
                    getTypeOfExpression(arg.valueExpression);
                }
            });
            return { argumentErrors: true, typeVarContexts: [srcTypeVarContext] };
        }
        const functionParamSpec = types_1.FunctionType.getParamSpecFromArgsKwargs(functionType);
        const functionWithoutParamSpec = types_1.FunctionType.cloneRemoveParamSpecArgsKwargs(functionType);
        // Handle the recursive case where we're passing (*args: P.args, **kwargs: P.args)
        // a remaining function of type (*P).
        if (functionParamSpec &&
            functionWithoutParamSpec.details.parameters.length === 0 &&
            (0, types_1.isTypeSame)(functionParamSpec, paramSpec)) {
            // If there are any arguments other than *args: P.args or **kwargs: P.kwargs,
            // report an error.
            let argsCount = 0;
            let kwargsCount = 0;
            let argumentErrors = false;
            let argErrorNode;
            for (const arg of argList) {
                const argType = (_a = getTypeOfArgument(arg, /* inferenceContext */ undefined, signatureTracker)) === null || _a === void 0 ? void 0 : _a.type;
                if (arg.argumentCategory === 1 /* ArgumentCategory.UnpackedList */) {
                    if ((0, parameterUtils_1.isParamSpecArgsArgument)(paramSpec, argType)) {
                        argsCount++;
                    }
                }
                else if (arg.argumentCategory === 2 /* ArgumentCategory.UnpackedDictionary */) {
                    if ((0, parameterUtils_1.isParamSpecKwargsArgument)(paramSpec, argType)) {
                        kwargsCount++;
                    }
                }
                else {
                    argErrorNode = argErrorNode !== null && argErrorNode !== void 0 ? argErrorNode : arg.valueExpression;
                    argumentErrors = true;
                }
            }
            if (argsCount !== 1 || kwargsCount !== 1) {
                argumentErrors = true;
            }
            if (argumentErrors) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, localize_1.LocMessage.paramSpecArgsMissing().format({
                    type: printType(functionParamSpec),
                }), argErrorNode !== null && argErrorNode !== void 0 ? argErrorNode : errorNode);
            }
            return { argumentErrors, typeVarContexts: [srcTypeVarContext] };
        }
        const result = validateArgTypes(errorNode, matchResults, srcTypeVarContext, signatureTracker, 
        /* skipUnknownArgCheck */ undefined);
        return { argumentErrors: !!result.argumentErrors, typeVarContexts: [srcTypeVarContext] };
    }
    function validateArgType(argParam, typeVarContext, signatureTracker, typeResult, options) {
        var _a;
        let argType;
        let expectedTypeDiag;
        let isTypeIncomplete = !!(typeResult === null || typeResult === void 0 ? void 0 : typeResult.isIncomplete);
        let isCompatible = true;
        const functionName = typeResult === null || typeResult === void 0 ? void 0 : typeResult.type.details.name;
        let skippedBareTypeVarExpectedType = false;
        let skipSolveTypeVars = false;
        if (argParam.argument.valueExpression) {
            let expectedType;
            // Is the expected type a "bare" in-scope TypeVar or a union of bare in-scope TypeVars?
            let isExpectedTypeBareTypeVar = true;
            (0, typeUtils_1.doForEachSubtype)(argParam.paramType, (subtype) => {
                if (!(0, types_1.isTypeVar)(subtype) || subtype.scopeId !== (typeResult === null || typeResult === void 0 ? void 0 : typeResult.type.details.typeVarScopeId)) {
                    isExpectedTypeBareTypeVar = false;
                }
            });
            if (!options.skipBareTypeVarExpectedType || !isExpectedTypeBareTypeVar) {
                expectedType = argParam.paramType;
                // If the parameter type is a function with a ParamSpec, don't apply
                // the solved TypeVars if the typeVarContext has more than one signature.
                // This will expand the ParamSpec into an overload, which will cause problems.
                const skipApplySolvedTypeVars = (0, types_1.isFunction)(argParam.paramType) &&
                    types_1.FunctionType.getParamSpecFromArgsKwargs(argParam.paramType) &&
                    typeVarContext.getSignatureContexts().length > 1;
                if (!skipApplySolvedTypeVars) {
                    expectedType = (0, typeUtils_1.applySolvedTypeVars)(expectedType, typeVarContext, {
                        useNarrowBoundOnly: !!options.useNarrowBoundOnly,
                    });
                }
            }
            else {
                skippedBareTypeVarExpectedType = true;
                // If the expected type is a union of bare TypeVars, it's not clear which of the two
                // (or both) should be constrained. We'll skip any attempt to solve the TypeVars during
                // this pass and hope that subsequent arg assignments will help us establish the correct
                // constraints.
                if ((0, types_1.isUnion)(argParam.paramType)) {
                    skipSolveTypeVars = true;
                }
            }
            // If the expected type is unknown, don't use an expected type. Instead,
            // use default rules for evaluating the expression type.
            if (expectedType && (0, types_1.isUnknown)(expectedType)) {
                expectedType = undefined;
            }
            // Was the argument's type precomputed by the caller?
            if (argParam.argType) {
                argType = argParam.argType;
            }
            else {
                const flags = argParam.isinstanceParam
                    ? 536871546 /* EvalFlags.IsInstanceArgDefaults */
                    : 16 /* EvalFlags.NoFinal */ | 2 /* EvalFlags.NoSpecialize */;
                const exprTypeResult = getTypeOfExpression(argParam.argument.valueExpression, flags, (0, typeUtils_1.makeInferenceContext)(expectedType, !!(typeResult === null || typeResult === void 0 ? void 0 : typeResult.isIncomplete)), signatureTracker);
                argType = exprTypeResult.type;
                // If the type includes multiple instances of a generic function
                // signature, force the type arguments for the duplicates to have
                // unique names.
                argType = (0, typeUtils_1.ensureFunctionSignaturesAreUnique)(argType, signatureTracker, argParam.argument.valueExpression.start);
                if (exprTypeResult.isIncomplete) {
                    isTypeIncomplete = true;
                }
                if (exprTypeResult.typeErrors) {
                    isCompatible = false;
                }
                else if (expectedType && (0, typeUtils_1.requiresSpecialization)(expectedType)) {
                    // Assign the argument type back to the expected type to assign
                    // values to any in-scope placeholder type variables.
                    const typeVarContextClone = typeVarContext.clone();
                    if (assignType(expectedType, argType, /* diag */ undefined, typeVarContextClone)) {
                        typeVarContext.copyFromClone(typeVarContextClone);
                    }
                    else {
                        isCompatible = false;
                    }
                }
                expectedTypeDiag = exprTypeResult.expectedTypeDiagAddendum;
            }
            if (argParam.argument && argParam.argument.name && !isSpeculativeModeInUse(argParam.errorNode)) {
                writeTypeCache(argParam.argument.name, { type: expectedType !== null && expectedType !== void 0 ? expectedType : argType, isIncomplete: isTypeIncomplete }, 0 /* EvalFlags.None */);
            }
        }
        else {
            // Was the argument's type precomputed by the caller?
            if (argParam.argType) {
                argType = argParam.argType;
            }
            else {
                const argTypeResult = getTypeOfArgument(argParam.argument, 
                /* inferenceContext */ undefined, signatureTracker);
                argType = argTypeResult.type;
                if (argTypeResult.isIncomplete) {
                    isTypeIncomplete = true;
                }
            }
            // If the argument came from a parameter's default argument value,
            // we may need to specialize the type.
            if (argParam.isDefaultArg) {
                argType = (0, typeUtils_1.applySolvedTypeVars)(argType, typeVarContext);
            }
        }
        // If we're assigning to a var arg dictionary with a TypeVar type,
        // strip literals before performing the assignment. This is used in
        // places like a dict constructor.
        if (argParam.paramCategory === 2 /* ParameterCategory.KwargsDict */ && (0, types_1.isTypeVar)(argParam.paramType)) {
            argType = stripLiteralValue(argType);
        }
        // If there's a constraint filter, apply it to top-level type variables
        // if appropriate. This doesn't properly handle non-top-level constrained
        // type variables.
        if (options.conditionFilter) {
            argType = mapSubtypesExpandTypeVars(argType, { conditionFilter: options.conditionFilter }, (expandedSubtype) => {
                return expandedSubtype;
            });
        }
        const condition = argType.condition;
        let diag = new diagnostic_1.DiagnosticAddendum();
        if ((0, types_1.isParamSpec)(argParam.paramType)) {
            // Handle the case where we're assigning a *args or **kwargs argument
            // to a *P.args or **P.kwargs parameter.
            if (argParam.paramType.paramSpecAccess !== undefined) {
                return { isCompatible, argType, isTypeIncomplete, condition };
            }
            // Handle the case where we're assigning a *P.args or **P.kwargs argument
            // to a *P.args or **P.kwargs parameter.
            if ((0, types_1.isParamSpec)(argType) && argType.paramSpecAccess !== undefined) {
                return { isCompatible, argType, isTypeIncomplete, condition };
            }
        }
        // If we are asked to skip overload arguments, determine whether the argument
        // is an explicit overload type, an overloaded class constructor, or a
        // an overloaded callback protocol.
        if (options.skipOverloadArg) {
            if ((0, types_1.isOverloadedFunction)(argType)) {
                return {
                    isCompatible,
                    argType,
                    isTypeIncomplete,
                    skippedOverloadArg: true,
                    skippedBareTypeVarExpectedType,
                    condition,
                };
            }
            const concreteParamType = makeTopLevelTypeVarsConcrete(argParam.paramType);
            if ((0, types_1.isFunction)(concreteParamType) || (0, types_1.isOverloadedFunction)(concreteParamType)) {
                if ((0, types_1.isInstantiableClass)(argType)) {
                    const constructor = (0, constructors_1.createFunctionFromConstructor)(evaluatorInterface, argType);
                    if (constructor) {
                        return {
                            isCompatible,
                            argType,
                            isTypeIncomplete,
                            skippedOverloadArg: true,
                            skippedBareTypeVarExpectedType,
                            condition,
                        };
                    }
                }
                if ((0, types_1.isClassInstance)(argType)) {
                    const callMember = (0, typeUtils_1.lookUpObjectMember)(argType, '__call__', 16 /* MemberAccessFlags.SkipInstanceMembers */);
                    if (callMember) {
                        const memberType = getTypeOfMember(callMember);
                        if ((0, types_1.isOverloadedFunction)(memberType)) {
                            return {
                                isCompatible,
                                argType,
                                isTypeIncomplete,
                                skippedOverloadArg: true,
                                skippedBareTypeVarExpectedType,
                                condition,
                            };
                        }
                    }
                }
            }
        }
        let assignTypeFlags = skipSolveTypeVars ? 8 /* AssignTypeFlags.SkipSolveTypeVars */ : 0 /* AssignTypeFlags.Default */;
        if (argParam.isinstanceParam) {
            assignTypeFlags |= 32768 /* AssignTypeFlags.AllowIsinstanceSpecialForms */;
        }
        if (!assignType(argParam.paramType, argType, diag.createAddendum(), typeVarContext, 
        /* srcTypeVarContext */ undefined, assignTypeFlags)) {
            // Mismatching parameter types are common in untyped code; don't bother spending time
            // printing types if the diagnostic is disabled.
            const fileInfo = AnalyzerNodeInfo.getFileInfo(argParam.errorNode);
            if (fileInfo.diagnosticRuleSet.reportArgumentType !== 'none' &&
                !canSkipDiagnosticForNode(argParam.errorNode) &&
                !isTypeIncomplete) {
                const argTypeText = printType(argType);
                const paramTypeText = printType(argParam.paramType);
                let message;
                if (argParam.paramName && !argParam.isParamNameSynthesized) {
                    if (functionName) {
                        message = localize_1.LocMessage.argAssignmentParamFunction().format({
                            argType: argTypeText,
                            paramType: paramTypeText,
                            functionName,
                            paramName: argParam.paramName,
                        });
                    }
                    else {
                        message = localize_1.LocMessage.argAssignmentParam().format({
                            argType: argTypeText,
                            paramType: paramTypeText,
                            paramName: argParam.paramName,
                        });
                    }
                }
                else {
                    if (functionName) {
                        message = localize_1.LocMessage.argAssignmentFunction().format({
                            argType: argTypeText,
                            paramType: paramTypeText,
                            functionName,
                        });
                    }
                    else {
                        message = localize_1.LocMessage.argAssignment().format({
                            argType: argTypeText,
                            paramType: paramTypeText,
                        });
                    }
                }
                // If we have an expected type diagnostic addendum, use that
                // instead of the local diagnostic addendum because it will
                // be more informative.
                if (expectedTypeDiag) {
                    diag = expectedTypeDiag;
                }
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportArgumentType, message + diag.getString(), argParam.errorNode, (_a = diag.getEffectiveTextRange()) !== null && _a !== void 0 ? _a : argParam.errorNode);
            }
            return { isCompatible: false, argType, isTypeIncomplete, skippedBareTypeVarExpectedType, condition };
        }
        if (!options.skipUnknownArgCheck) {
            const simplifiedType = (0, types_1.removeUnbound)(argType);
            const fileInfo = AnalyzerNodeInfo.getFileInfo(argParam.errorNode);
            function getDiagAddendum() {
                const diagAddendum = new diagnostic_1.DiagnosticAddendum();
                if (argParam.paramName) {
                    diagAddendum.addMessage((functionName
                        ? localize_1.LocAddendum.argParamFunction().format({
                            paramName: argParam.paramName,
                            functionName,
                        })
                        : localize_1.LocAddendum.argParam().format({ paramName: argParam.paramName })) +
                        diagAddendum.getString());
                }
                return diagAddendum;
            }
            // Do not check for unknown types if the expected type is "Any".
            // Don't print types if reportUnknownArgumentType is disabled for performance.
            if (fileInfo.diagnosticRuleSet.reportUnknownArgumentType !== 'none' &&
                !(0, types_1.isAny)(argParam.paramType) &&
                !isTypeIncomplete) {
                if ((0, types_1.isUnknown)(simplifiedType)) {
                    const diagAddendum = getDiagAddendum();
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportUnknownArgumentType, localize_1.LocMessage.argTypeUnknown() + diagAddendum.getString(), argParam.errorNode);
                }
                else if ((0, typeUtils_1.isPartlyUnknown)(simplifiedType)) {
                    // If the parameter type is also partially unknown, don't report
                    // the error because it's likely that the partially-unknown type
                    // arose due to bidirectional type matching.
                    if (!(0, typeUtils_1.isPartlyUnknown)(argParam.paramType)) {
                        const diagAddendum = getDiagAddendum();
                        diagAddendum.addMessage(localize_1.LocAddendum.argumentType().format({
                            type: printType(simplifiedType, { expandTypeAlias: true }),
                        }));
                        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportUnknownArgumentType, localize_1.LocMessage.argTypePartiallyUnknown() + diagAddendum.getString(), argParam.errorNode);
                    }
                }
            }
        }
        return { isCompatible, argType, isTypeIncomplete, skippedBareTypeVarExpectedType, condition };
    }
    function createTypeVarType(errorNode, classType, argList) {
        var _a, _b, _c, _d, _e, _f, _g;
        let typeVarName = '';
        let firstConstraintArg;
        let defaultValueNode;
        if (argList.length === 0) {
            addError(localize_1.LocMessage.typeVarFirstArg(), errorNode);
            return undefined;
        }
        const firstArg = argList[0];
        if (firstArg.valueExpression && firstArg.valueExpression.nodeType === 48 /* ParseNodeType.StringList */) {
            typeVarName = firstArg.valueExpression.strings.map((s) => s.value).join('');
        }
        else {
            addError(localize_1.LocMessage.typeVarFirstArg(), firstArg.valueExpression || errorNode);
        }
        const typeVar = types_1.TypeBase.cloneAsSpecialForm(types_1.TypeVarType.createInstantiable(typeVarName, /* isParamSpec */ false), types_1.ClassType.cloneAsInstance(classType));
        // Parse the remaining parameters.
        const paramNameMap = new Map();
        for (let i = 1; i < argList.length; i++) {
            const paramNameNode = argList[i].name;
            const paramName = paramNameNode ? paramNameNode.value : undefined;
            if (paramName) {
                if (paramNameMap.get(paramName)) {
                    addError(localize_1.LocMessage.duplicateParam().format({ name: paramName }), argList[i].valueExpression || errorNode);
                }
                if (paramName === 'bound') {
                    if (typeVar.details.constraints.length > 0) {
                        addError(localize_1.LocMessage.typeVarBoundAndConstrained(), argList[i].valueExpression || errorNode);
                    }
                    else {
                        const argType = (_b = (_a = argList[i].typeResult) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : getTypeOfExpressionExpectingType(argList[i].valueExpression, {
                            disallowProtocolAndTypedDict: true,
                        }).type;
                        if ((0, typeUtils_1.requiresSpecialization)(argType, { ignorePseudoGeneric: true, ignoreImplicitTypeArgs: true })) {
                            addError(localize_1.LocMessage.typeVarBoundGeneric(), argList[i].valueExpression || errorNode);
                        }
                        typeVar.details.boundType = (0, typeUtils_1.convertToInstance)(argType);
                    }
                }
                else if (paramName === 'covariant') {
                    if (argList[i].valueExpression && getBooleanValue(argList[i].valueExpression)) {
                        if (typeVar.details.declaredVariance === 4 /* Variance.Contravariant */ ||
                            typeVar.details.declaredVariance === 0 /* Variance.Auto */) {
                            addError(localize_1.LocMessage.typeVarVariance(), argList[i].valueExpression);
                        }
                        else {
                            typeVar.details.declaredVariance = 3 /* Variance.Covariant */;
                        }
                    }
                }
                else if (paramName === 'contravariant') {
                    if (argList[i].valueExpression && getBooleanValue(argList[i].valueExpression)) {
                        if (typeVar.details.declaredVariance === 3 /* Variance.Covariant */ ||
                            typeVar.details.declaredVariance === 0 /* Variance.Auto */) {
                            addError(localize_1.LocMessage.typeVarVariance(), argList[i].valueExpression);
                        }
                        else {
                            typeVar.details.declaredVariance = 4 /* Variance.Contravariant */;
                        }
                    }
                }
                else if (paramName === 'infer_variance') {
                    if (argList[i].valueExpression && getBooleanValue(argList[i].valueExpression)) {
                        if (typeVar.details.declaredVariance === 3 /* Variance.Covariant */ ||
                            typeVar.details.declaredVariance === 4 /* Variance.Contravariant */) {
                            addError(localize_1.LocMessage.typeVarVariance(), argList[i].valueExpression);
                        }
                        else {
                            typeVar.details.declaredVariance = 0 /* Variance.Auto */;
                        }
                    }
                }
                else if (paramName === 'default') {
                    defaultValueNode = argList[i].valueExpression;
                    const argType = (_d = (_c = argList[i].typeResult) === null || _c === void 0 ? void 0 : _c.type) !== null && _d !== void 0 ? _d : getTypeOfExpressionExpectingType(defaultValueNode, {
                        allowTypeVarsWithoutScopeId: true,
                    }).type;
                    typeVar.details.defaultType = (0, typeUtils_1.convertToInstance)(argType);
                    typeVar.details.isDefaultExplicit = true;
                    const fileInfo = AnalyzerNodeInfo.getFileInfo(errorNode);
                    if (!fileInfo.isStubFile &&
                        fileInfo.executionEnvironment.pythonVersion.isLessThan(pythonVersion_1.pythonVersion3_13) &&
                        classType.details.moduleName !== 'typing_extensions') {
                        addError(localize_1.LocMessage.typeVarDefaultIllegal(), defaultValueNode);
                    }
                }
                else {
                    addError(localize_1.LocMessage.typeVarUnknownParam().format({ name: paramName }), ((_e = argList[i].node) === null || _e === void 0 ? void 0 : _e.name) || argList[i].valueExpression || errorNode);
                }
                paramNameMap.set(paramName, paramName);
            }
            else {
                if (typeVar.details.boundType) {
                    addError(localize_1.LocMessage.typeVarBoundAndConstrained(), argList[i].valueExpression || errorNode);
                }
                else {
                    const argType = (_g = (_f = argList[i].typeResult) === null || _f === void 0 ? void 0 : _f.type) !== null && _g !== void 0 ? _g : getTypeOfExpressionExpectingType(argList[i].valueExpression).type;
                    if ((0, typeUtils_1.requiresSpecialization)(argType, { ignorePseudoGeneric: true })) {
                        addError(localize_1.LocMessage.typeVarConstraintGeneric(), argList[i].valueExpression || errorNode);
                    }
                    types_1.TypeVarType.addConstraint(typeVar, (0, typeUtils_1.convertToInstance)(argType));
                    if (firstConstraintArg === undefined) {
                        firstConstraintArg = argList[i];
                    }
                }
            }
        }
        if (typeVar.details.constraints.length === 1 && firstConstraintArg) {
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeVarSingleConstraint(), firstConstraintArg.valueExpression || errorNode);
        }
        // If a default is provided, make sure it is compatible with the bound
        // or constraint.
        if (typeVar.details.isDefaultExplicit && defaultValueNode) {
            verifyTypeVarDefaultIsCompatible(typeVar, defaultValueNode);
        }
        return typeVar;
    }
    function verifyTypeVarDefaultIsCompatible(typeVar, defaultValueNode) {
        (0, debug_1.assert)(typeVar.details.isDefaultExplicit);
        const typeVarContext = new typeVarContext_1.TypeVarContext(typeVar.scopeId);
        const concreteDefaultType = makeTopLevelTypeVarsConcrete((0, typeUtils_1.applySolvedTypeVars)(typeVar.details.defaultType, typeVarContext, {
            unknownIfNotFound: true,
            tupleClassType: getTupleClassType(),
        }));
        if (typeVar.details.boundType) {
            if (!assignType(typeVar.details.boundType, concreteDefaultType)) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeVarDefaultBoundMismatch(), defaultValueNode);
            }
        }
        else if (typeVar.details.constraints.length > 0) {
            let isConstraintCompatible = true;
            // If the default type is a constrained TypeVar, make sure all of its constraints
            // are also constraints in typeVar. If the default type is not a constrained TypeVar,
            // use its concrete type to compare against the constraints.
            if ((0, types_1.isTypeVar)(typeVar.details.defaultType) && typeVar.details.defaultType.details.constraints.length > 0) {
                for (const constraint of typeVar.details.defaultType.details.constraints) {
                    if (!typeVar.details.constraints.some((c) => (0, types_1.isTypeSame)(c, constraint))) {
                        isConstraintCompatible = false;
                    }
                }
            }
            else if (!typeVar.details.constraints.some((constraint) => (0, types_1.isTypeSame)(constraint, concreteDefaultType, { ignoreConditions: true }))) {
                isConstraintCompatible = false;
            }
            if (!isConstraintCompatible) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeVarDefaultConstraintMismatch(), defaultValueNode);
            }
        }
    }
    function createTypeVarTupleType(errorNode, classType, argList) {
        var _a, _b;
        let typeVarName = '';
        if (argList.length === 0) {
            addError(localize_1.LocMessage.typeVarFirstArg(), errorNode);
            return undefined;
        }
        const firstArg = argList[0];
        if (firstArg.valueExpression && firstArg.valueExpression.nodeType === 48 /* ParseNodeType.StringList */) {
            typeVarName = firstArg.valueExpression.strings.map((s) => s.value).join('');
        }
        else {
            addError(localize_1.LocMessage.typeVarFirstArg(), firstArg.valueExpression || errorNode);
        }
        const typeVar = types_1.TypeBase.cloneAsSpecialForm(types_1.TypeVarType.createInstantiable(typeVarName, /* isParamSpec */ false), types_1.ClassType.cloneAsInstance(classType));
        typeVar.details.isVariadic = true;
        typeVar.details.defaultType = makeTupleObject([{ type: types_1.UnknownType.create(), isUnbounded: true }]);
        // Parse the remaining parameters.
        for (let i = 1; i < argList.length; i++) {
            const paramNameNode = argList[i].name;
            const paramName = paramNameNode ? paramNameNode.value : undefined;
            if (paramName) {
                if (paramName === 'default') {
                    const expr = argList[i].valueExpression;
                    if (expr) {
                        const defaultType = getTypeVarTupleDefaultType(expr, /* isPep695Syntax */ false);
                        if (defaultType) {
                            typeVar.details.defaultType = defaultType;
                            typeVar.details.isDefaultExplicit = true;
                        }
                    }
                    const fileInfo = AnalyzerNodeInfo.getFileInfo(errorNode);
                    if (!fileInfo.isStubFile &&
                        fileInfo.executionEnvironment.pythonVersion.isLessThan(pythonVersion_1.pythonVersion3_13) &&
                        classType.details.moduleName !== 'typing_extensions') {
                        addError(localize_1.LocMessage.typeVarDefaultIllegal(), expr);
                    }
                }
                else {
                    addError(localize_1.LocMessage.typeVarTupleUnknownParam().format({ name: ((_a = argList[i].name) === null || _a === void 0 ? void 0 : _a.value) || '?' }), ((_b = argList[i].node) === null || _b === void 0 ? void 0 : _b.name) || argList[i].valueExpression || errorNode);
                }
            }
            else {
                addError(localize_1.LocMessage.typeVarTupleConstraints(), argList[i].valueExpression || errorNode);
            }
        }
        return typeVar;
    }
    function getTypeVarTupleDefaultType(node, isPep695Syntax) {
        const argType = getTypeOfExpressionExpectingType(node, {
            allowUnpackedTuple: true,
            allowTypeVarsWithoutScopeId: true,
            allowForwardReference: isPep695Syntax,
        }).type;
        const isUnpackedTuple = (0, types_1.isClass)(argType) && (0, typeUtils_1.isTupleClass)(argType) && argType.isUnpacked;
        const isUnpackedTypeVarTuple = (0, types_1.isUnpackedVariadicTypeVar)(argType);
        if (!isUnpackedTuple && !isUnpackedTypeVarTuple) {
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeVarTupleDefaultNotUnpacked(), node);
            return undefined;
        }
        return (0, typeUtils_1.convertToInstance)(argType);
    }
    function createParamSpecType(errorNode, classType, argList) {
        if (argList.length === 0) {
            addError(localize_1.LocMessage.paramSpecFirstArg(), errorNode);
            return undefined;
        }
        const firstArg = argList[0];
        let paramSpecName = '';
        if (firstArg.valueExpression && firstArg.valueExpression.nodeType === 48 /* ParseNodeType.StringList */) {
            paramSpecName = firstArg.valueExpression.strings.map((s) => s.value).join('');
        }
        else {
            addError(localize_1.LocMessage.paramSpecFirstArg(), firstArg.valueExpression || errorNode);
        }
        const paramSpec = types_1.TypeBase.cloneAsSpecialForm(types_1.TypeVarType.createInstantiable(paramSpecName, /* isParamSpec */ true), types_1.ClassType.cloneAsInstance(classType));
        paramSpec.details.defaultType = (0, typeUtils_1.getUnknownTypeForParamSpec)();
        // Parse the remaining parameters.
        for (let i = 1; i < argList.length; i++) {
            const paramNameNode = argList[i].name;
            const paramName = paramNameNode ? paramNameNode.value : undefined;
            if (paramName) {
                if (paramName === 'default') {
                    const expr = argList[i].valueExpression;
                    if (expr) {
                        const defaultType = getParamSpecDefaultType(expr, /* isPep695Syntax */ false);
                        if (defaultType) {
                            paramSpec.details.defaultType = defaultType;
                            paramSpec.details.isDefaultExplicit = true;
                        }
                    }
                    const fileInfo = AnalyzerNodeInfo.getFileInfo(errorNode);
                    if (!fileInfo.isStubFile &&
                        fileInfo.executionEnvironment.pythonVersion.isLessThan(pythonVersion_1.pythonVersion3_13) &&
                        classType.details.moduleName !== 'typing_extensions') {
                        addError(localize_1.LocMessage.typeVarDefaultIllegal(), expr);
                    }
                }
                else {
                    addError(localize_1.LocMessage.paramSpecUnknownParam().format({ name: paramName }), paramNameNode || argList[i].valueExpression || errorNode);
                }
            }
            else {
                addError(localize_1.LocMessage.paramSpecUnknownArg(), argList[i].valueExpression || errorNode);
                break;
            }
        }
        return paramSpec;
    }
    function getParamSpecDefaultType(node, isPep695Syntax) {
        const functionType = types_1.FunctionType.createSynthesizedInstance('', 65536 /* FunctionTypeFlags.ParamSpecValue */);
        if (node.nodeType === 21 /* ParseNodeType.Ellipsis */) {
            types_1.FunctionType.addDefaultParameters(functionType);
            functionType.details.flags |= 32768 /* FunctionTypeFlags.GradualCallableForm */;
            return functionType;
        }
        if (node.nodeType === 34 /* ParseNodeType.List */) {
            node.entries.forEach((paramExpr, index) => {
                const typeResult = getTypeOfExpressionExpectingType(paramExpr, {
                    allowTypeVarsWithoutScopeId: true,
                    allowForwardReference: isPep695Syntax,
                });
                types_1.FunctionType.addParameter(functionType, {
                    category: 0 /* ParameterCategory.Simple */,
                    name: `__p${index}`,
                    isNameSynthesized: true,
                    hasDeclaredType: true,
                    type: (0, typeUtils_1.convertToInstance)(typeResult.type),
                });
            });
            if (node.entries.length > 0) {
                types_1.FunctionType.addPositionOnlyParameterSeparator(functionType);
            }
            // Update the type cache so we don't attempt to re-evaluate this node.
            // The type doesn't matter, so use Any.
            writeTypeCache(node, { type: types_1.AnyType.create() }, /* flags */ undefined);
            return functionType;
        }
        else {
            const typeResult = getTypeOfExpressionExpectingType(node, {
                allowParamSpec: true,
                allowTypeVarsWithoutScopeId: true,
            });
            if (typeResult.typeErrors) {
                return undefined;
            }
            if ((0, types_1.isParamSpec)(typeResult.type)) {
                types_1.FunctionType.addParamSpecVariadics(functionType, typeResult.type);
                return functionType;
            }
            if ((0, types_1.isClassInstance)(typeResult.type) &&
                types_1.ClassType.isBuiltIn(typeResult.type, ['EllipsisType', 'ellipsis'])) {
                types_1.FunctionType.addDefaultParameters(functionType);
                return functionType;
            }
        }
        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.paramSpecDefaultNotTuple(), node);
        return undefined;
    }
    // Handles a call to TypeAliasType(). This special form allows a caller to programmatically
    // create a type alias as defined in PEP 695. If one or more of the arguments is incorrect,
    // it returns undefined so the normal constructor evaluation can be performed (and type errors
    // emitted).
    function createTypeAliasType(errorNode, argList) {
        if (errorNode.nodeType !== 9 /* ParseNodeType.Call */ || !errorNode.parent || argList.length < 2) {
            return undefined;
        }
        if (errorNode.parent.nodeType !== 3 /* ParseNodeType.Assignment */ ||
            errorNode.parent.rightExpression !== errorNode ||
            errorNode.parent.leftExpression.nodeType !== 38 /* ParseNodeType.Name */) {
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeAliasTypeMustBeAssigned(), errorNode);
            return undefined;
        }
        const nameNode = errorNode.parent.leftExpression;
        const firstArg = argList[0];
        if (firstArg.valueExpression && firstArg.valueExpression.nodeType === 48 /* ParseNodeType.StringList */) {
            const typeAliasName = firstArg.valueExpression.strings.map((s) => s.value).join('');
            if (typeAliasName !== nameNode.value) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeAliasTypeNameMismatch(), firstArg.valueExpression);
            }
        }
        else {
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeAliasTypeNameArg(), firstArg.valueExpression || errorNode);
            return undefined;
        }
        let valueExpr;
        let typeParamsExpr;
        // Parse the remaining parameters.
        for (let i = 1; i < argList.length; i++) {
            const paramNameNode = argList[i].name;
            const paramName = paramNameNode ? paramNameNode.value : undefined;
            if (paramName) {
                if (paramName === 'type_params' && !typeParamsExpr) {
                    typeParamsExpr = argList[i].valueExpression;
                }
                else if (paramName === 'value' && !valueExpr) {
                    valueExpr = argList[i].valueExpression;
                }
                else {
                    return undefined;
                }
            }
            else if (i === 1) {
                valueExpr = argList[i].valueExpression;
            }
            else {
                return undefined;
            }
        }
        // The value expression is not optional, so bail if it's not present.
        if (!valueExpr) {
            return undefined;
        }
        let typeParameters;
        if (typeParamsExpr) {
            if (typeParamsExpr.nodeType !== 52 /* ParseNodeType.Tuple */) {
                addError(localize_1.LocMessage.typeAliasTypeParamInvalid(), typeParamsExpr);
                return undefined;
            }
            typeParameters = [];
            let isTypeParamListValid = true;
            typeParamsExpr.expressions.map((expr) => {
                let entryType = getTypeOfExpression(expr, 128 /* EvalFlags.InstantiableType */ | 4096 /* EvalFlags.AllowTypeVarWithoutScopeId */).type;
                if ((0, types_1.isTypeVar)(entryType)) {
                    if (entryType.scopeId || entryType.isVariadicUnpacked) {
                        isTypeParamListValid = false;
                    }
                    else {
                        entryType = types_1.TypeVarType.cloneForScopeId(entryType, ParseTreeUtils.getScopeIdForNode(nameNode), nameNode.value, 2 /* TypeVarScopeType.TypeAlias */);
                    }
                    typeParameters.push(entryType);
                }
                else {
                    isTypeParamListValid = false;
                }
            });
            if (!isTypeParamListValid) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeAliasTypeParamInvalid(), typeParamsExpr);
                return undefined;
            }
        }
        return getTypeOfTypeAliasCommon(nameNode, nameNode, valueExpr, 
        /* isPep695Syntax */ true, 
        /* typeParamNodes */ undefined, () => typeParameters);
    }
    function getBooleanValue(node) {
        if (node.nodeType === 14 /* ParseNodeType.Constant */) {
            if (node.constType === 15 /* KeywordType.False */) {
                return false;
            }
            else if (node.constType === 33 /* KeywordType.True */) {
                return true;
            }
        }
        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.expectedBoolLiteral(), node);
        return false;
    }
    function getFunctionFullName(functionNode, moduleName, functionName) {
        const nameParts = [functionName];
        let curNode = functionNode;
        // Walk the parse tree looking for classes or functions.
        while (curNode) {
            curNode = ParseTreeUtils.getEnclosingClassOrFunction(curNode);
            if (curNode) {
                nameParts.push(curNode.name.value);
            }
        }
        nameParts.push(moduleName);
        return nameParts.reverse().join('.');
    }
    // Implements the semantics of the NewType call as documented
    // in the Python specification: The static type checker will treat
    // the new type as if it were a subclass of the original type.
    function createNewType(errorNode, argList) {
        var _a, _b, _c;
        const fileInfo = AnalyzerNodeInfo.getFileInfo(errorNode);
        let className = '';
        if (argList.length !== 2) {
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportCallIssue, localize_1.LocMessage.newTypeParamCount(), errorNode);
            return undefined;
        }
        const nameArg = argList[0];
        if (nameArg.argumentCategory === 0 /* ArgumentCategory.Simple */ &&
            nameArg.valueExpression &&
            nameArg.valueExpression.nodeType === 48 /* ParseNodeType.StringList */) {
            className = nameArg.valueExpression.strings.map((s) => s.value).join('');
        }
        if (!className) {
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportArgumentType, localize_1.LocMessage.newTypeBadName(), (_a = argList[0].node) !== null && _a !== void 0 ? _a : errorNode);
            return undefined;
        }
        if (((_b = errorNode.parent) === null || _b === void 0 ? void 0 : _b.nodeType) === 3 /* ParseNodeType.Assignment */ &&
            errorNode.parent.leftExpression.nodeType === 38 /* ParseNodeType.Name */ &&
            errorNode.parent.leftExpression.value !== className) {
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.newTypeNameMismatch(), errorNode.parent.leftExpression);
            return undefined;
        }
        let baseClass = getTypeOfArgumentExpectingType(argList[1]).type;
        let isBaseClassAny = false;
        if ((0, types_1.isAnyOrUnknown)(baseClass)) {
            baseClass = objectClass !== null && objectClass !== void 0 ? objectClass : types_1.UnknownType.create();
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.newTypeAnyOrUnknown(), (_c = argList[1].node) !== null && _c !== void 0 ? _c : errorNode);
            isBaseClassAny = true;
        }
        // Specifically disallow Annotated.
        if (baseClass.specialForm &&
            (0, types_1.isInstantiableClass)(baseClass.specialForm) &&
            types_1.ClassType.isBuiltIn(baseClass.specialForm, 'Annotated')) {
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.newTypeNotAClass(), argList[1].node || errorNode);
            return undefined;
        }
        if (!(0, types_1.isInstantiableClass)(baseClass)) {
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.newTypeNotAClass(), argList[1].node || errorNode);
            return undefined;
        }
        if (types_1.ClassType.isProtocolClass(baseClass) || types_1.ClassType.isTypedDictClass(baseClass)) {
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.newTypeProtocolClass(), argList[1].node || errorNode);
        }
        else if (baseClass.literalValue !== undefined) {
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.newTypeLiteral(), argList[1].node || errorNode);
        }
        const classType = types_1.ClassType.createInstantiable(className, ParseTreeUtils.getClassFullName(errorNode, fileInfo.moduleName, className), fileInfo.moduleName, fileInfo.fileUri, 256 /* ClassTypeFlags.Final */ | 2097152 /* ClassTypeFlags.NewTypeClass */ | 4194304 /* ClassTypeFlags.ValidTypeAliasClass */, ParseTreeUtils.getTypeSourceId(errorNode), 
        /* declaredMetaclass */ undefined, baseClass.details.effectiveMetaclass);
        classType.details.baseClasses.push(isBaseClassAny ? types_1.AnyType.create() : baseClass);
        (0, typeUtils_1.computeMroLinearization)(classType);
        if (!isBaseClassAny) {
            // Synthesize an __init__ method that accepts only the specified type.
            const initType = types_1.FunctionType.createSynthesizedInstance('__init__');
            types_1.FunctionType.addParameter(initType, {
                category: 0 /* ParameterCategory.Simple */,
                name: 'self',
                type: types_1.ClassType.cloneAsInstance(classType),
                hasDeclaredType: true,
            });
            types_1.FunctionType.addParameter(initType, {
                category: 0 /* ParameterCategory.Simple */,
                name: '_x',
                type: types_1.ClassType.cloneAsInstance(baseClass),
                hasDeclaredType: true,
            });
            initType.details.declaredReturnType = getNoneType();
            types_1.ClassType.getSymbolTable(classType).set('__init__', symbol_1.Symbol.createWithType(4 /* SymbolFlags.ClassMember */, initType));
            // Synthesize a trivial __new__ method.
            const newType = types_1.FunctionType.createSynthesizedInstance('__new__', 1 /* FunctionTypeFlags.ConstructorMethod */);
            types_1.FunctionType.addParameter(newType, {
                category: 0 /* ParameterCategory.Simple */,
                name: 'cls',
                type: classType,
                hasDeclaredType: true,
            });
            types_1.FunctionType.addDefaultParameters(newType);
            newType.details.declaredReturnType = types_1.ClassType.cloneAsInstance(classType);
            newType.details.constructorTypeVarScopeId = (0, typeUtils_1.getTypeVarScopeId)(classType);
            types_1.ClassType.getSymbolTable(classType).set('__new__', symbol_1.Symbol.createWithType(4 /* SymbolFlags.ClassMember */, newType));
        }
        return classType;
    }
    // Implements the semantics of the multi-parameter variant of the "type" call.
    function createClassFromMetaclass(errorNode, argList, metaclass) {
        const fileInfo = AnalyzerNodeInfo.getFileInfo(errorNode);
        const arg0Type = getTypeOfArgument(argList[0], 
        /* inferenceContext */ undefined, 
        /* signatureTracker */ undefined).type;
        if (!(0, types_1.isClassInstance)(arg0Type) || !types_1.ClassType.isBuiltIn(arg0Type, 'str')) {
            return undefined;
        }
        const className = arg0Type.literalValue || '_';
        const arg1Type = getTypeOfArgument(argList[1], 
        /* inferenceContext */ undefined, 
        /* signatureTracker */ undefined).type;
        // TODO - properly handle case where tuple of base classes is provided.
        if (!(0, types_1.isClassInstance)(arg1Type) || !(0, typeUtils_1.isTupleClass)(arg1Type) || arg1Type.tupleTypeArguments === undefined) {
            return undefined;
        }
        const classType = types_1.ClassType.createInstantiable(className, ParseTreeUtils.getClassFullName(errorNode, fileInfo.moduleName, className), fileInfo.moduleName, fileInfo.fileUri, 4194304 /* ClassTypeFlags.ValidTypeAliasClass */, ParseTreeUtils.getTypeSourceId(errorNode), metaclass, arg1Type.details.effectiveMetaclass);
        arg1Type.tupleTypeArguments.forEach((typeArg) => {
            const specializedType = makeTopLevelTypeVarsConcrete(typeArg.type);
            if ((0, typeUtils_1.isEffectivelyInstantiable)(specializedType)) {
                classType.details.baseClasses.push(specializedType);
            }
            else {
                classType.details.baseClasses.push(types_1.UnknownType.create());
            }
        });
        if (!(0, typeUtils_1.computeMroLinearization)(classType)) {
            addError(localize_1.LocMessage.methodOrdering(), errorNode);
        }
        return classType;
    }
    function getTypeOfConstant(node, flags) {
        let type;
        if (node.constType === 26 /* KeywordType.None */) {
            if (noneTypeClass) {
                type = (flags & 128 /* EvalFlags.InstantiableType */) !== 0 ? noneTypeClass : (0, typeUtils_1.convertToInstance)(noneTypeClass);
            }
        }
        else if (node.constType === 33 /* KeywordType.True */ ||
            node.constType === 15 /* KeywordType.False */ ||
            node.constType === 9 /* KeywordType.Debug */) {
            type = getBuiltInObject(node, 'bool');
            // For True and False, we can create truthy and falsy
            // versions of 'bool'.
            if (type && (0, types_1.isClassInstance)(type)) {
                if (node.constType === 33 /* KeywordType.True */) {
                    type = types_1.ClassType.cloneWithLiteral(type, /* value */ true);
                }
                else if (node.constType === 15 /* KeywordType.False */) {
                    type = types_1.ClassType.cloneWithLiteral(type, /* value */ false);
                }
            }
        }
        return { type: type !== null && type !== void 0 ? type : types_1.UnknownType.create() };
    }
    function getTypeOfMagicMethodCall(objType, methodName, argList, errorNode, inferenceContext, diag) {
        let magicMethodSupported = true;
        // Create a helper lambda for object subtypes.
        const handleSubtype = (subtype) => {
            let magicMethodType;
            const concreteSubtype = makeTopLevelTypeVarsConcrete(subtype);
            if ((0, types_1.isClass)(concreteSubtype)) {
                magicMethodType = getBoundMagicMethod(concreteSubtype, methodName, subtype, diag);
            }
            if (magicMethodType) {
                const functionArgs = argList.map((arg) => {
                    return {
                        argumentCategory: 0 /* ArgumentCategory.Simple */,
                        typeResult: arg,
                    };
                });
                let callResult;
                callResult = useSpeculativeMode(errorNode, () => {
                    (0, debug_1.assert)(magicMethodType !== undefined);
                    return validateCallArguments(errorNode, functionArgs, { type: magicMethodType }, 
                    /* typeVarContext */ undefined, 
                    /* skipUnknownArgCheck */ true, inferenceContext, 
                    /* signatureTracker */ undefined);
                });
                // If there were errors with the expected type, try
                // to evaluate without the expected type.
                if (callResult.argumentErrors && inferenceContext) {
                    callResult = useSpeculativeMode(errorNode, () => {
                        (0, debug_1.assert)(magicMethodType !== undefined);
                        return validateCallArguments(errorNode, functionArgs, { type: magicMethodType }, 
                        /* typeVarContext */ undefined, 
                        /* skipUnknownArgCheck */ true, 
                        /* inferenceContext */ undefined, 
                        /* signatureTracker */ undefined);
                    });
                }
                if (callResult.argumentErrors) {
                    magicMethodSupported = false;
                }
                return callResult.returnType;
            }
            magicMethodSupported = false;
            return undefined;
        };
        const returnType = (0, typeUtils_1.mapSubtypes)(objType, (subtype) => {
            if ((0, types_1.isAnyOrUnknown)(subtype)) {
                return subtype;
            }
            if ((0, types_1.isClassInstance)(subtype) || (0, types_1.isInstantiableClass)(subtype) || (0, types_1.isTypeVar)(subtype)) {
                return handleSubtype(subtype);
            }
            if ((0, typeUtils_1.isNoneInstance)(subtype)) {
                if (objectClass && (0, types_1.isInstantiableClass)(objectClass)) {
                    // Use 'object' for 'None'.
                    return handleSubtype((0, typeUtils_1.convertToInstance)(objectClass));
                }
            }
            if ((0, typeUtils_1.isNoneTypeClass)(subtype)) {
                if (typeClass && (0, types_1.isInstantiableClass)(typeClass)) {
                    // Use 'type' for 'type[None]'.
                    return handleSubtype(types_1.ClassType.cloneAsInstance(typeClass));
                }
            }
            magicMethodSupported = false;
            return undefined;
        });
        if (!magicMethodSupported) {
            return undefined;
        }
        return returnType;
    }
    function getTypeOfDictionary(node, flags, inferenceContext) {
        var _a;
        if ((flags & 256 /* EvalFlags.TypeExpression */) !== 0 && ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.nodeType) !== 1 /* ParseNodeType.Argument */) {
            const diag = new diagnostic_1.DiagnosticAddendum();
            diag.addMessage(localize_1.LocAddendum.useDictInstead());
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportInvalidTypeForm, localize_1.LocMessage.dictInAnnotation() + diag.getString(), node);
        }
        // If the expected type is a union, analyze for each of the subtypes
        // to find one that matches.
        let expectedType = inferenceContext === null || inferenceContext === void 0 ? void 0 : inferenceContext.expectedType;
        if (inferenceContext && (0, types_1.isUnion)(inferenceContext.expectedType)) {
            let matchingSubtype;
            let matchingSubtypeResult;
            (0, typeUtils_1.doForEachSubtype)(inferenceContext.expectedType, (subtype) => {
                // Use shortcut if we've already found a match.
                if (matchingSubtypeResult && !matchingSubtypeResult.typeErrors) {
                    return;
                }
                const subtypeResult = useSpeculativeMode(node, () => {
                    return getTypeOfDictionaryWithContext(node, flags, (0, typeUtils_1.makeInferenceContext)(subtype));
                });
                if (subtypeResult && assignType(subtype, subtypeResult.type)) {
                    // If this is the first result we're seeing or it's the first result
                    // without errors, select it as the match.
                    if (!matchingSubtypeResult || (matchingSubtypeResult.typeErrors && !subtypeResult.typeErrors)) {
                        matchingSubtype = subtype;
                        matchingSubtypeResult = subtypeResult;
                    }
                }
            }, 
            /* sortSubtypes */ true);
            expectedType = matchingSubtype;
        }
        let expectedTypeDiagAddendum = undefined;
        if (expectedType) {
            expectedTypeDiagAddendum = new diagnostic_1.DiagnosticAddendum();
            const result = getTypeOfDictionaryWithContext(node, flags, (0, typeUtils_1.makeInferenceContext)(expectedType), expectedTypeDiagAddendum);
            if (result) {
                return result;
            }
        }
        const result = getTypeOfDictionaryInferred(node, flags, /* hasExpectedType */ !!(inferenceContext === null || inferenceContext === void 0 ? void 0 : inferenceContext.expectedType));
        return { ...result, expectedTypeDiagAddendum };
    }
    function getTypeOfDictionaryWithContext(node, flags, inferenceContext, expectedDiagAddendum) {
        inferenceContext.expectedType = (0, typeUtils_1.transformPossibleRecursiveTypeAlias)(inferenceContext.expectedType);
        let concreteExpectedType = makeTopLevelTypeVarsConcrete(inferenceContext.expectedType);
        if (!(0, types_1.isClassInstance)(concreteExpectedType)) {
            return undefined;
        }
        const keyTypes = [];
        const valueTypes = [];
        let isIncomplete = false;
        let typeErrors = false;
        // Handle TypedDict's as a special case.
        if (types_1.ClassType.isTypedDictClass(concreteExpectedType)) {
            // Remove any conditions associated with the type so the resulting type isn't
            // considered compatible with a bound TypeVar.
            concreteExpectedType = types_1.TypeBase.cloneForCondition(concreteExpectedType, undefined);
            const expectedTypedDictEntries = (0, typedDicts_1.getTypedDictMembersForClass)(evaluatorInterface, concreteExpectedType);
            // Infer the key and value types if possible.
            const keyValueTypeResult = getKeyAndValueTypesFromDictionary(node, flags, keyTypes, valueTypes, 
            /* forceStrictInference */ true, 
            /* isValueTypeInvariant */ true, 
            /* expectedKeyType */ undefined, 
            /* expectedValueType */ undefined, expectedTypedDictEntries, expectedDiagAddendum);
            if (keyValueTypeResult.isIncomplete) {
                isIncomplete = true;
            }
            if (keyValueTypeResult.typeErrors) {
                typeErrors = true;
            }
            const resultTypedDict = (0, typedDicts_1.assignToTypedDict)(evaluatorInterface, concreteExpectedType, keyTypes, valueTypes, 
            // Don't overwrite existing expectedDiagAddendum messages if they were
            // already provided by getKeyValueTypesFromDictionary.
            (expectedDiagAddendum === null || expectedDiagAddendum === void 0 ? void 0 : expectedDiagAddendum.isEmpty()) ? expectedDiagAddendum : undefined);
            if (resultTypedDict) {
                return {
                    type: resultTypedDict,
                    isIncomplete,
                };
            }
            return undefined;
        }
        let expectedKeyType;
        let expectedValueType;
        if ((0, types_1.isAnyOrUnknown)(inferenceContext.expectedType)) {
            expectedKeyType = inferenceContext.expectedType;
            expectedValueType = inferenceContext.expectedType;
        }
        else {
            const builtInDict = getBuiltInObject(node, 'dict');
            if (!(0, types_1.isClassInstance)(builtInDict)) {
                return undefined;
            }
            const dictTypeVarContext = new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(builtInDict));
            if (!(0, constraintSolver_1.addConstraintsForExpectedType)(evaluatorInterface, builtInDict, inferenceContext.expectedType, dictTypeVarContext, ParseTreeUtils.getTypeVarScopesForNode(node), node.start)) {
                return undefined;
            }
            const specializedDict = (0, typeUtils_1.applySolvedTypeVars)(types_1.ClassType.cloneAsInstantiable(builtInDict), dictTypeVarContext);
            if (!specializedDict.typeArguments || specializedDict.typeArguments.length !== 2) {
                return undefined;
            }
            expectedKeyType = specializedDict.typeArguments[0];
            expectedValueType = specializedDict.typeArguments[1];
        }
        // Dict and MutableMapping types have invariant value types, so they
        // cannot be narrowed further. Other super-types like Mapping, Collection,
        // and Iterable use covariant value types, so they can be narrowed.
        let isValueTypeInvariant = false;
        if ((0, types_1.isClassInstance)(inferenceContext.expectedType)) {
            if (inferenceContext.expectedType.details.typeParameters.length >= 2) {
                const valueTypeParam = inferenceContext.expectedType.details.typeParameters[1];
                if (types_1.TypeVarType.getVariance(valueTypeParam) === 2 /* Variance.Invariant */) {
                    isValueTypeInvariant = true;
                }
            }
        }
        // Infer the key and value types if possible.
        const keyValueResult = getKeyAndValueTypesFromDictionary(node, flags, keyTypes, valueTypes, 
        /* forceStrictInference */ true, isValueTypeInvariant, expectedKeyType, expectedValueType, undefined, expectedDiagAddendum);
        if (keyValueResult.isIncomplete) {
            isIncomplete = true;
        }
        if (keyValueResult.typeErrors) {
            typeErrors = true;
        }
        const specializedKeyType = inferTypeArgFromExpectedEntryType((0, typeUtils_1.makeInferenceContext)(expectedKeyType), keyTypes.map((result) => result.type), 
        /* isNarrowable */ false);
        const specializedValueType = inferTypeArgFromExpectedEntryType((0, typeUtils_1.makeInferenceContext)(expectedValueType), valueTypes.map((result) => result.type), !isValueTypeInvariant);
        if (!specializedKeyType || !specializedValueType) {
            return undefined;
        }
        const type = getBuiltInObject(node, 'dict', [specializedKeyType, specializedValueType]);
        return { type, isIncomplete, typeErrors };
    }
    // Attempts to infer the type of a dictionary statement. If hasExpectedType
    // is true, strict inference is used for the subexpressions.
    function getTypeOfDictionaryInferred(node, flags, hasExpectedType) {
        const fallbackType = hasExpectedType ? types_1.AnyType.create() : types_1.UnknownType.create();
        let keyType = fallbackType;
        let valueType = fallbackType;
        const keyTypeResults = [];
        const valueTypeResults = [];
        let isEmptyContainer = false;
        let isIncomplete = false;
        let typeErrors = false;
        // Infer the key and value types if possible.
        const keyValueResult = getKeyAndValueTypesFromDictionary(node, flags, keyTypeResults, valueTypeResults, 
        /* forceStrictInference */ hasExpectedType, 
        /* isValueTypeInvariant */ false);
        if (keyValueResult.isIncomplete) {
            isIncomplete = true;
        }
        if (keyValueResult.typeErrors) {
            typeErrors = true;
        }
        // Strip any literal values.
        const keyTypes = keyTypeResults.map((t) => stripLiteralValue(t.type));
        const valueTypes = valueTypeResults.map((t) => stripLiteralValue(t.type));
        keyType = keyTypes.length > 0 ? (0, types_1.combineTypes)(keyTypes) : fallbackType;
        // If the value type differs and we're not using "strict inference mode",
        // we need to back off because we can't properly represent the mappings
        // between different keys and associated value types. If all the values
        // are the same type, we'll assume that all values in this dictionary should
        // be the same.
        if (valueTypes.length > 0) {
            if (AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.strictDictionaryInference || hasExpectedType) {
                valueType = (0, types_1.combineTypes)(valueTypes);
            }
            else {
                valueType = (0, typeUtils_1.areTypesSame)(valueTypes, { ignorePseudoGeneric: true }) ? valueTypes[0] : fallbackType;
            }
        }
        else {
            valueType = fallbackType;
            isEmptyContainer = true;
        }
        const dictClass = getBuiltInType(node, 'dict');
        const type = (0, types_1.isInstantiableClass)(dictClass)
            ? types_1.ClassType.cloneAsInstance(types_1.ClassType.cloneForSpecialization(dictClass, [keyType, valueType], 
            /* isTypeArgumentExplicit */ true, 
            /* includeSubclasses */ undefined, 
            /* TupleTypeArguments */ undefined, isEmptyContainer))
            : types_1.UnknownType.create();
        if (isIncomplete) {
            if ((0, typeUtils_1.getContainerDepth)(type) > maxInferredContainerDepth) {
                return { type: types_1.UnknownType.create() };
            }
        }
        return { type, isIncomplete, typeErrors };
    }
    function getKeyAndValueTypesFromDictionary(node, flags, keyTypes, valueTypes, forceStrictInference, isValueTypeInvariant, expectedKeyType, expectedValueType, expectedTypedDictEntries, expectedDiagAddendum) {
        let isIncomplete = false;
        let typeErrors = false;
        // Mask out some of the flags that are not applicable for a dictionary key
        // even if it appears within an inlined TypedDict annotation.
        const keyFlags = flags & ~(256 /* EvalFlags.TypeExpression */ | 8 /* EvalFlags.StrLiteralAsType */ | 128 /* EvalFlags.InstantiableType */);
        // Infer the key and value types if possible.
        node.entries.forEach((entryNode, index) => {
            var _a, _b, _c;
            let addUnknown = true;
            if (entryNode.nodeType === 20 /* ParseNodeType.DictionaryKeyEntry */) {
                const keyTypeResult = getTypeOfExpression(entryNode.keyExpression, keyFlags | 268435456 /* EvalFlags.StripTupleLiterals */, (0, typeUtils_1.makeInferenceContext)(expectedKeyType !== null && expectedKeyType !== void 0 ? expectedKeyType : (forceStrictInference ? types_1.NeverType.createNever() : undefined)));
                if (keyTypeResult.isIncomplete) {
                    isIncomplete = true;
                }
                if (keyTypeResult.typeErrors) {
                    typeErrors = true;
                }
                const keyType = keyTypeResult.type;
                if (!keyTypeResult.isIncomplete && !keyTypeResult.typeErrors) {
                    verifySetEntryOrDictKeyIsHashable(entryNode.keyExpression, keyType, /* isDictKey */ true);
                }
                if (expectedDiagAddendum && keyTypeResult.expectedTypeDiagAddendum) {
                    expectedDiagAddendum.addAddendum(keyTypeResult.expectedTypeDiagAddendum);
                }
                let valueTypeResult;
                let entryInferenceContext;
                if (expectedTypedDictEntries &&
                    (0, types_1.isClassInstance)(keyType) &&
                    types_1.ClassType.isBuiltIn(keyType, 'str') &&
                    (0, typeUtils_1.isLiteralType)(keyType) &&
                    expectedTypedDictEntries.knownItems.has(keyType.literalValue)) {
                    const effectiveValueType = expectedTypedDictEntries.knownItems.get(keyType.literalValue).valueType;
                    entryInferenceContext = (0, typeUtils_1.makeInferenceContext)(effectiveValueType);
                    valueTypeResult = getTypeOfExpression(entryNode.valueExpression, flags | 268435456 /* EvalFlags.StripTupleLiterals */, entryInferenceContext);
                }
                else {
                    const effectiveValueType = expectedValueType !== null && expectedValueType !== void 0 ? expectedValueType : (forceStrictInference ? types_1.NeverType.createNever() : undefined);
                    entryInferenceContext = (0, typeUtils_1.makeInferenceContext)(effectiveValueType);
                    valueTypeResult = getTypeOfExpression(entryNode.valueExpression, flags | 268435456 /* EvalFlags.StripTupleLiterals */, entryInferenceContext);
                }
                if (entryInferenceContext && !valueTypeResult.typeErrors) {
                    const fromExpectedType = inferTypeArgFromExpectedEntryType(entryInferenceContext, [valueTypeResult.type], !isValueTypeInvariant);
                    if (fromExpectedType) {
                        valueTypeResult = { ...valueTypeResult, type: fromExpectedType };
                    }
                }
                if (expectedDiagAddendum && valueTypeResult.expectedTypeDiagAddendum) {
                    expectedDiagAddendum.addAddendum(valueTypeResult.expectedTypeDiagAddendum);
                }
                const valueType = valueTypeResult.type;
                if (valueTypeResult.isIncomplete) {
                    isIncomplete = true;
                }
                if (valueTypeResult.typeErrors) {
                    typeErrors = true;
                }
                if (forceStrictInference || index < maxEntriesToUseForInference) {
                    // If an existing key has the same literal type, delete the previous
                    // key since we're overwriting it here.
                    if ((0, types_1.isClass)(keyType) && (0, typeUtils_1.isLiteralType)(keyType)) {
                        const existingIndex = keyTypes.findIndex((kt) => (0, types_1.isTypeSame)(keyType, kt.type));
                        if (existingIndex >= 0) {
                            keyTypes.splice(existingIndex, 1);
                            valueTypes.splice(existingIndex, 1);
                        }
                    }
                    keyTypes.push({ node: entryNode.keyExpression, type: keyType });
                    valueTypes.push({ node: entryNode.valueExpression, type: valueType });
                }
                addUnknown = false;
            }
            else if (entryNode.nodeType === 19 /* ParseNodeType.DictionaryExpandEntry */) {
                let expectedType;
                if (expectedKeyType && expectedValueType) {
                    if (supportsKeysAndGetItemClass && (0, types_1.isInstantiableClass)(supportsKeysAndGetItemClass)) {
                        expectedType = types_1.ClassType.cloneAsInstance(types_1.ClassType.cloneForSpecialization(supportsKeysAndGetItemClass, [expectedKeyType, expectedValueType], 
                        /* isTypeArgumentExplicit */ true));
                    }
                }
                const entryInferenceContext = (0, typeUtils_1.makeInferenceContext)(expectedType);
                let unexpandedTypeResult = getTypeOfExpression(entryNode.expandExpression, flags | 268435456 /* EvalFlags.StripTupleLiterals */, entryInferenceContext);
                if (entryInferenceContext && !unexpandedTypeResult.typeErrors) {
                    const fromExpectedType = inferTypeArgFromExpectedEntryType(entryInferenceContext, [unexpandedTypeResult.type], !isValueTypeInvariant);
                    if (fromExpectedType) {
                        unexpandedTypeResult = { ...unexpandedTypeResult, type: fromExpectedType };
                    }
                }
                if (unexpandedTypeResult.isIncomplete) {
                    isIncomplete = true;
                }
                if (unexpandedTypeResult.typeErrors) {
                    typeErrors = true;
                }
                const unexpandedType = unexpandedTypeResult.type;
                if ((0, types_1.isAnyOrUnknown)(unexpandedType)) {
                    addUnknown = false;
                }
                else if ((0, types_1.isClassInstance)(unexpandedType) && types_1.ClassType.isTypedDictClass(unexpandedType)) {
                    // Handle dictionary expansion for a TypedDict.
                    if (strClass && (0, types_1.isInstantiableClass)(strClass)) {
                        const strObject = types_1.ClassType.cloneAsInstance(strClass);
                        const tdEntries = (0, typedDicts_1.getTypedDictMembersForClass)(evaluatorInterface, unexpandedType, 
                        /* allowNarrowed */ true);
                        tdEntries.knownItems.forEach((entry, name) => {
                            if (entry.isRequired || entry.isProvided) {
                                keyTypes.push({
                                    node: entryNode,
                                    type: types_1.ClassType.cloneWithLiteral(strObject, name),
                                });
                                valueTypes.push({ node: entryNode, type: entry.valueType });
                            }
                        });
                        if (!expectedTypedDictEntries) {
                            keyTypes.push({ node: entryNode, type: types_1.ClassType.cloneAsInstance(strObject) });
                            valueTypes.push({
                                node: entryNode,
                                type: (_b = (_a = tdEntries.extraItems) === null || _a === void 0 ? void 0 : _a.valueType) !== null && _b !== void 0 ? _b : getObjectType(),
                            });
                        }
                        addUnknown = false;
                    }
                }
                else if (supportsKeysAndGetItemClass && (0, types_1.isInstantiableClass)(supportsKeysAndGetItemClass)) {
                    const mappingTypeVarContext = new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(supportsKeysAndGetItemClass));
                    supportsKeysAndGetItemClass = (0, typeUtils_1.selfSpecializeClass)(supportsKeysAndGetItemClass);
                    if (assignType(types_1.ClassType.cloneAsInstance(supportsKeysAndGetItemClass), unexpandedType, 
                    /* diag */ undefined, mappingTypeVarContext, 
                    /* srcTypeVarContext */ undefined, 256 /* AssignTypeFlags.RetainLiteralsForTypeVar */)) {
                        const specializedMapping = (0, typeUtils_1.applySolvedTypeVars)(supportsKeysAndGetItemClass, mappingTypeVarContext);
                        const typeArgs = specializedMapping.typeArguments;
                        if (typeArgs && typeArgs.length >= 2) {
                            if (forceStrictInference || index < maxEntriesToUseForInference) {
                                keyTypes.push({ node: entryNode, type: typeArgs[0] });
                                valueTypes.push({ node: entryNode, type: typeArgs[1] });
                            }
                            addUnknown = false;
                        }
                    }
                    else {
                        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.dictUnpackIsNotMapping(), entryNode);
                    }
                }
            }
            else if (entryNode.nodeType === 11 /* ParseNodeType.Comprehension */) {
                const dictEntryTypeResult = getElementTypeFromComprehension(entryNode, flags | 268435456 /* EvalFlags.StripTupleLiterals */, expectedValueType, expectedKeyType);
                const dictEntryType = dictEntryTypeResult.type;
                if (dictEntryTypeResult.isIncomplete) {
                    isIncomplete = true;
                }
                if (dictEntryTypeResult.typeErrors) {
                    typeErrors = true;
                }
                // The result should be a tuple.
                if ((0, types_1.isClassInstance)(dictEntryType) && (0, typeUtils_1.isTupleClass)(dictEntryType)) {
                    const typeArgs = (_c = dictEntryType.tupleTypeArguments) === null || _c === void 0 ? void 0 : _c.map((t) => t.type);
                    if (typeArgs && typeArgs.length === 2) {
                        if (forceStrictInference || index < maxEntriesToUseForInference) {
                            keyTypes.push({ node: entryNode, type: typeArgs[0] });
                            valueTypes.push({ node: entryNode, type: typeArgs[1] });
                        }
                        addUnknown = false;
                    }
                }
            }
            if (addUnknown) {
                if (forceStrictInference || index < maxEntriesToUseForInference) {
                    keyTypes.push({ node: entryNode, type: types_1.UnknownType.create() });
                    valueTypes.push({ node: entryNode, type: types_1.UnknownType.create() });
                }
            }
        });
        return { type: types_1.AnyType.create(), isIncomplete, typeErrors };
    }
    function getTypeOfListOrSet(node, flags, inferenceContext) {
        var _a;
        if ((flags & 256 /* EvalFlags.TypeExpression */) !== 0 &&
            node.nodeType === 34 /* ParseNodeType.List */ &&
            ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.nodeType) !== 1 /* ParseNodeType.Argument */) {
            const diag = new diagnostic_1.DiagnosticAddendum();
            diag.addMessage(localize_1.LocAddendum.useListInstead());
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportInvalidTypeForm, localize_1.LocMessage.listInAnnotation() + diag.getString(), node);
        }
        flags &= ~(256 /* EvalFlags.TypeExpression */ | 8 /* EvalFlags.StrLiteralAsType */ | 128 /* EvalFlags.InstantiableType */);
        // If the expected type is a union, recursively call for each of the subtypes
        // to find one that matches.
        let expectedType = inferenceContext === null || inferenceContext === void 0 ? void 0 : inferenceContext.expectedType;
        if (inferenceContext && (0, types_1.isUnion)(inferenceContext.expectedType)) {
            let matchingSubtype;
            let matchingSubtypeResult;
            (0, typeUtils_1.doForEachSubtype)(inferenceContext.expectedType, (subtype) => {
                // Use shortcut if we've already found a match.
                if (matchingSubtypeResult && !matchingSubtypeResult.typeErrors) {
                    return;
                }
                const subtypeResult = useSpeculativeMode(node, () => {
                    return getTypeOfListOrSetWithContext(node, flags, (0, typeUtils_1.makeInferenceContext)(subtype));
                });
                if (subtypeResult && assignType(subtype, subtypeResult.type)) {
                    // If this is the first result we're seeing or it's the first result
                    // without errors, select it as the match.
                    if (!matchingSubtypeResult || (matchingSubtypeResult.typeErrors && !subtypeResult.typeErrors)) {
                        matchingSubtype = subtype;
                        matchingSubtypeResult = subtypeResult;
                    }
                }
            }, 
            /* sortSubtypes */ true);
            expectedType = matchingSubtype;
        }
        let expectedTypeDiagAddendum;
        if (expectedType) {
            const result = getTypeOfListOrSetWithContext(node, flags, (0, typeUtils_1.makeInferenceContext)(expectedType));
            if (result && !result.typeErrors) {
                return result;
            }
            expectedTypeDiagAddendum = result === null || result === void 0 ? void 0 : result.expectedTypeDiagAddendum;
        }
        const typeResult = getTypeOfListOrSetInferred(node, flags, 
        /* hasExpectedType */ !!(inferenceContext === null || inferenceContext === void 0 ? void 0 : inferenceContext.expectedType));
        return { ...typeResult, expectedTypeDiagAddendum };
    }
    // Attempts to determine the type of a list or set statement based on an expected type.
    // Returns undefined if that type cannot be honored.
    function getTypeOfListOrSetWithContext(node, flags, inferenceContext) {
        const builtInClassName = node.nodeType === 34 /* ParseNodeType.List */ ? 'list' : 'set';
        inferenceContext.expectedType = (0, typeUtils_1.transformPossibleRecursiveTypeAlias)(inferenceContext.expectedType);
        let isIncomplete = false;
        let typeErrors = false;
        const verifyHashable = node.nodeType === 45 /* ParseNodeType.Set */;
        const expectedEntryType = getExpectedEntryTypeForIterable(node, getBuiltInType(node, builtInClassName), inferenceContext);
        if (!expectedEntryType) {
            return undefined;
        }
        const entryTypes = [];
        const expectedTypeDiagAddendum = new diagnostic_1.DiagnosticAddendum();
        node.entries.forEach((entry) => {
            let entryTypeResult;
            if (entry.nodeType === 11 /* ParseNodeType.Comprehension */) {
                entryTypeResult = getElementTypeFromComprehension(entry, flags | 268435456 /* EvalFlags.StripTupleLiterals */, expectedEntryType);
            }
            else {
                entryTypeResult = getTypeOfExpression(entry, flags | 268435456 /* EvalFlags.StripTupleLiterals */, (0, typeUtils_1.makeInferenceContext)(expectedEntryType));
            }
            entryTypes.push(entryTypeResult.type);
            if (entryTypeResult.isIncomplete) {
                isIncomplete = true;
            }
            if (entryTypeResult.typeErrors) {
                typeErrors = true;
            }
            if (entryTypeResult.expectedTypeDiagAddendum) {
                expectedTypeDiagAddendum.addAddendum(entryTypeResult.expectedTypeDiagAddendum);
            }
            if (verifyHashable && !entryTypeResult.isIncomplete && !entryTypeResult.typeErrors) {
                verifySetEntryOrDictKeyIsHashable(entry, entryTypeResult.type, /* isDictKey */ false);
            }
        });
        let isTypeInvariant = false;
        if ((0, types_1.isClassInstance)(inferenceContext.expectedType)) {
            inferTypeParameterVarianceForClass(inferenceContext.expectedType);
            if (inferenceContext.expectedType.details.typeParameters.some((t) => types_1.TypeVarType.getVariance(t) === 2 /* Variance.Invariant */)) {
                isTypeInvariant = true;
            }
        }
        const specializedEntryType = inferTypeArgFromExpectedEntryType((0, typeUtils_1.makeInferenceContext)(expectedEntryType), entryTypes, !isTypeInvariant);
        if (!specializedEntryType) {
            return { type: types_1.UnknownType.create(), isIncomplete, typeErrors: true, expectedTypeDiagAddendum };
        }
        const type = getBuiltInObject(node, builtInClassName, [specializedEntryType]);
        return { type, isIncomplete, typeErrors, expectedTypeDiagAddendum };
    }
    function getExpectedEntryTypeForIterable(node, expectedClassType, inferenceContext) {
        if (!inferenceContext) {
            return undefined;
        }
        if (!expectedClassType || !(0, types_1.isInstantiableClass)(expectedClassType)) {
            return undefined;
        }
        if ((0, types_1.isAnyOrUnknown)(inferenceContext.expectedType)) {
            return inferenceContext.expectedType;
        }
        if (!(0, types_1.isClassInstance)(inferenceContext.expectedType)) {
            return undefined;
        }
        const typeVarContext = new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(expectedClassType));
        if (!(0, constraintSolver_1.addConstraintsForExpectedType)(evaluatorInterface, types_1.ClassType.cloneAsInstance(expectedClassType), inferenceContext.expectedType, typeVarContext, ParseTreeUtils.getTypeVarScopesForNode(node), node.start)) {
            return undefined;
        }
        const specializedListOrSet = (0, typeUtils_1.applySolvedTypeVars)(expectedClassType, typeVarContext);
        if (!specializedListOrSet.typeArguments) {
            return undefined;
        }
        return specializedListOrSet.typeArguments[0];
    }
    // Attempts to infer the type of a list or set statement with no "expected type".
    function getTypeOfListOrSetInferred(node, flags, hasExpectedType) {
        const builtInClassName = node.nodeType === 34 /* ParseNodeType.List */ ? 'list' : 'set';
        const verifyHashable = node.nodeType === 45 /* ParseNodeType.Set */;
        let isEmptyContainer = false;
        let isIncomplete = false;
        let typeErrors = false;
        let entryTypes = [];
        node.entries.forEach((entry, index) => {
            let entryTypeResult;
            if (entry.nodeType === 11 /* ParseNodeType.Comprehension */ && !entry.isGenerator) {
                entryTypeResult = getElementTypeFromComprehension(entry, flags | 268435456 /* EvalFlags.StripTupleLiterals */);
            }
            else {
                entryTypeResult = getTypeOfExpression(entry, flags | 268435456 /* EvalFlags.StripTupleLiterals */);
            }
            if (entryTypeResult.isIncomplete) {
                isIncomplete = true;
            }
            if (entryTypeResult.typeErrors) {
                typeErrors = true;
            }
            if (hasExpectedType || index < maxEntriesToUseForInference) {
                entryTypes.push(entryTypeResult.type);
            }
            if (verifyHashable && !entryTypeResult.isIncomplete && !entryTypeResult.typeErrors) {
                verifySetEntryOrDictKeyIsHashable(entry, entryTypeResult.type, /* isDictKey */ false);
            }
        });
        entryTypes = entryTypes.map((t) => stripLiteralValue(t));
        let inferredEntryType = hasExpectedType ? types_1.AnyType.create() : types_1.UnknownType.create();
        if (entryTypes.length > 0) {
            const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
            // If there was an expected type or we're using strict list inference,
            // combine the types into a union.
            if ((builtInClassName === 'list' && fileInfo.diagnosticRuleSet.strictListInference) ||
                (builtInClassName === 'set' && fileInfo.diagnosticRuleSet.strictSetInference) ||
                hasExpectedType) {
                inferredEntryType = (0, types_1.combineTypes)(entryTypes, typeEvaluatorTypes_1.maxSubtypesForInferredType);
            }
            else {
                // Is the list or set homogeneous? If so, use stricter rules. Otherwise relax the rules.
                inferredEntryType = (0, typeUtils_1.areTypesSame)(entryTypes, { ignorePseudoGeneric: true })
                    ? entryTypes[0]
                    : inferredEntryType;
            }
        }
        else {
            isEmptyContainer = true;
        }
        const listOrSetClass = getBuiltInType(node, builtInClassName);
        const type = (0, types_1.isInstantiableClass)(listOrSetClass)
            ? types_1.ClassType.cloneAsInstance(types_1.ClassType.cloneForSpecialization(listOrSetClass, [inferredEntryType], 
            /* isTypeArgumentExplicit */ true, 
            /* includeSubclasses */ undefined, 
            /* TupleTypeArguments */ undefined, isEmptyContainer))
            : types_1.UnknownType.create();
        if (isIncomplete) {
            if ((0, typeUtils_1.getContainerDepth)(type) > maxInferredContainerDepth) {
                return { type: types_1.UnknownType.create() };
            }
        }
        return { type, isIncomplete, typeErrors };
    }
    function verifySetEntryOrDictKeyIsHashable(entry, type, isDictKey) {
        // Verify that the type is hashable.
        if (!isTypeHashable(type)) {
            const diag = new diagnostic_1.DiagnosticAddendum();
            diag.addMessage(localize_1.LocAddendum.unhashableType().format({ type: printType(type) }));
            const message = isDictKey ? localize_1.LocMessage.unhashableDictKey() : localize_1.LocMessage.unhashableSetEntry();
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportUnhashable, message + diag.getString(), entry);
        }
    }
    function inferTypeArgFromExpectedEntryType(inferenceContext, entryTypes, isNarrowable) {
        // If the expected type is Any, the resulting type becomes Any.
        if ((0, types_1.isAny)(inferenceContext.expectedType)) {
            return inferenceContext.expectedType;
        }
        const typeVarContext = new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(inferenceContext.expectedType));
        const expectedType = inferenceContext.expectedType;
        let isCompatible = true;
        entryTypes.forEach((entryType) => {
            if (isCompatible && !assignType(expectedType, entryType, /* diag */ undefined, typeVarContext)) {
                isCompatible = false;
            }
        });
        if (!isCompatible) {
            return undefined;
        }
        if (isNarrowable && entryTypes.length > 0) {
            const combinedTypes = (0, types_1.combineTypes)(entryTypes);
            return (0, typeUtils_1.containsLiteralType)(inferenceContext.expectedType)
                ? combinedTypes
                : stripLiteralValue(combinedTypes);
        }
        return (0, typeUtils_1.mapSubtypes)((0, typeUtils_1.applySolvedTypeVars)(inferenceContext.expectedType, typeVarContext, { applyInScopePlaceholders: true }), (subtype) => {
            if (entryTypes.length !== 1) {
                return subtype;
            }
            const entryType = entryTypes[0];
            // If the entry type is a TypedDict instance, clone it with additional information.
            if ((0, types_1.isTypeSame)(subtype, entryType, { ignoreTypedDictNarrowEntries: true }) &&
                (0, types_1.isClass)(subtype) &&
                (0, types_1.isClass)(entryType) &&
                types_1.ClassType.isTypedDictClass(entryType)) {
                return types_1.ClassType.cloneForNarrowedTypedDictEntries(subtype, entryType.typedDictNarrowedEntries);
            }
            return subtype;
        });
    }
    function getTypeOfYield(node) {
        let expectedYieldType;
        let sentType;
        let isIncomplete = false;
        const enclosingFunction = ParseTreeUtils.getEnclosingFunction(node);
        if (enclosingFunction) {
            const functionTypeInfo = getTypeOfFunction(enclosingFunction);
            if (functionTypeInfo) {
                const returnType = types_1.FunctionType.getEffectiveReturnType(functionTypeInfo.functionType);
                if (returnType) {
                    expectedYieldType = (0, typeUtils_1.getGeneratorYieldType)(returnType, !!enclosingFunction.isAsync);
                    const generatorTypeArgs = (0, typeUtils_1.getGeneratorTypeArgs)(returnType);
                    if (generatorTypeArgs && generatorTypeArgs.length >= 2) {
                        sentType = generatorTypeArgs[1];
                    }
                }
            }
        }
        if (node.expression) {
            const exprResult = getTypeOfExpression(node.expression, 
            /* flags */ undefined, (0, typeUtils_1.makeInferenceContext)(expectedYieldType));
            if (exprResult.isIncomplete) {
                isIncomplete = true;
            }
        }
        return { type: sentType || types_1.UnknownType.create(), isIncomplete };
    }
    function getTypeOfYieldFrom(node) {
        const yieldFromTypeResult = getTypeOfExpression(node.expression);
        const yieldFromType = yieldFromTypeResult.type;
        const returnedType = (0, typeUtils_1.mapSubtypes)(yieldFromType, (yieldFromSubtype) => {
            var _a, _b;
            // Is the expression a Generator type?
            let generatorTypeArgs = (0, typeUtils_1.getGeneratorTypeArgs)(yieldFromSubtype);
            if (generatorTypeArgs) {
                return generatorTypeArgs.length >= 2 ? generatorTypeArgs[2] : types_1.UnknownType.create();
            }
            // Handle old-style (pre-await) Coroutines as a special case.
            if ((0, types_1.isClassInstance)(yieldFromSubtype) && types_1.ClassType.isBuiltIn(yieldFromSubtype, 'Coroutine')) {
                return types_1.UnknownType.create();
            }
            // Handle simple iterables.
            const iterableType = (_b = (_a = getTypeOfIterable(yieldFromTypeResult, /* isAsync */ false, node)) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : types_1.UnknownType.create();
            // Does the iterable return a Generator?
            generatorTypeArgs = (0, typeUtils_1.getGeneratorTypeArgs)(iterableType);
            return generatorTypeArgs && generatorTypeArgs.length >= 2 ? generatorTypeArgs[2] : types_1.UnknownType.create();
        });
        return { type: returnedType };
    }
    function getTypeOfLambda(node, inferenceContext) {
        let expectedFunctionTypes = [];
        if (inferenceContext) {
            (0, typeUtils_1.mapSubtypes)(inferenceContext.expectedType, (subtype) => {
                if ((0, types_1.isFunction)(subtype)) {
                    expectedFunctionTypes.push(subtype);
                }
                if ((0, types_1.isClassInstance)(subtype)) {
                    const boundMethod = getBoundMagicMethod(subtype, '__call__');
                    if (boundMethod && (0, types_1.isFunction)(boundMethod)) {
                        expectedFunctionTypes.push(boundMethod);
                    }
                }
                return undefined;
            });
        }
        let expectedSubtype;
        // If there's more than one type, try each in turn until we find one that works.
        if (expectedFunctionTypes.length > 1) {
            // Sort the expected types for deterministic results.
            expectedFunctionTypes = (0, typeUtils_1.sortTypes)(expectedFunctionTypes);
            for (const subtype of expectedFunctionTypes) {
                const result = getTypeOfLambdaWithExpectedType(node, subtype, inferenceContext, 
                /* forceSpeculative */ true);
                if (!result.typeErrors) {
                    expectedSubtype = subtype;
                    break;
                }
            }
        }
        if (!expectedSubtype && expectedFunctionTypes.length > 0) {
            expectedSubtype = expectedFunctionTypes[0];
        }
        return getTypeOfLambdaWithExpectedType(node, expectedSubtype, inferenceContext, /* forceSpeculative */ false);
    }
    function getTypeOfLambdaWithExpectedType(node, expectedType, inferenceContext, forceSpeculative) {
        let isIncomplete = !!(inferenceContext === null || inferenceContext === void 0 ? void 0 : inferenceContext.isTypeIncomplete);
        let paramsArePositionOnly = true;
        let expectedReturnType;
        let expectedParamDetails;
        if (expectedType) {
            const liveTypeVarScopes = ParseTreeUtils.getTypeVarScopesForNode(node);
            expectedType = (0, typeUtils_1.transformExpectedType)(expectedType, liveTypeVarScopes, node.start);
            expectedParamDetails = (0, parameterUtils_1.getParameterListDetails)(expectedType);
            expectedReturnType = getFunctionEffectiveReturnType(expectedType);
        }
        let functionType = types_1.FunctionType.createInstance('', '', '', 131072 /* FunctionTypeFlags.PartiallyEvaluated */);
        functionType.details.typeVarScopeId = ParseTreeUtils.getScopeIdForNode(node);
        return (0, cancellationUtils_1.invalidateTypeCacheIfCanceled)(() => {
            // Pre-cache the incomplete function type in case the evaluation of the
            // lambda depends on itself.
            writeTypeCache(node, { type: functionType, isIncomplete: true }, 0 /* EvalFlags.None */);
            // We assume for simplicity that the parameter signature of the lambda is
            // the same as the expected type. If this isn't the case, we'll use
            // object for any lambda parameters that don't match. We could make this
            // more sophisticated in the future, but it becomes very complex to handle
            // all of the permutations.
            let sawParamMismatch = false;
            node.parameters.forEach((param, index) => {
                let paramType;
                if (expectedParamDetails && !sawParamMismatch) {
                    if (index < expectedParamDetails.params.length) {
                        const expectedParam = expectedParamDetails.params[index];
                        // If the parameter category matches and both of the parameters are
                        // either separators (/ or *) or not separators, copy the type
                        // from the expected parameter.
                        if (expectedParam.param.category === param.category &&
                            !param.name === !expectedParam.param.name) {
                            paramType = expectedParam.type;
                        }
                        else {
                            sawParamMismatch = true;
                        }
                    }
                    else if (param.defaultValue) {
                        // If the lambda param has a default value but there is no associated
                        // parameter in the expected type, assume that the default value is
                        // being used to explicitly capture a value from an outer scope. Infer
                        // its type from the default value expression.
                        paramType = getTypeOfExpression(param.defaultValue, undefined, inferenceContext).type;
                    }
                }
                else if (param.defaultValue) {
                    // If there is no inference context but we have a default value,
                    // use the default value to infer the parameter's type.
                    paramType = inferParameterTypeFromDefaultValue(param.defaultValue);
                }
                if (param.name) {
                    writeTypeCache(param.name, { type: transformVariadicParamType(node, param.category, paramType !== null && paramType !== void 0 ? paramType : types_1.UnknownType.create()) }, 0 /* EvalFlags.None */);
                }
                if (param.defaultValue) {
                    // Evaluate the default value if it's present.
                    getTypeOfExpression(param.defaultValue, 1 /* EvalFlags.ConvertEllipsisToAny */);
                }
                // Determine whether we need to insert an implied position-only parameter.
                // This is needed when a function's parameters are named using the old-style
                // way of specifying position-only parameters.
                if (index >= 0) {
                    let isImplicitPositionOnlyParam = false;
                    if (param.category === 0 /* ParameterCategory.Simple */ && param.name) {
                        if ((0, symbolNameUtils_1.isPrivateName)(param.name.value)) {
                            isImplicitPositionOnlyParam = true;
                        }
                    }
                    else {
                        paramsArePositionOnly = false;
                    }
                    if (paramsArePositionOnly &&
                        !isImplicitPositionOnlyParam &&
                        functionType.details.parameters.length > 0) {
                        types_1.FunctionType.addPositionOnlyParameterSeparator(functionType);
                    }
                    if (!isImplicitPositionOnlyParam) {
                        paramsArePositionOnly = false;
                    }
                }
                const functionParam = {
                    category: param.category,
                    name: param.name ? param.name.value : undefined,
                    hasDefault: !!param.defaultValue,
                    defaultValueExpression: param.defaultValue,
                    hasDeclaredType: true,
                    type: paramType !== null && paramType !== void 0 ? paramType : types_1.UnknownType.create(),
                };
                types_1.FunctionType.addParameter(functionType, functionParam);
            });
            if (paramsArePositionOnly && functionType.details.parameters.length > 0) {
                types_1.FunctionType.addPositionOnlyParameterSeparator(functionType);
            }
            let typeErrors = false;
            // If we're speculatively evaluating the lambda, create another speculative
            // evaluation scope for the return expression and do not allow retention
            // of the cached types.
            // We need to set allowCacheRetention to false because we don't want to
            // cache the type of the lambda return expression because it depends on
            // the parameter types that we set above, and the speculative type cache
            // doesn't know about that context.
            useSpeculativeMode(forceSpeculative || isSpeculativeModeInUse(node) || (inferenceContext === null || inferenceContext === void 0 ? void 0 : inferenceContext.isTypeIncomplete)
                ? node.expression
                : undefined, () => {
                const returnTypeResult = getTypeOfExpression(node.expression, 
                /* flags */ undefined, (0, typeUtils_1.makeInferenceContext)(expectedReturnType));
                functionType.inferredReturnType = returnTypeResult.type;
                if (returnTypeResult.isIncomplete) {
                    isIncomplete = true;
                }
                if (returnTypeResult.typeErrors) {
                    typeErrors = true;
                }
                else if (expectedReturnType) {
                    // If the expectedReturnType is generic, see if the actual return type
                    // provides types for some or all type variables.
                    if ((0, typeUtils_1.requiresSpecialization)(expectedReturnType)) {
                        const typeVarContext = new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(functionType));
                        if (assignType(expectedReturnType, returnTypeResult.type, 
                        /* diag */ undefined, typeVarContext)) {
                            functionType = (0, typeUtils_1.applySolvedTypeVars)(functionType, typeVarContext, {
                                applyInScopePlaceholders: true,
                            });
                        }
                    }
                }
            }, {
                dependentType: inferenceContext === null || inferenceContext === void 0 ? void 0 : inferenceContext.expectedType,
                allowDiagnostics: !forceSpeculative && !canSkipDiagnosticForNode(node) && !(inferenceContext === null || inferenceContext === void 0 ? void 0 : inferenceContext.isTypeIncomplete),
            });
            // Mark the function type as no longer being evaluated.
            functionType.details.flags &= ~131072 /* FunctionTypeFlags.PartiallyEvaluated */;
            // Is the resulting function compatible with the expected type?
            if (expectedType && !assignType(expectedType, functionType)) {
                typeErrors = true;
            }
            return { type: functionType, isIncomplete, typeErrors };
        });
    }
    function getTypeOfComprehension(node, flags, inferenceContext) {
        let isIncomplete = false;
        let typeErrors = false;
        // If any of the "for" clauses are marked async or any of the "if" clauses
        // or any clause other than the leftmost "for" contain an "await" operator,
        // it is treated as an async generator.
        let isAsync = node.forIfNodes.some((comp, index) => {
            if (comp.nodeType === 12 /* ParseNodeType.ComprehensionFor */ && comp.isAsync) {
                return true;
            }
            return index > 0 && ParseTreeUtils.containsAwaitNode(comp);
        });
        let type = types_1.UnknownType.create();
        if (ParseTreeUtils.containsAwaitNode(node.expression)) {
            isAsync = true;
        }
        const builtInIteratorType = getTypingType(node, isAsync ? 'AsyncGenerator' : 'Generator');
        const expectedEntryType = getExpectedEntryTypeForIterable(node, builtInIteratorType, inferenceContext);
        const elementTypeResult = getElementTypeFromComprehension(node, flags | 268435456 /* EvalFlags.StripTupleLiterals */, expectedEntryType);
        if (elementTypeResult.isIncomplete) {
            isIncomplete = true;
        }
        if (elementTypeResult.typeErrors) {
            typeErrors = true;
        }
        let elementType = elementTypeResult.type;
        if (!expectedEntryType || !(0, typeUtils_1.containsLiteralType)(expectedEntryType)) {
            elementType = stripLiteralValue(elementType);
        }
        if (builtInIteratorType && (0, types_1.isInstantiableClass)(builtInIteratorType)) {
            type = types_1.ClassType.cloneAsInstance(types_1.ClassType.cloneForSpecialization(builtInIteratorType, isAsync ? [elementType, getNoneType()] : [elementType, getNoneType(), getNoneType()], 
            /* isTypeArgumentExplicit */ true));
        }
        return { type, isIncomplete, typeErrors };
    }
    function reportPossibleUnknownAssignment(diagLevel, rule, target, type, errorNode, ignoreEmptyContainers) {
        // Don't bother if the feature is disabled.
        if (diagLevel === 'none') {
            return;
        }
        const nameValue = target.value;
        // Sometimes variables contain an "unbound" type if they're
        // assigned only within conditional statements. Remove this
        // to avoid confusion.
        const simplifiedType = (0, types_1.removeUnbound)(type);
        if ((0, types_1.isUnknown)(simplifiedType)) {
            addDiagnostic(rule, localize_1.LocMessage.typeUnknown().format({ name: nameValue }), errorNode);
        }
        else if ((0, typeUtils_1.isPartlyUnknown)(simplifiedType)) {
            // If ignoreEmptyContainers is true, don't report the problem for
            // empty containers (lists or dictionaries). We'll report the problem
            // only if the assigned value is used later.
            if (!ignoreEmptyContainers || !(0, types_1.isClassInstance)(type) || !type.isEmptyContainer) {
                const diagAddendum = new diagnostic_1.DiagnosticAddendum();
                diagAddendum.addMessage(localize_1.LocAddendum.typeOfSymbol().format({
                    name: nameValue,
                    type: printType(simplifiedType, { expandTypeAlias: true }),
                }));
                addDiagnostic(rule, localize_1.LocMessage.typePartiallyUnknown().format({ name: nameValue }) + diagAddendum.getString(), errorNode);
            }
        }
    }
    function evaluateComprehensionForIf(node) {
        var _a;
        let isIncomplete = false;
        if (node.nodeType === 12 /* ParseNodeType.ComprehensionFor */) {
            const iterableTypeResult = getTypeOfExpression(node.iterableExpression);
            if (iterableTypeResult.isIncomplete) {
                isIncomplete = true;
            }
            const iterableType = stripLiteralValue(iterableTypeResult.type);
            const itemTypeResult = (_a = getTypeOfIterator({ type: iterableType, isIncomplete: iterableTypeResult.isIncomplete }, !!node.isAsync, node.iterableExpression)) !== null && _a !== void 0 ? _a : { type: types_1.UnknownType.create(), isIncomplete: iterableTypeResult.isIncomplete };
            const targetExpr = node.targetExpression;
            assignTypeToExpression(targetExpr, itemTypeResult, node.iterableExpression);
        }
        else {
            (0, debug_1.assert)(node.nodeType === 13 /* ParseNodeType.ComprehensionIf */);
            // Evaluate the test expression to validate it and mark symbols
            // as referenced. This doesn't affect the type of the evaluated
            // comprehension, but it is important for evaluating intermediate
            // expressions such as assignment expressions that can affect other
            // subexpressions.
            getTypeOfExpression(node.testExpression);
        }
        return isIncomplete;
    }
    // Returns the type of one entry returned by the comprehension.
    function getElementTypeFromComprehension(node, flags, expectedValueOrElementType, expectedKeyType) {
        let isIncomplete = false;
        let typeErrors = false;
        // "Execute" the list comprehensions from start to finish.
        for (const forIfNode of node.forIfNodes) {
            if (evaluateComprehensionForIf(forIfNode)) {
                isIncomplete = true;
            }
        }
        let type = types_1.UnknownType.create();
        if (node.expression.nodeType === 20 /* ParseNodeType.DictionaryKeyEntry */) {
            // Create a tuple with the key/value types.
            const keyTypeResult = getTypeOfExpression(node.expression.keyExpression, flags, (0, typeUtils_1.makeInferenceContext)(expectedKeyType));
            if (keyTypeResult.isIncomplete) {
                isIncomplete = true;
            }
            if (keyTypeResult.typeErrors) {
                typeErrors = true;
            }
            let keyType = keyTypeResult.type;
            if (!expectedKeyType || !(0, typeUtils_1.containsLiteralType)(expectedKeyType)) {
                keyType = stripLiteralValue(keyType);
            }
            const valueTypeResult = getTypeOfExpression(node.expression.valueExpression, flags, (0, typeUtils_1.makeInferenceContext)(expectedValueOrElementType));
            if (valueTypeResult.isIncomplete) {
                isIncomplete = true;
            }
            if (valueTypeResult.typeErrors) {
                typeErrors = true;
            }
            let valueType = valueTypeResult.type;
            if (!expectedValueOrElementType || !(0, typeUtils_1.containsLiteralType)(expectedValueOrElementType)) {
                valueType = stripLiteralValue(valueType);
            }
            type = makeTupleObject([
                { type: keyType, isUnbounded: false },
                { type: valueType, isUnbounded: false },
            ]);
        }
        else if (node.expression.nodeType === 19 /* ParseNodeType.DictionaryExpandEntry */) {
            // The parser should have reported an error in this case because it's not allowed.
            getTypeOfExpression(node.expression.expandExpression, flags, (0, typeUtils_1.makeInferenceContext)(expectedValueOrElementType));
        }
        else if ((0, parseNodes_1.isExpressionNode)(node)) {
            const exprTypeResult = getTypeOfExpression(node.expression, flags, (0, typeUtils_1.makeInferenceContext)(expectedValueOrElementType));
            if (exprTypeResult.isIncomplete) {
                isIncomplete = true;
            }
            if (exprTypeResult.typeErrors) {
                typeErrors = true;
            }
            type = exprTypeResult.type;
        }
        return { type, isIncomplete, typeErrors };
    }
    function getTypeOfSlice(node) {
        // Evaluate the expressions to report errors and record symbol
        // references. We can skip this if we're executing speculatively.
        if (!isSpeculativeModeInUse(node)) {
            if (node.startValue) {
                getTypeOfExpression(node.startValue);
            }
            if (node.endValue) {
                getTypeOfExpression(node.endValue);
            }
            if (node.stepValue) {
                getTypeOfExpression(node.stepValue);
            }
        }
        return { type: getBuiltInObject(node, 'slice') };
    }
    // Verifies that a type argument's type is not disallowed.
    function validateTypeArg(argResult, options) {
        if (argResult.typeList) {
            if (!(options === null || options === void 0 ? void 0 : options.allowTypeArgList)) {
                addError(localize_1.LocMessage.typeArgListNotAllowed(), argResult.node);
                return false;
            }
            else {
                argResult.typeList.forEach((typeArg) => {
                    validateTypeArg(typeArg);
                });
            }
        }
        if ((0, typeUtils_1.isEllipsisType)(argResult.type)) {
            if (!(options === null || options === void 0 ? void 0 : options.allowTypeArgList)) {
                addError(localize_1.LocMessage.ellipsisContext(), argResult.node);
                return false;
            }
        }
        if ((0, types_1.isModule)(argResult.type)) {
            addError(localize_1.LocMessage.moduleAsType(), argResult.node);
            return false;
        }
        if ((0, types_1.isParamSpec)(argResult.type)) {
            if (!(options === null || options === void 0 ? void 0 : options.allowParamSpec)) {
                addError(localize_1.LocMessage.paramSpecContext(), argResult.node);
                return false;
            }
        }
        if ((0, types_1.isVariadicTypeVar)(argResult.type) && !argResult.type.isVariadicInUnion) {
            if (!(options === null || options === void 0 ? void 0 : options.allowVariadicTypeVar)) {
                addError(localize_1.LocMessage.typeVarTupleContext(), argResult.node);
                return false;
            }
            else {
                validateVariadicTypeVarIsUnpacked(argResult.type, argResult.node);
            }
        }
        if (!(options === null || options === void 0 ? void 0 : options.allowEmptyTuple) && argResult.isEmptyTupleShorthand) {
            addError(localize_1.LocMessage.zeroLengthTupleNotAllowed(), argResult.node);
            return false;
        }
        if ((0, types_1.isUnpackedClass)(argResult.type)) {
            if (!(options === null || options === void 0 ? void 0 : options.allowUnpackedTuples)) {
                addError(localize_1.LocMessage.unpackedArgInTypeArgument(), argResult.node);
                return false;
            }
        }
        return true;
    }
    // Evaluates the type arguments for a Callable type. It should have zero
    // to two arguments.The first argument, if present, should be an ellipsis,
    // a ParamSpec, a Concatenate, or a list of positional parameter types.
    // The second argument, if present, should specify the return type.
    function createCallableType(classType, typeArgs, errorNode) {
        const functionType = types_1.FunctionType.createInstantiable(0 /* FunctionTypeFlags.None */);
        let paramSpec;
        functionType.specialForm = classType;
        functionType.details.declaredReturnType = types_1.UnknownType.create();
        functionType.details.typeVarScopeId = ParseTreeUtils.getScopeIdForNode(errorNode);
        if (typeArgs && typeArgs.length > 0) {
            functionType.isCallableWithTypeArgs = true;
            if (typeArgs[0].typeList) {
                const typeList = typeArgs[0].typeList;
                let sawUnpacked = false;
                let reportedUnpackedError = false;
                const noteSawUnpacked = (entry) => {
                    // Make sure we have at most one unpacked variadic type variable.
                    if (sawUnpacked) {
                        if (!reportedUnpackedError) {
                            addError(localize_1.LocMessage.variadicTypeArgsTooMany(), entry.node);
                            reportedUnpackedError = true;
                        }
                    }
                    sawUnpacked = true;
                };
                typeList.forEach((entry, index) => {
                    var _a;
                    let entryType = entry.type;
                    let paramCategory = 0 /* ParameterCategory.Simple */;
                    const paramName = `__p${index.toString()}`;
                    if ((0, types_1.isVariadicTypeVar)(entryType)) {
                        validateVariadicTypeVarIsUnpacked(entryType, entry.node);
                        paramCategory = 1 /* ParameterCategory.ArgsList */;
                        noteSawUnpacked(entry);
                    }
                    else if (validateTypeArg(entry, { allowUnpackedTuples: true })) {
                        if ((0, types_1.isUnpackedClass)(entryType)) {
                            paramCategory = 1 /* ParameterCategory.ArgsList */;
                            if ((_a = entryType.tupleTypeArguments) === null || _a === void 0 ? void 0 : _a.some((typeArg) => (0, types_1.isVariadicTypeVar)(typeArg.type) || typeArg.isUnbounded)) {
                                noteSawUnpacked(entry);
                            }
                        }
                    }
                    else {
                        entryType = types_1.UnknownType.create();
                    }
                    types_1.FunctionType.addParameter(functionType, {
                        category: paramCategory,
                        name: paramName,
                        isNameSynthesized: true,
                        type: (0, typeUtils_1.convertToInstance)(entryType),
                        hasDeclaredType: true,
                    });
                });
                if (typeList.length > 0) {
                    types_1.FunctionType.addPositionOnlyParameterSeparator(functionType);
                }
            }
            else if ((0, typeUtils_1.isEllipsisType)(typeArgs[0].type)) {
                types_1.FunctionType.addDefaultParameters(functionType);
                functionType.details.flags |= 32768 /* FunctionTypeFlags.GradualCallableForm */;
            }
            else if ((0, types_1.isParamSpec)(typeArgs[0].type)) {
                paramSpec = typeArgs[0].type;
            }
            else {
                if ((0, types_1.isInstantiableClass)(typeArgs[0].type) && types_1.ClassType.isBuiltIn(typeArgs[0].type, 'Concatenate')) {
                    const concatTypeArgs = typeArgs[0].type.typeArguments;
                    if (concatTypeArgs && concatTypeArgs.length > 0) {
                        concatTypeArgs.forEach((typeArg, index) => {
                            if (index === concatTypeArgs.length - 1) {
                                types_1.FunctionType.addPositionOnlyParameterSeparator(functionType);
                                if ((0, types_1.isParamSpec)(typeArg)) {
                                    paramSpec = typeArg;
                                }
                                else if ((0, typeUtils_1.isEllipsisType)(typeArg)) {
                                    types_1.FunctionType.addDefaultParameters(functionType);
                                    functionType.details.flags |= 32768 /* FunctionTypeFlags.GradualCallableForm */;
                                }
                            }
                            else {
                                types_1.FunctionType.addParameter(functionType, {
                                    category: 0 /* ParameterCategory.Simple */,
                                    name: `__p${index}`,
                                    isNameSynthesized: true,
                                    hasDeclaredType: true,
                                    type: typeArg,
                                });
                            }
                        });
                    }
                }
                else {
                    addError(localize_1.LocMessage.callableFirstArg(), typeArgs[0].node);
                }
            }
            if (typeArgs.length > 1) {
                let typeArg1Type = typeArgs[1].type;
                if (!validateTypeArg(typeArgs[1])) {
                    typeArg1Type = types_1.UnknownType.create();
                }
                functionType.details.declaredReturnType = (0, typeUtils_1.convertToInstance)(typeArg1Type);
            }
            else {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportMissingTypeArgument, localize_1.LocMessage.callableSecondArg(), errorNode);
                functionType.details.declaredReturnType = types_1.UnknownType.create();
            }
            if (typeArgs.length > 2) {
                addError(localize_1.LocMessage.callableExtraArgs(), typeArgs[2].node);
            }
        }
        else {
            types_1.FunctionType.addDefaultParameters(functionType, /* useUnknown */ true);
            functionType.details.flags |= 32768 /* FunctionTypeFlags.GradualCallableForm */;
        }
        if (paramSpec) {
            types_1.FunctionType.addParamSpecVariadics(functionType, paramSpec);
        }
        return functionType;
    }
    // Creates an Optional[X] type.
    function createOptionalType(classType, errorNode, typeArgs, flags) {
        if (!typeArgs) {
            // If no type arguments are provided, the resulting type
            // depends on whether we're evaluating a type annotation or
            // we're in some other context.
            if ((flags & 256 /* EvalFlags.TypeExpression */) !== 0) {
                addError(localize_1.LocMessage.optionalExtraArgs(), errorNode);
                return types_1.UnknownType.create();
            }
            return classType;
        }
        if (typeArgs.length > 1) {
            addError(localize_1.LocMessage.optionalExtraArgs(), errorNode);
            return types_1.UnknownType.create();
        }
        let typeArg0Type = typeArgs[0].type;
        if (!validateTypeArg(typeArgs[0])) {
            typeArg0Type = types_1.UnknownType.create();
        }
        let optionalType = (0, types_1.combineTypes)([typeArg0Type, noneTypeClass !== null && noneTypeClass !== void 0 ? noneTypeClass : types_1.UnknownType.create()]);
        if (unionTypeClass && (0, types_1.isInstantiableClass)(unionTypeClass)) {
            optionalType = types_1.TypeBase.cloneAsSpecialForm(optionalType, types_1.ClassType.cloneAsInstance(unionTypeClass));
        }
        return optionalType;
    }
    function cloneBuiltinObjectWithLiteral(node, builtInName, value) {
        const type = getBuiltInObject(node, builtInName);
        if ((0, types_1.isClassInstance)(type)) {
            return types_1.ClassType.cloneWithLiteral(types_1.ClassType.cloneRemoveTypePromotions(type), value);
        }
        return types_1.UnknownType.create();
    }
    function cloneBuiltinClassWithLiteral(node, literalClassType, builtInName, value) {
        const type = getBuiltInType(node, builtInName);
        if ((0, types_1.isInstantiableClass)(type)) {
            const literalType = types_1.ClassType.cloneWithLiteral(type, value);
            literalType.specialForm = literalClassType;
            return literalType;
        }
        return types_1.UnknownType.create();
    }
    // Creates a type that represents a Literal.
    function createLiteralType(classType, node, flags) {
        if (node.items.length === 0) {
            addError(localize_1.LocMessage.literalEmptyArgs(), node.baseExpression);
            return types_1.UnknownType.create();
        }
        // As per the specification, we support None, int, bool, str, bytes literals
        // plus enum values.
        const literalTypes = [];
        for (const item of node.items) {
            let type;
            const itemExpr = item.valueExpression;
            if (item.argumentCategory !== 0 /* ArgumentCategory.Simple */) {
                addError(localize_1.LocMessage.unpackedArgInTypeArgument(), itemExpr);
                type = types_1.UnknownType.create();
            }
            else if (item.name) {
                addError(localize_1.LocMessage.keywordArgInTypeArgument(), itemExpr);
                type = types_1.UnknownType.create();
            }
            else if (itemExpr.nodeType === 48 /* ParseNodeType.StringList */) {
                const isBytes = (itemExpr.strings[0].token.flags & 32 /* StringTokenFlags.Bytes */) !== 0;
                const value = itemExpr.strings.map((s) => s.value).join('');
                if (isBytes) {
                    type = cloneBuiltinClassWithLiteral(node, classType, 'bytes', value);
                }
                else {
                    type = cloneBuiltinClassWithLiteral(node, classType, 'str', value);
                }
                itemExpr.strings.forEach((stringNode) => {
                    if ((stringNode.token.flags & 512 /* StringTokenFlags.NamedUnicodeEscape */) !== 0) {
                        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportInvalidTypeForm, localize_1.LocMessage.literalNamedUnicodeEscape(), stringNode);
                    }
                });
            }
            else if (itemExpr.nodeType === 40 /* ParseNodeType.Number */) {
                if (!itemExpr.isImaginary && itemExpr.isInteger) {
                    type = cloneBuiltinClassWithLiteral(node, classType, 'int', itemExpr.value);
                }
            }
            else if (itemExpr.nodeType === 14 /* ParseNodeType.Constant */) {
                if (itemExpr.constType === 33 /* KeywordType.True */) {
                    type = cloneBuiltinClassWithLiteral(node, classType, 'bool', true);
                }
                else if (itemExpr.constType === 15 /* KeywordType.False */) {
                    type = cloneBuiltinClassWithLiteral(node, classType, 'bool', false);
                }
                else if (itemExpr.constType === 26 /* KeywordType.None */) {
                    type = noneTypeClass !== null && noneTypeClass !== void 0 ? noneTypeClass : types_1.UnknownType.create();
                }
            }
            else if (itemExpr.nodeType === 55 /* ParseNodeType.UnaryOperation */) {
                if (itemExpr.operator === 33 /* OperatorType.Subtract */ || itemExpr.operator === 0 /* OperatorType.Add */) {
                    if (itemExpr.expression.nodeType === 40 /* ParseNodeType.Number */) {
                        if (!itemExpr.expression.isImaginary && itemExpr.expression.isInteger) {
                            type = cloneBuiltinClassWithLiteral(node, classType, 'int', itemExpr.operator === 33 /* OperatorType.Subtract */
                                ? -itemExpr.expression.value
                                : itemExpr.expression.value);
                        }
                    }
                }
            }
            if (!type) {
                const exprType = getTypeOfExpression(itemExpr, (flags & 4 /* EvalFlags.ForwardRefs */) | 33554432 /* EvalFlags.NoConvertSpecialForm */ | 256 /* EvalFlags.TypeExpression */);
                // Is this an enum type?
                if ((0, types_1.isClassInstance)(exprType.type) &&
                    types_1.ClassType.isEnumClass(exprType.type) &&
                    exprType.type.literalValue !== undefined) {
                    type = types_1.ClassType.cloneAsInstantiable(exprType.type);
                }
                else {
                    // Is this a type alias to an existing literal type?
                    let isLiteralType = true;
                    (0, typeUtils_1.doForEachSubtype)(exprType.type, (subtype) => {
                        if (!(0, types_1.isInstantiableClass)(subtype) || subtype.literalValue === undefined) {
                            if (!(0, typeUtils_1.isNoneTypeClass)(subtype)) {
                                isLiteralType = false;
                            }
                        }
                    });
                    if (isLiteralType) {
                        type = exprType.type;
                    }
                }
            }
            if (!type) {
                addError(localize_1.LocMessage.literalUnsupportedType(), item);
                type = types_1.UnknownType.create();
            }
            literalTypes.push(type);
        }
        let result = (0, types_1.combineTypes)(literalTypes);
        if ((0, types_1.isUnion)(result) && unionTypeClass && (0, types_1.isInstantiableClass)(unionTypeClass)) {
            result = types_1.TypeBase.cloneAsSpecialForm(result, types_1.ClassType.cloneAsInstance(unionTypeClass));
        }
        return result;
    }
    // Creates a ClassVar type.
    function createClassVarType(classType, errorNode, typeArgs, flags) {
        var _a;
        if (flags & 131072 /* EvalFlags.NoClassVar */) {
            addError(localize_1.LocMessage.classVarNotAllowed(), errorNode);
            return types_1.AnyType.create();
        }
        if (!typeArgs) {
            return classType;
        }
        else if (typeArgs.length === 0) {
            addError(localize_1.LocMessage.classVarFirstArgMissing(), errorNode);
            return types_1.UnknownType.create();
        }
        else if (typeArgs.length > 1) {
            addError(localize_1.LocMessage.classVarTooManyArgs(), typeArgs[1].node);
            return types_1.UnknownType.create();
        }
        const type = typeArgs[0].type;
        // A ClassVar should not allow TypeVars or generic types parameterized
        // by TypeVars.
        if ((0, typeUtils_1.requiresSpecialization)(type, { ignorePseudoGeneric: true, ignoreSelf: true })) {
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.classVarWithTypeVar(), (_a = typeArgs[0].node) !== null && _a !== void 0 ? _a : errorNode);
        }
        return type;
    }
    // Creates a "TypeGuard" and "TypeIs" type. This is an alias for 'bool', which
    // isn't a generic type and therefore doesn't have a typeParameter.
    // We'll abuse our internal types a bit by specializing it with
    // a type argument anyway.
    function createTypeGuardType(classType, errorNode, typeArgs, flags) {
        // If no type arguments are provided, the resulting type
        // depends on whether we're evaluating a type annotation or
        // we're in some other context.
        if (!typeArgs) {
            if ((flags & 256 /* EvalFlags.TypeExpression */) !== 0) {
                addError(localize_1.LocMessage.typeGuardArgCount(), errorNode);
            }
            return classType;
        }
        else if (typeArgs.length !== 1) {
            addError(localize_1.LocMessage.typeGuardArgCount(), errorNode);
            return types_1.UnknownType.create();
        }
        const convertedTypeArgs = typeArgs.map((typeArg) => {
            return (0, typeUtils_1.convertToInstance)(validateTypeArg(typeArg) ? typeArg.type : types_1.UnknownType.create());
        });
        return types_1.ClassType.cloneForSpecialization(classType, convertedTypeArgs, /* isTypeArgumentExplicit */ true);
    }
    function createSelfType(classType, errorNode, typeArgs, flags) {
        var _a;
        // Self doesn't support any type arguments.
        if (typeArgs) {
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportInvalidTypeArguments, localize_1.LocMessage.typeArgsExpectingNone().format({
                name: classType.details.name,
            }), (_a = typeArgs[0].node) !== null && _a !== void 0 ? _a : errorNode);
        }
        let enclosingClass = ParseTreeUtils.getEnclosingClass(errorNode);
        // If `Self` appears anywhere outside of the class body (e.g. a decorator,
        // base class list, metaclass argument, type parameter list), it is
        // considered illegal.
        if (enclosingClass && !ParseTreeUtils.isNodeContainedWithin(errorNode, enclosingClass.suite)) {
            enclosingClass = undefined;
        }
        const enclosingClassTypeResult = enclosingClass ? getTypeOfClass(enclosingClass) : undefined;
        if (!enclosingClassTypeResult) {
            if ((flags & (256 /* EvalFlags.TypeExpression */ | 128 /* EvalFlags.InstantiableType */)) !== 0) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.selfTypeContext(), errorNode);
            }
            return types_1.UnknownType.create();
        }
        else if ((0, typeUtils_1.isInstantiableMetaclass)(enclosingClassTypeResult.classType)) {
            // If `Self` appears within a metaclass, it is considered illegal.
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.selfTypeMetaclass(), errorNode);
            return types_1.UnknownType.create();
        }
        const enclosingFunction = ParseTreeUtils.getEnclosingFunction(errorNode);
        if (enclosingFunction) {
            const functionInfo = (0, decorators_1.getFunctionInfoFromDecorators)(evaluatorInterface, enclosingFunction, 
            /* isInClass */ true);
            const isInnerFunction = !!ParseTreeUtils.getEnclosingFunction(enclosingFunction);
            if (!isInnerFunction) {
                // Check for static methods.
                if (functionInfo.flags & 4 /* FunctionTypeFlags.StaticMethod */) {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.selfTypeContext(), errorNode);
                    return types_1.UnknownType.create();
                }
                if (enclosingFunction.parameters.length > 0) {
                    const firstParamTypeAnnotation = ParseTreeUtils.getTypeAnnotationForParameter(enclosingFunction, 0);
                    if (firstParamTypeAnnotation &&
                        !ParseTreeUtils.isNodeContainedWithin(errorNode, firstParamTypeAnnotation)) {
                        const annotationType = getTypeOfAnnotation(firstParamTypeAnnotation, {
                            associateTypeVarsWithScope: true,
                        });
                        if (!(0, types_1.isTypeVar)(annotationType) || !annotationType.details.isSynthesizedSelf) {
                            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.selfTypeWithTypedSelfOrCls(), errorNode);
                        }
                    }
                }
            }
        }
        return (0, typeUtils_1.synthesizeTypeVarForSelfCls)(enclosingClassTypeResult.classType, /* isClsParam */ true);
    }
    function createRequiredOrReadOnlyType(classType, errorNode, typeArgs, flags) {
        // If no type arguments are provided, the resulting type
        // depends on whether we're evaluating a type annotation or
        // we're in some other context.
        if (!typeArgs && (flags & 256 /* EvalFlags.TypeExpression */) === 0) {
            return { type: classType };
        }
        if (!typeArgs || typeArgs.length !== 1) {
            addError(classType.details.name === 'ReadOnly'
                ? localize_1.LocMessage.readOnlyArgCount()
                : classType.details.name === 'Required'
                    ? localize_1.LocMessage.requiredArgCount()
                    : localize_1.LocMessage.notRequiredArgCount(), errorNode);
            return { type: classType };
        }
        const typeArgType = typeArgs[0].type;
        // Make sure this is used only in a dataclass.
        const containingClassNode = ParseTreeUtils.getEnclosingClass(errorNode, /* stopAtFunction */ true);
        const classTypeInfo = containingClassNode ? getTypeOfClass(containingClassNode) : undefined;
        let isUsageLegal = false;
        if (classTypeInfo &&
            (0, types_1.isInstantiableClass)(classTypeInfo.classType) &&
            types_1.ClassType.isTypedDictClass(classTypeInfo.classType)) {
            // The only legal usage is when used in a type annotation statement.
            if (ParseTreeUtils.isNodeContainedWithinNodeType(errorNode, 54 /* ParseNodeType.TypeAnnotation */)) {
                isUsageLegal = true;
            }
        }
        if ((flags & 1048576 /* EvalFlags.AllowRequired */) !== 0) {
            isUsageLegal = true;
        }
        let isReadOnly = typeArgs[0].isReadOnly;
        let isRequired = typeArgs[0].isRequired;
        let isNotRequired = typeArgs[0].isNotRequired;
        if (classType.details.name === 'ReadOnly') {
            // Nested ReadOnly are not allowed.
            if (typeArgs[0].isReadOnly) {
                isUsageLegal = false;
            }
            isReadOnly = true;
        }
        else {
            // Nested Required/NotRequired are not allowed.
            if (typeArgs[0].isRequired || typeArgs[0].isNotRequired) {
                isUsageLegal = false;
            }
            isRequired = classType.details.name === 'Required';
            isNotRequired = classType.details.name === 'NotRequired';
        }
        if (!isUsageLegal) {
            addError(classType.details.name === 'ReadOnly'
                ? localize_1.LocMessage.readOnlyNotInTypedDict()
                : classType.details.name === 'Required'
                    ? localize_1.LocMessage.requiredNotInTypedDict()
                    : localize_1.LocMessage.notRequiredNotInTypedDict(), errorNode);
            return { type: types_1.ClassType.cloneForSpecialization(classType, [(0, typeUtils_1.convertToInstance)(typeArgType)], !!typeArgs) };
        }
        return { type: typeArgType, isReadOnly, isRequired, isNotRequired };
    }
    function createUnpackType(classType, errorNode, typeArgs, flags) {
        // If no type arguments are provided, the resulting type
        // depends on whether we're evaluating a type annotation or
        // we're in some other context.
        if (!typeArgs && (flags & 256 /* EvalFlags.TypeExpression */) === 0) {
            return classType;
        }
        if (!typeArgs || typeArgs.length !== 1) {
            addError(localize_1.LocMessage.unpackArgCount(), errorNode);
            return types_1.UnknownType.create();
        }
        let typeArgType = typeArgs[0].type;
        if ((0, types_1.isUnion)(typeArgType) && typeArgType.subtypes.length === 1) {
            typeArgType = typeArgType.subtypes[0];
        }
        if ((flags & 2097152 /* EvalFlags.AllowUnpackedTuple */) !== 0) {
            if ((0, types_1.isInstantiableClass)(typeArgType) && !typeArgType.includeSubclasses && (0, typeUtils_1.isTupleClass)(typeArgType)) {
                return types_1.ClassType.cloneForUnpacked(typeArgType);
            }
            if ((0, types_1.isVariadicTypeVar)(typeArgType) && !typeArgType.isVariadicUnpacked) {
                return types_1.TypeVarType.cloneForUnpacked(typeArgType);
            }
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.unpackExpectedTypeVarTuple(), errorNode);
            return types_1.UnknownType.create();
        }
        if ((flags & 4194304 /* EvalFlags.AllowUnpackedTypedDict */) !== 0) {
            if ((0, types_1.isInstantiableClass)(typeArgType) && types_1.ClassType.isTypedDictClass(typeArgType)) {
                return types_1.ClassType.cloneForUnpacked(typeArgType);
            }
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.unpackExpectedTypedDict(), errorNode);
            return types_1.UnknownType.create();
        }
        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.unpackNotAllowed(), errorNode);
        return types_1.UnknownType.create();
    }
    // Creates a "Final" type.
    function createFinalType(classType, errorNode, typeArgs, flags) {
        if (flags & 16 /* EvalFlags.NoFinal */) {
            addError(localize_1.LocMessage.finalContext(), errorNode);
            return classType;
        }
        if (!typeArgs || typeArgs.length === 0) {
            return classType;
        }
        if (typeArgs.length > 1) {
            addError(localize_1.LocMessage.finalTooManyArgs(), errorNode);
        }
        return types_1.TypeBase.cloneAsSpecialForm(typeArgs[0].type, classType);
    }
    function createConcatenateType(classType, errorNode, typeArgs, flags) {
        if ((flags & 134217728 /* EvalFlags.AllowConcatenate */) === 0) {
            addError(localize_1.LocMessage.concatenateContext(), errorNode);
            return types_1.AnyType.create();
        }
        if (!typeArgs || typeArgs.length === 0) {
            addError(localize_1.LocMessage.concatenateTypeArgsMissing(), errorNode);
        }
        else {
            typeArgs.forEach((typeArg, index) => {
                if (index === typeArgs.length - 1) {
                    if (!(0, types_1.isParamSpec)(typeArg.type) && !(0, typeUtils_1.isEllipsisType)(typeArg.type)) {
                        addError(localize_1.LocMessage.concatenateParamSpecMissing(), typeArg.node);
                    }
                }
                else {
                    if ((0, types_1.isParamSpec)(typeArg.type)) {
                        addError(localize_1.LocMessage.paramSpecContext(), typeArg.node);
                    }
                    else if ((0, types_1.isUnpackedVariadicTypeVar)(typeArg.type)) {
                        addError(localize_1.LocMessage.typeVarTupleContext(), typeArg.node);
                    }
                    else if ((0, types_1.isUnpackedClass)(typeArg.type)) {
                        addError(localize_1.LocMessage.unpackedArgInTypeArgument(), typeArg.node);
                    }
                }
            });
        }
        return createSpecialType(classType, typeArgs, /* paramLimit */ undefined, /* allowParamSpec */ true);
    }
    function createAnnotatedType(classType, errorNode, typeArgs, flags) {
        const typeExprFlags = 256 /* EvalFlags.TypeExpression */ | 33554432 /* EvalFlags.NoConvertSpecialForm */;
        if ((flags & typeExprFlags) === 0) {
            return { type: classType };
        }
        if (typeArgs) {
            if (typeArgs.length < 2) {
                addError(localize_1.LocMessage.annotatedTypeArgMissing(), errorNode);
            }
            else {
                validateAnnotatedMetadata(errorNode, typeArgs[0].type, typeArgs.slice(1));
            }
        }
        if (!typeArgs || typeArgs.length === 0) {
            return { type: types_1.AnyType.create() };
        }
        if (typeArgs[0].typeList) {
            addError(localize_1.LocMessage.typeArgListNotAllowed(), typeArgs[0].node);
        }
        return {
            type: types_1.TypeBase.cloneAsSpecialForm(typeArgs[0].type, classType),
            isReadOnly: typeArgs[0].isReadOnly,
            isRequired: typeArgs[0].isRequired,
            isNotRequired: typeArgs[0].isNotRequired,
        };
    }
    // Enforces metadata consistency as specified in PEP 746.
    function validateAnnotatedMetadata(errorNode, annotatedType, metaArgs) {
        var _a;
        // This is an experimental feature because PEP 746 hasn't been accepted.
        if (!AnalyzerNodeInfo.getFileInfo(errorNode).diagnosticRuleSet.enableExperimentalFeatures) {
            return;
        }
        for (const metaArg of metaArgs) {
            if ((0, types_1.isClass)(metaArg.type)) {
                const supportsTypeMethod = (_a = getTypeOfBoundMember(
                /* errorNode */ undefined, metaArg.type, '__supports_type__')) === null || _a === void 0 ? void 0 : _a.type;
                if (!supportsTypeMethod) {
                    continue;
                }
                // "Call" the __supports_type__ method to determine if the type is supported.
                const callResult = useSpeculativeMode(errorNode, () => validateCallArguments(errorNode, [
                    {
                        argumentCategory: 0 /* ArgumentCategory.Simple */,
                        typeResult: { type: (0, typeUtils_1.convertToInstance)(annotatedType) },
                    },
                ], { type: supportsTypeMethod }, 
                /* typeVarContext */ undefined, 
                /* skipUnknownArgCheck */ true, 
                /* inferenceContext */ undefined, 
                /* signatureTracker */ undefined));
                if (callResult.isTypeIncomplete || !callResult.returnType) {
                    continue;
                }
                // If there are no errors and the return type is potentially truthy,
                // we know that the type is supported by this metadata object.
                if (!callResult.argumentErrors && canBeTruthy(callResult.returnType)) {
                    continue;
                }
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportInvalidTypeArguments, localize_1.LocMessage.annotatedMetadataInconsistent().format({
                    metadataType: printType(metaArg.type),
                    type: printType((0, typeUtils_1.convertToInstance)(annotatedType)),
                }), metaArg.node);
            }
        }
    }
    // Creates one of several "special" types that are defined in typing.pyi
    // but not declared in their entirety. This includes the likes of "Tuple",
    // "Dict", etc.
    function createSpecialType(classType, typeArgs, paramLimit, allowParamSpec = false, isSpecialForm = true) {
        const isTupleTypeParam = types_1.ClassType.isTupleClass(classType);
        if (typeArgs) {
            if (isTupleTypeParam && typeArgs.length === 1 && typeArgs[0].isEmptyTupleShorthand) {
                typeArgs = [];
            }
            else {
                let sawUnpacked = false;
                const noteSawUnpacked = (typeArg) => {
                    if (sawUnpacked) {
                        if (!reportedUnpackedError) {
                            addError(localize_1.LocMessage.variadicTypeArgsTooMany(), typeArg.node);
                            reportedUnpackedError = true;
                        }
                    }
                    sawUnpacked = true;
                };
                let reportedUnpackedError = false;
                // Verify that we didn't receive any inappropriate types.
                typeArgs.forEach((typeArg, index) => {
                    var _a;
                    (0, debug_1.assert)(typeArgs !== undefined);
                    if ((0, typeUtils_1.isEllipsisType)(typeArg.type)) {
                        if (!isTupleTypeParam) {
                            if (!allowParamSpec) {
                                addError(localize_1.LocMessage.ellipsisContext(), typeArg.node);
                            }
                        }
                        else if (typeArgs.length !== 2 || index !== 1) {
                            addError(localize_1.LocMessage.ellipsisSecondArg(), typeArg.node);
                        }
                        else {
                            if ((0, types_1.isVariadicTypeVar)(typeArgs[0].type) && !typeArgs[0].type.isVariadicInUnion) {
                                addError(localize_1.LocMessage.typeVarTupleContext(), typeArgs[0].node);
                            }
                            else if ((0, types_1.isUnpackedClass)(typeArgs[0].type)) {
                                addError(localize_1.LocMessage.ellipsisAfterUnpacked(), typeArg.node);
                            }
                        }
                    }
                    else if ((0, types_1.isParamSpec)(typeArg.type) && allowParamSpec) {
                        // Nothing to do - this is allowed.
                    }
                    else if (paramLimit === undefined && (0, types_1.isVariadicTypeVar)(typeArg.type)) {
                        if (!typeArg.type.isVariadicInUnion) {
                            noteSawUnpacked(typeArg);
                        }
                        validateVariadicTypeVarIsUnpacked(typeArg.type, typeArg.node);
                    }
                    else if (paramLimit === undefined && (0, types_1.isUnpackedClass)(typeArg.type)) {
                        if ((_a = typeArg.type.tupleTypeArguments) === null || _a === void 0 ? void 0 : _a.some((typeArg) => (0, types_1.isVariadicTypeVar)(typeArg.type) || typeArg.isUnbounded)) {
                            noteSawUnpacked(typeArg);
                        }
                        validateTypeArg(typeArg, { allowUnpackedTuples: true });
                    }
                    else {
                        validateTypeArg(typeArg);
                    }
                });
            }
        }
        let typeArgTypes = typeArgs ? typeArgs.map((t) => (0, typeUtils_1.convertToInstance)(t.type)) : [];
        // Make sure the argument list count is correct.
        if (paramLimit !== undefined) {
            if (typeArgs && typeArgTypes.length > paramLimit) {
                addError(localize_1.LocMessage.typeArgsTooMany().format({
                    name: classType.aliasName || classType.details.name,
                    expected: paramLimit,
                    received: typeArgTypes.length,
                }), typeArgs[paramLimit].node);
                typeArgTypes = typeArgTypes.slice(0, paramLimit);
            }
            else if (typeArgTypes.length < paramLimit) {
                // Fill up the remainder of the slots with unknown types.
                while (typeArgTypes.length < paramLimit) {
                    typeArgTypes.push(types_1.UnknownType.create());
                }
            }
        }
        // Handle tuple type params as a special case.
        let returnType;
        if (isTupleTypeParam) {
            const tupleTypeArgTypes = [];
            // If no type args are provided and it's a tuple, default to [Unknown, ...].
            if (!typeArgs) {
                tupleTypeArgTypes.push({ type: types_1.UnknownType.create(), isUnbounded: true });
            }
            else {
                typeArgs.forEach((typeArg, index) => {
                    if (index === 1 && (0, typeUtils_1.isEllipsisType)(typeArgTypes[index])) {
                        if (tupleTypeArgTypes.length === 1 && !tupleTypeArgTypes[0].isUnbounded) {
                            tupleTypeArgTypes[0] = { type: tupleTypeArgTypes[0].type, isUnbounded: true };
                        }
                    }
                    else if ((0, types_1.isUnpackedClass)(typeArg.type) && typeArg.type.tupleTypeArguments) {
                        (0, collectionUtils_1.appendArray)(tupleTypeArgTypes, typeArg.type.tupleTypeArguments);
                    }
                    else {
                        tupleTypeArgTypes.push({ type: typeArgTypes[index], isUnbounded: false });
                    }
                });
            }
            returnType = (0, typeUtils_1.specializeTupleClass)(classType, tupleTypeArgTypes, typeArgs !== undefined);
        }
        else {
            returnType = types_1.ClassType.cloneForSpecialization(classType, typeArgTypes, typeArgs !== undefined);
        }
        if (isSpecialForm) {
            returnType = types_1.TypeBase.cloneAsSpecialForm(returnType, classType);
        }
        return returnType;
    }
    // Unpacks the index expression for a "Union[X, Y, Z]" type annotation.
    function createUnionType(classType, errorNode, typeArgs, flags) {
        const fileInfo = AnalyzerNodeInfo.getFileInfo(errorNode);
        const types = [];
        let allowSingleTypeArg = false;
        if (!typeArgs) {
            // If no type arguments are provided, the resulting type
            // depends on whether we're evaluating a type annotation or
            // we're in some other context.
            if ((flags & 256 /* EvalFlags.TypeExpression */) !== 0) {
                addError(localize_1.LocMessage.unionTypeArgCount(), errorNode);
                return types_1.NeverType.createNever();
            }
            return classType;
        }
        for (const typeArg of typeArgs) {
            let typeArgType = typeArg.type;
            // This is an experimental feature because Unions of unpacked TypeVarTuples are not officially supported.
            if (!validateTypeArg(typeArg, {
                allowVariadicTypeVar: fileInfo.diagnosticRuleSet.enableExperimentalFeatures,
            })) {
                typeArgType = types_1.UnknownType.create();
            }
            // If this is an unpacked tuple, explode out the individual items.
            if ((0, types_1.isUnpackedClass)(typeArg.type) && typeArg.type.tupleTypeArguments) {
                // This is an experimental feature because Unions of unpacked TypeVarTuples are not officially supported.
                if (fileInfo.diagnosticRuleSet.enableExperimentalFeatures) {
                    typeArg.type.tupleTypeArguments.forEach((tupleTypeArg) => {
                        types.push((0, typeUtils_1.convertToInstantiable)(tupleTypeArg.type));
                    });
                    allowSingleTypeArg = true;
                }
                else {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.unionUnpackedTuple(), errorNode);
                    types.push(types_1.UnknownType.create());
                }
            }
            else {
                if ((0, types_1.isTypeVar)(typeArgType) && (0, types_1.isUnpackedVariadicTypeVar)(typeArgType)) {
                    // This is an experimental feature because Unions of unpacked TypeVarTuples are not officially supported.
                    if (fileInfo.diagnosticRuleSet.enableExperimentalFeatures) {
                        // If this is an unpacked TypeVar, note that it is in a union so we can
                        // differentiate between Unpack[Vs] and Union[Unpack[Vs]].
                        typeArgType = types_1.TypeVarType.cloneForUnpacked(typeArgType, /* isInUnion */ true);
                        allowSingleTypeArg = true;
                    }
                    else {
                        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.unionUnpackedTypeVarTuple(), errorNode);
                        typeArgType = types_1.UnknownType.create();
                    }
                }
                types.push(typeArgType);
            }
        }
        // Validate that we received at least two type arguments. One type argument
        // is allowed if it's an unpacked variadic type var or tuple. None is also allowed
        // since it is used to define NoReturn in typeshed stubs).
        if (types.length === 1 && !allowSingleTypeArg && !(0, typeUtils_1.isNoneInstance)(types[0])) {
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportInvalidTypeArguments, localize_1.LocMessage.unionTypeArgCount(), errorNode);
        }
        let unionType = (0, types_1.combineTypes)(types);
        if (unionTypeClass && (0, types_1.isInstantiableClass)(unionTypeClass)) {
            unionType = types_1.TypeBase.cloneAsSpecialForm(unionType, types_1.ClassType.cloneAsInstance(unionTypeClass));
        }
        return unionType;
    }
    // Creates a type that represents "Generic[T1, T2, ...]", used in the
    // definition of a generic class.
    function createGenericType(classType, errorNode, typeArgs, flags) {
        if (!typeArgs) {
            // If no type arguments are provided, the resulting type
            // depends on whether we're evaluating a type annotation or
            // we're in some other context.
            if ((flags & (256 /* EvalFlags.TypeExpression */ | 262144 /* EvalFlags.NoNakedGeneric */)) !== 0) {
                addError(localize_1.LocMessage.genericTypeArgMissing(), errorNode);
            }
            return classType;
        }
        const uniqueTypeVars = [];
        if (typeArgs) {
            // Make sure there's at least one type arg.
            if (typeArgs.length === 0) {
                addError(localize_1.LocMessage.genericTypeArgMissing(), errorNode);
            }
            // Make sure that all of the type args are typeVars and are unique.
            typeArgs.forEach((typeArg) => {
                if (!(0, types_1.isTypeVar)(typeArg.type)) {
                    addError(localize_1.LocMessage.genericTypeArgTypeVar(), typeArg.node);
                }
                else {
                    if (uniqueTypeVars.some((t) => (0, types_1.isTypeSame)(t, typeArg.type))) {
                        addError(localize_1.LocMessage.genericTypeArgUnique(), typeArg.node);
                    }
                    uniqueTypeVars.push(typeArg.type);
                }
            });
        }
        return createSpecialType(classType, typeArgs, /* paramLimit */ undefined, /* allowParamSpec */ true);
    }
    function transformTypeForTypeAlias(type, name, errorNode, isPep695Syntax, isPep695TypeVarType, typeParameters, typeParamNodes) {
        if (!types_1.TypeBase.isInstantiable(type)) {
            return type;
        }
        // If this is a recursive type alias that hasn't yet been fully resolved
        // (i.e. there is no boundType associated with it), don't apply the transform.
        if ((0, typeUtils_1.isTypeAliasPlaceholder)(type)) {
            return type;
        }
        if (!typeParameters) {
            // Determine if there are any generic type parameters associated
            // with this type alias.
            typeParameters = [];
            (0, typeUtils_1.addTypeVarsToListIfUnique)(typeParameters, (0, typeUtils_1.getTypeVarArgumentsRecursive)(type));
            // Don't include any synthesized type variables.
            typeParameters = typeParameters.filter((typeVar) => !typeVar.details.isSynthesized);
        }
        // Convert all type variables to instances.
        typeParameters = typeParameters.map((typeVar) => {
            if (types_1.TypeBase.isInstance(typeVar)) {
                return typeVar;
            }
            return (0, typeUtils_1.convertToInstance)(typeVar);
        });
        // See if the type alias includes a TypeVarTuple followed by a TypeVar
        // with a default value. This isn't allowed.
        const firstTypeVarTupleIndex = typeParameters.findIndex((typeVar) => (0, types_1.isVariadicTypeVar)(typeVar));
        if (firstTypeVarTupleIndex >= 0) {
            const typeVarWithDefaultIndex = typeParameters.findIndex((typeVar, index) => index > firstTypeVarTupleIndex && !typeVar.details.isParamSpec && typeVar.details.isDefaultExplicit);
            if (typeVarWithDefaultIndex >= 0) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeVarWithDefaultFollowsVariadic().format({
                    typeVarName: typeParameters[typeVarWithDefaultIndex].details.name,
                    variadicName: typeParameters[firstTypeVarTupleIndex].details.name,
                }), typeParamNodes ? typeParamNodes[typeVarWithDefaultIndex].name : name);
            }
        }
        const typeAliasScopeId = ParseTreeUtils.getScopeIdForNode(name);
        // Validate the default types for all type parameters.
        typeParameters.forEach((typeParam, index) => {
            var _a;
            (0, debug_1.assert)(typeParameters !== undefined);
            let bestErrorNode = errorNode;
            if (typeParamNodes && index < typeParamNodes.length) {
                bestErrorNode = (_a = typeParamNodes[index].defaultExpression) !== null && _a !== void 0 ? _a : typeParamNodes[index].name;
            }
            validateTypeParameterDefault(bestErrorNode, typeParam, typeParameters.slice(0, index), typeAliasScopeId);
        });
        // Verify that we have at most one variadic type variable.
        const variadics = typeParameters.filter((param) => (0, types_1.isVariadicTypeVar)(param));
        if (variadics.length > 1) {
            addError(localize_1.LocMessage.variadicTypeParamTooManyAlias().format({
                names: variadics.map((v) => `"${v.details.name}"`).join(', '),
            }), errorNode);
        }
        if (!isPep695Syntax && !isPep695TypeVarType) {
            const boundTypeVars = typeParameters.filter((typeVar) => typeVar.scopeId !== typeAliasScopeId && typeVar.scopeType === 0 /* TypeVarScopeType.Class */);
            if (boundTypeVars.length > 0) {
                addError(localize_1.LocMessage.genericTypeAliasBoundTypeVar().format({
                    names: boundTypeVars.map((t) => `${t.details.name}`).join(', '),
                }), errorNode);
            }
        }
        const fileInfo = AnalyzerNodeInfo.getFileInfo(name);
        let typeAlias = types_1.TypeBase.cloneForTypeAlias(type, name.value, ParseTreeUtils.getClassFullName(name, fileInfo.moduleName, name.value), fileInfo.moduleName, fileInfo.fileUri, typeAliasScopeId, isPep695Syntax, typeParameters.length > 0 ? typeParameters : undefined);
        // All PEP 695 type aliases are special forms because they are
        // TypeAliasType objects at runtime.
        if (isPep695Syntax || isPep695TypeVarType) {
            const typeAliasTypeClass = getTypingType(errorNode, 'TypeAliasType');
            if (typeAliasTypeClass && (0, types_1.isInstantiableClass)(typeAliasTypeClass)) {
                typeAlias = types_1.TypeBase.cloneAsSpecialForm(typeAlias, types_1.ClassType.cloneAsInstance(typeAliasTypeClass));
            }
        }
        return typeAlias;
    }
    function createSpecialBuiltInClass(node, assignedName, aliasMapEntry) {
        var _a;
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        let specialClassType = types_1.ClassType.createInstantiable(assignedName, ParseTreeUtils.getClassFullName(node, fileInfo.moduleName, assignedName), fileInfo.moduleName, fileInfo.fileUri, 1 /* ClassTypeFlags.BuiltInClass */ | 2 /* ClassTypeFlags.SpecialBuiltIn */, 
        /* typeSourceId */ 0, 
        /* declaredMetaclass */ undefined, 
        /* effectiveMetaclass */ undefined);
        if (aliasMapEntry.isSpecialForm) {
            specialClassType.details.flags |= 8388608 /* ClassTypeFlags.SpecialFormClass */;
        }
        if (aliasMapEntry.isIllegalInIsinstance) {
            specialClassType.details.flags |= 16777216 /* ClassTypeFlags.IllegalIsinstanceClass */;
        }
        // Synthesize a single type parameter with the specified variance if
        // specified in the alias map entry.
        if (aliasMapEntry.typeParamVariance !== undefined) {
            let typeParam = types_1.TypeVarType.createInstance('T');
            typeParam = types_1.TypeVarType.cloneForScopeId(typeParam, ParseTreeUtils.getScopeIdForNode(node), assignedName, 0 /* TypeVarScopeType.Class */);
            typeParam.details.declaredVariance = aliasMapEntry.typeParamVariance;
            specialClassType.details.typeParameters.push(typeParam);
        }
        const specialBuiltInClassDeclaration = ((_a = AnalyzerNodeInfo.getDeclaration(node)) !== null && _a !== void 0 ? _a : (node.parent ? AnalyzerNodeInfo.getDeclaration(node.parent) : undefined));
        specialClassType.details.declaration = specialBuiltInClassDeclaration;
        if (fileInfo.isTypingExtensionsStubFile) {
            specialClassType.details.flags |= 4096 /* ClassTypeFlags.TypingExtensionClass */;
        }
        const baseClassName = aliasMapEntry.alias || 'object';
        let baseClass;
        if (aliasMapEntry.module === 'builtins') {
            baseClass = getBuiltInType(node, baseClassName);
        }
        else if (aliasMapEntry.module === 'collections') {
            // The typing.pyi file imports collections.
            baseClass = getTypeOfModule(node, baseClassName, ['collections']);
        }
        else if (aliasMapEntry.module === 'self') {
            const symbolWithScope = lookUpSymbolRecursive(node, baseClassName, /* honorCodeFlow */ false);
            if (symbolWithScope) {
                baseClass = getEffectiveTypeOfSymbol(symbolWithScope.symbol);
                // The _TypedDict class is marked as abstract, but the
                // methods that are abstract are overridden and shouldn't
                // cause the TypedDict to be marked as abstract.
                if ((0, types_1.isInstantiableClass)(baseClass) && types_1.ClassType.isBuiltIn(baseClass, '_TypedDict')) {
                    baseClass = types_1.ClassType.cloneWithNewFlags(baseClass, baseClass.details.flags &
                        ~(64 /* ClassTypeFlags.SupportsAbstractMethods */ | 1048576 /* ClassTypeFlags.TypeCheckOnly */));
                }
            }
        }
        if (baseClass && (0, types_1.isInstantiableClass)(baseClass)) {
            if (aliasMapEntry.alias) {
                specialClassType = types_1.ClassType.cloneForTypingAlias(baseClass, assignedName);
            }
            else {
                specialClassType.details.baseClasses.push(baseClass);
                specialClassType.details.effectiveMetaclass = baseClass.details.effectiveMetaclass;
                (0, typeUtils_1.computeMroLinearization)(specialClassType);
            }
        }
        else {
            specialClassType.details.baseClasses.push(types_1.UnknownType.create());
            specialClassType.details.effectiveMetaclass = types_1.UnknownType.create();
            (0, typeUtils_1.computeMroLinearization)(specialClassType);
        }
        return specialClassType;
    }
    // Handles some special-case type annotations that are found
    // within the typings.pyi file.
    function handleTypingStubTypeAnnotation(node) {
        if (!node.parent || node.parent.nodeType !== 54 /* ParseNodeType.TypeAnnotation */) {
            return undefined;
        }
        if (node.parent.valueExpression.nodeType !== 38 /* ParseNodeType.Name */) {
            return undefined;
        }
        const nameNode = node.parent.valueExpression;
        const assignedName = nameNode.value;
        const specialTypes = new Map([
            ['Tuple', { alias: 'tuple', module: 'builtins' }],
            ['Generic', { alias: '', module: 'builtins', isSpecialForm: true }],
            ['Protocol', { alias: '', module: 'builtins', isSpecialForm: true }],
            ['Callable', { alias: '', module: 'builtins', isSpecialForm: true }],
            ['Type', { alias: 'type', module: 'builtins' }],
            ['ClassVar', { alias: '', module: 'builtins', isSpecialForm: true }],
            ['Final', { alias: '', module: 'builtins', isSpecialForm: true }],
            ['Literal', { alias: '', module: 'builtins', isSpecialForm: true }],
            ['TypedDict', { alias: '_TypedDict', module: 'self' }],
            ['Union', { alias: '', module: 'builtins', isSpecialForm: true }],
            ['Optional', { alias: '', module: 'builtins', isSpecialForm: true }],
            ['Annotated', { alias: '', module: 'builtins', isSpecialForm: true, isIllegalInIsinstance: true }],
            ['TypeAlias', { alias: '', module: 'builtins', isSpecialForm: true }],
            ['Concatenate', { alias: '', module: 'builtins', isSpecialForm: true }],
            [
                'TypeGuard',
                { alias: '', module: 'builtins', isSpecialForm: true, typeParamVariance: 3 /* Variance.Covariant */ },
            ],
            ['Unpack', { alias: '', module: 'builtins', isSpecialForm: true }],
            ['Required', { alias: '', module: 'builtins', isSpecialForm: true }],
            ['NotRequired', { alias: '', module: 'builtins', isSpecialForm: true }],
            ['Self', { alias: '', module: 'builtins', isSpecialForm: true }],
            ['NoReturn', { alias: '', module: 'builtins', isSpecialForm: true }],
            ['Never', { alias: '', module: 'builtins', isSpecialForm: true }],
            ['LiteralString', { alias: '', module: 'builtins', isSpecialForm: true }],
            ['ReadOnly', { alias: '', module: 'builtins', isSpecialForm: true }],
            ['TypeIs', { alias: '', module: 'builtins', isSpecialForm: true, typeParamVariance: 2 /* Variance.Invariant */ }],
        ]);
        const aliasMapEntry = specialTypes.get(assignedName);
        if (aliasMapEntry) {
            const cachedType = readTypeCache(node, 0 /* EvalFlags.None */);
            if (cachedType) {
                (0, debug_1.assert)((0, types_1.isInstantiableClass)(cachedType));
                return cachedType;
            }
            const specialType = createSpecialBuiltInClass(node, assignedName, aliasMapEntry);
            // Handle 'LiteralString' specially because we want it to act as
            // though it derives from 'str'.
            if (assignedName === 'LiteralString') {
                specialType.details.baseClasses.push(strClass !== null && strClass !== void 0 ? strClass : types_1.AnyType.create());
                (0, typeUtils_1.computeMroLinearization)(specialType);
            }
            writeTypeCache(node, { type: specialType }, 0 /* EvalFlags.None */);
            return specialType;
        }
        return undefined;
    }
    // Handles some special-case assignment statements that are found
    // within the typings.pyi file.
    function handleTypingStubAssignment(node) {
        if (node.leftExpression.nodeType !== 38 /* ParseNodeType.Name */) {
            return undefined;
        }
        const nameNode = node.leftExpression;
        const assignedName = nameNode.value;
        if (assignedName === 'Any') {
            return types_1.AnyType.createSpecialForm();
        }
        const specialTypes = new Map([
            ['overload', { alias: '', module: 'builtins' }],
            ['TypeVar', { alias: '', module: 'builtins' }],
            ['_promote', { alias: '', module: 'builtins' }],
            ['no_type_check', { alias: '', module: 'builtins' }],
            ['NoReturn', { alias: '', module: 'builtins' }],
            ['Never', { alias: '', module: 'builtins' }],
            ['Counter', { alias: 'Counter', module: 'collections' }],
            ['List', { alias: 'list', module: 'builtins' }],
            ['Dict', { alias: 'dict', module: 'builtins' }],
            ['DefaultDict', { alias: 'defaultdict', module: 'collections' }],
            ['Set', { alias: 'set', module: 'builtins' }],
            ['FrozenSet', { alias: 'frozenset', module: 'builtins' }],
            ['Deque', { alias: 'deque', module: 'collections' }],
            ['ChainMap', { alias: 'ChainMap', module: 'collections' }],
            ['OrderedDict', { alias: 'OrderedDict', module: 'collections' }],
        ]);
        const aliasMapEntry = specialTypes.get(assignedName);
        if (aliasMapEntry) {
            // Evaluate the expression so symbols are marked as accessed.
            getTypeOfExpression(node.rightExpression);
            return createSpecialBuiltInClass(node, assignedName, aliasMapEntry);
        }
        return undefined;
    }
    function evaluateTypesForAssignmentStatement(node) {
        var _a;
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        // If the entire statement has already been evaluated, don't
        // re-evaluate it.
        if (isTypeCached(node)) {
            return;
        }
        let flags = 0 /* EvalFlags.None */;
        if (fileInfo.isStubFile) {
            // An assignment of ellipsis means "Any" within a type stub file.
            flags |= 1 /* EvalFlags.ConvertEllipsisToAny */;
        }
        if (node.rightExpression.nodeType === 38 /* ParseNodeType.Name */ ||
            node.rightExpression.nodeType === 35 /* ParseNodeType.MemberAccess */) {
            // Don't specialize a generic class on assignment (e.g. "x = list"
            // or "x = collections.OrderedDict") because we may want to later
            // specialize it (e.g. "x[int]").
            flags |= 2 /* EvalFlags.NoSpecialize */;
        }
        // Is this type already cached?
        let rightHandType = readTypeCache(node.rightExpression, /* flags */ undefined);
        let isIncomplete = false;
        let expectedTypeDiagAddendum;
        if (!rightHandType) {
            // Special-case the typing.pyi file, which contains some special
            // types that the type analyzer needs to interpret differently.
            if (fileInfo.isTypingStubFile || fileInfo.isTypingExtensionsStubFile) {
                rightHandType = handleTypingStubAssignment(node);
                if (rightHandType) {
                    writeTypeCache(node.rightExpression, { type: rightHandType }, 0 /* EvalFlags.None */);
                }
            }
        }
        if (!rightHandType) {
            // Determine whether there is a declared type.
            const declaredType = getDeclaredTypeForExpression(node.leftExpression, { method: 'set' });
            let typeAliasNameNode;
            let typeAliasPlaceholder;
            let isSpeculativeTypeAlias = false;
            if (isDeclaredTypeAlias(node.leftExpression)) {
                flags =
                    128 /* EvalFlags.InstantiableType */ |
                        256 /* EvalFlags.TypeExpression */ |
                        8 /* EvalFlags.StrLiteralAsType */ |
                        32 /* EvalFlags.NoParamSpec */ |
                        64 /* EvalFlags.NoTypeVarTuple */ |
                        131072 /* EvalFlags.NoClassVar */;
                typeAliasNameNode = node.leftExpression.valueExpression;
                if (!isLegalTypeAliasExpressionForm(node.rightExpression)) {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportInvalidTypeForm, localize_1.LocMessage.typeAliasIllegalExpressionForm(), node.rightExpression);
                }
            }
            else if (node.leftExpression.nodeType === 38 /* ParseNodeType.Name */) {
                const symbolWithScope = lookUpSymbolRecursive(node.leftExpression, node.leftExpression.value, 
                /* honorCodeFlow */ false);
                if (symbolWithScope) {
                    const decls = symbolWithScope.symbol.getDeclarations();
                    if (decls.length === 1) {
                        if (isPossibleTypeAliasDeclaration(decls[0])) {
                            typeAliasNameNode = node.leftExpression;
                            isSpeculativeTypeAlias = true;
                            flags |= 33554432 /* EvalFlags.NoConvertSpecialForm */;
                        }
                        else if (isPossibleTypeDictFactoryCall(decls[0])) {
                            // Handle calls to TypedDict factory functions like type
                            // aliases to support recursive field type definitions.
                            typeAliasNameNode = node.leftExpression;
                        }
                    }
                }
            }
            if (typeAliasNameNode) {
                typeAliasPlaceholder = synthesizeTypeAliasPlaceholder(typeAliasNameNode);
                writeTypeCache(node, { type: typeAliasPlaceholder }, /* flags */ undefined);
                writeTypeCache(node.leftExpression, { type: typeAliasPlaceholder }, /* flags */ undefined);
                if (node.leftExpression.nodeType === 54 /* ParseNodeType.TypeAnnotation */) {
                    writeTypeCache(node.leftExpression.valueExpression, { type: typeAliasPlaceholder }, 
                    /* flags */ undefined);
                }
            }
            const srcTypeResult = getTypeOfExpression(node.rightExpression, flags, (0, typeUtils_1.makeInferenceContext)(declaredType));
            rightHandType = srcTypeResult.type;
            expectedTypeDiagAddendum = srcTypeResult.expectedTypeDiagAddendum;
            if (srcTypeResult.isIncomplete) {
                isIncomplete = true;
            }
            // If this was a speculative type alias, it becomes a real type alias
            // only if the evaluated type is an instantiable type.
            if (isSpeculativeTypeAlias && !isLegalImplicitTypeAliasType(rightHandType)) {
                typeAliasNameNode = undefined;
            }
            if (typeAliasNameNode) {
                (0, debug_1.assert)(typeAliasPlaceholder !== undefined);
                // If this is a type alias, record its name based on the assignment target.
                rightHandType = transformTypeForTypeAlias(rightHandType, typeAliasNameNode, typeAliasNameNode, 
                /* isPep695Syntax */ false, 
                /* isPep695TypeVarType */ false);
                if ((0, typeUtils_1.isTypeAliasRecursive)(typeAliasPlaceholder, rightHandType)) {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeAliasIsRecursiveDirect().format({
                        name: typeAliasNameNode.value,
                    }), node.rightExpression);
                    rightHandType = types_1.UnknownType.create();
                }
                // Set the resulting type to the boundType of the original type alias
                // to support recursive type aliases.
                typeAliasPlaceholder.details.boundType = rightHandType;
                // Record the type parameters within the recursive type alias so it
                // can be specialized.
                typeAliasPlaceholder.details.recursiveTypeParameters = (_a = rightHandType.typeAliasInfo) === null || _a === void 0 ? void 0 : _a.typeParameters;
            }
            else {
                // If the RHS is a constant boolean expression, assign it a literal type.
                const constExprValue = (0, staticExpressions_1.evaluateStaticBoolExpression)(node.rightExpression, fileInfo.executionEnvironment, fileInfo.definedConstants);
                if (constExprValue !== undefined) {
                    const boolType = getBuiltInObject(node, 'bool');
                    if ((0, types_1.isClassInstance)(boolType)) {
                        rightHandType = types_1.ClassType.cloneWithLiteral(boolType, constExprValue);
                    }
                }
            }
        }
        assignTypeToExpression(node.leftExpression, { type: rightHandType, isIncomplete }, node.rightExpression, 
        /* ignoreEmptyContainers */ true, 
        /* allowAssignmentToFinalVar */ true, expectedTypeDiagAddendum);
        writeTypeCache(node, { type: rightHandType, isIncomplete }, 0 /* EvalFlags.None */);
    }
    // Synthesize a TypeVar that acts as a placeholder for a type alias. This allows
    // the type alias definition to refer to itself.
    function synthesizeTypeAliasPlaceholder(nameNode) {
        const placeholder = types_1.TypeVarType.createInstantiable(`__type_alias_${nameNode.value}`);
        placeholder.details.isSynthesized = true;
        placeholder.details.recursiveTypeAliasName = nameNode.value;
        const scopeId = ParseTreeUtils.getScopeIdForNode(nameNode);
        placeholder.details.recursiveTypeAliasScopeId = scopeId;
        placeholder.details.recursiveTypeAliasIsPep695Syntax = false;
        placeholder.scopeId = scopeId;
        return placeholder;
    }
    // Evaluates the type of a type alias (i.e. "type") statement. This code
    // path does not handle traditional type aliases, which are treated as
    // variables since they use normal variable assignment syntax.
    function getTypeOfTypeAlias(node) {
        var _a;
        return getTypeOfTypeAliasCommon(node, node.name, node.expression, 
        /* isPep695Syntax */ true, (_a = node.typeParameters) === null || _a === void 0 ? void 0 : _a.parameters, () => {
            if (node.typeParameters) {
                return evaluateTypeParameterList(node.typeParameters);
            }
            return undefined;
        });
    }
    // This function is common to the handling of "type" statements and explicit
    // calls to the TypeAliasType constructor.
    function getTypeOfTypeAliasCommon(declNode, nameNode, valueNode, isPep695Syntax, typeParamNodes, getTypeParamCallback) {
        const cachedType = readTypeCache(nameNode, 0 /* EvalFlags.None */);
        if (cachedType) {
            return cachedType;
        }
        // Synthesize a type variable that represents the type alias while we're
        // evaluating it. This allows us to handle recursive definitions.
        const typeAliasTypeVar = synthesizeTypeAliasPlaceholder(nameNode);
        // Write the type to the type cache to support recursive type alias definitions.
        writeTypeCache(nameNode, { type: typeAliasTypeVar }, /* flags */ undefined);
        // Set a partial type to handle recursive (self-referential) type aliases.
        const scope = ScopeUtils.getScopeForNode(declNode);
        const typeAliasSymbol = scope === null || scope === void 0 ? void 0 : scope.lookUpSymbolRecursive(nameNode.value);
        const typeAliasDecl = AnalyzerNodeInfo.getDeclaration(declNode);
        if (typeAliasDecl && typeAliasSymbol) {
            setSymbolResolutionPartialType(typeAliasSymbol.symbol, typeAliasDecl, typeAliasTypeVar);
        }
        const typeParameters = getTypeParamCallback();
        typeAliasTypeVar.details.recursiveTypeParameters = typeParameters || [];
        const aliasTypeResult = getTypeOfExpressionExpectingType(valueNode, {
            allowForwardReference: true,
            enforceTypeAnnotationRules: true,
        });
        let isIncomplete = false;
        let aliasType = aliasTypeResult.type;
        if (aliasTypeResult.isIncomplete) {
            isIncomplete = true;
        }
        aliasType = transformTypeForTypeAlias(aliasType, nameNode, nameNode, isPep695Syntax, 
        /* isPep695TypeVarType */ true, typeParameters, typeParamNodes);
        // See if the type alias relies on itself in a way that cannot be resolved.
        if ((0, typeUtils_1.isTypeAliasRecursive)(typeAliasTypeVar, aliasType)) {
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeAliasIsRecursiveDirect().format({
                name: nameNode.value,
            }), valueNode);
            aliasType = types_1.UnknownType.create();
        }
        // Set the resulting type to the boundType of the original type alias
        // to support recursive type aliases.
        typeAliasTypeVar.details.boundType = aliasType;
        writeTypeCache(nameNode, { type: aliasType, isIncomplete }, 0 /* EvalFlags.None */);
        return aliasType;
    }
    function evaluateTypesForAugmentedAssignment(node) {
        if (isTypeCached(node)) {
            return;
        }
        const destTypeResult = (0, operations_1.getTypeOfAugmentedAssignment)(evaluatorInterface, node, /* inferenceContext */ undefined);
        writeTypeCache(node, destTypeResult, 0 /* EvalFlags.None */);
    }
    function getPseudoGenericTypeVarName(paramName) {
        return `__type_of_${paramName}`;
    }
    function getTypeOfClass(node) {
        initializePrefetchedTypes(node);
        // Is this type already cached?
        const cachedClassType = readTypeCache(node.name, 0 /* EvalFlags.None */);
        if (cachedClassType) {
            if (!(0, types_1.isInstantiableClass)(cachedClassType)) {
                // This can happen in rare circumstances where the class declaration
                // is located in an unreachable code block.
                return undefined;
            }
            return {
                classType: cachedClassType,
                decoratedType: readTypeCache(node, 0 /* EvalFlags.None */) || types_1.UnknownType.create(),
            };
        }
        // The type wasn't cached, so we need to create a new one.
        const scope = ScopeUtils.getScopeForNode(node);
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        let classFlags = 0 /* ClassTypeFlags.None */;
        if ((scope === null || scope === void 0 ? void 0 : scope.type) === 5 /* ScopeType.Builtin */ ||
            fileInfo.isTypingStubFile ||
            fileInfo.isTypingExtensionsStubFile ||
            fileInfo.isBuiltInStubFile ||
            fileInfo.isTypeshedStubFile) {
            classFlags |= 1 /* ClassTypeFlags.BuiltInClass */;
            if (fileInfo.isTypingExtensionsStubFile) {
                classFlags |= 4096 /* ClassTypeFlags.TypingExtensionClass */;
            }
            if (node.name.value === 'property') {
                classFlags |= 128 /* ClassTypeFlags.PropertyClass */;
            }
            if (node.name.value === 'tuple') {
                classFlags |= 32768 /* ClassTypeFlags.TupleClass */;
            }
        }
        if (fileInfo.isStubFile) {
            classFlags |= 262144 /* ClassTypeFlags.DefinedInStub */;
        }
        const classType = types_1.ClassType.createInstantiable(node.name.value, ParseTreeUtils.getClassFullName(node, fileInfo.moduleName, node.name.value), fileInfo.moduleName, fileInfo.fileUri, classFlags, 
        /* typeSourceId */ 0, 
        /* declaredMetaclass */ undefined, 
        /* effectiveMetaclass */ undefined, ParseTreeUtils.getDocString(node.suite.statements));
        classType.details.typeVarScopeId = ParseTreeUtils.getScopeIdForNode(node);
        // Is this a special type that supports type promotions according to PEP 484?
        if (typePromotions.has(classType.details.fullName)) {
            classType.includePromotions = true;
        }
        // Some classes refer to themselves within type arguments used within
        // base classes. We'll register the partially-constructed class type
        // to allow these to be resolved.
        const classSymbol = scope === null || scope === void 0 ? void 0 : scope.lookUpSymbol(node.name.value);
        let classDecl;
        const decl = AnalyzerNodeInfo.getDeclaration(node);
        if (decl) {
            classDecl = decl;
        }
        if (classDecl && classSymbol) {
            setSymbolResolutionPartialType(classSymbol, classDecl, classType);
        }
        classType.details.flags |= 8192 /* ClassTypeFlags.PartiallyEvaluated */;
        classType.details.declaration = classDecl;
        return (0, cancellationUtils_1.invalidateTypeCacheIfCanceled)(() => {
            writeTypeCache(node, { type: classType }, /* flags */ undefined);
            writeTypeCache(node.name, { type: classType }, /* flags */ undefined);
            // Keep a list of unique type parameters that are used in the
            // base class arguments.
            let typeParameters = [];
            if (node.typeParameters) {
                typeParameters = evaluateTypeParameterList(node.typeParameters).map((t) => types_1.TypeVarType.cloneAsInstance(t));
            }
            // If the class derives from "Generic" directly, it will provide
            // all of the type parameters in the specified order.
            let genericTypeParameters;
            let protocolTypeParameters;
            let isNamedTupleSubclass = false;
            const initSubclassArgs = [];
            let metaclassNode;
            let exprFlags = 128 /* EvalFlags.InstantiableType */ |
                1024 /* EvalFlags.AllowGeneric */ |
                262144 /* EvalFlags.NoNakedGeneric */ |
                2048 /* EvalFlags.NoTypeVarWithScopeId */ |
                8192 /* EvalFlags.TypeVarGetsCurScope */ |
                16384 /* EvalFlags.EnforceVarianceConsistency */;
            if (fileInfo.isStubFile) {
                exprFlags |= 4 /* EvalFlags.ForwardRefs */;
            }
            node.arguments.forEach((arg) => {
                // Ignore unpacked arguments.
                if (arg.argumentCategory === 2 /* ArgumentCategory.UnpackedDictionary */) {
                    // Evaluate the expression's type so symbols are marked accessed
                    // and errors are reported.
                    getTypeOfExpression(arg.valueExpression);
                    return;
                }
                if (!arg.name) {
                    let argType;
                    if (arg.argumentCategory === 1 /* ArgumentCategory.UnpackedList */) {
                        getTypeOfExpression(arg.valueExpression);
                        argType = types_1.UnknownType.create();
                    }
                    else {
                        argType = getTypeOfExpression(arg.valueExpression, exprFlags).type;
                        if ((0, types_1.isTypeVar)(argType) && argType.specialForm && types_1.TypeBase.isInstance(argType.specialForm)) {
                            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.baseClassInvalid(), arg);
                            argType = types_1.UnknownType.create();
                        }
                        argType = makeTopLevelTypeVarsConcrete(argType);
                    }
                    // In some stub files, classes are conditionally defined (e.g. based
                    // on platform type). We'll assume that the conditional logic is correct
                    // and strip off the "unbound" union.
                    if ((0, types_1.isUnion)(argType)) {
                        argType = (0, types_1.removeUnbound)(argType);
                    }
                    // Any is allowed as a base class. Remove its "special form" flag to avoid
                    // false positive errors.
                    if ((0, types_1.isAny)(argType) && argType.specialForm) {
                        argType = types_1.AnyType.create();
                    }
                    if (!(0, types_1.isAnyOrUnknown)(argType) && !(0, types_1.isUnbound)(argType)) {
                        if ((0, typeUtils_1.isMetaclassInstance)(argType)) {
                            (0, debug_1.assert)((0, types_1.isClassInstance)(argType));
                            argType =
                                argType.typeArguments && argType.typeArguments.length > 0
                                    ? argType.typeArguments[0]
                                    : types_1.UnknownType.create();
                        }
                        else if (!(0, types_1.isInstantiableClass)(argType)) {
                            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.baseClassInvalid(), arg);
                            argType = types_1.UnknownType.create();
                        }
                        else {
                            if (types_1.ClassType.isPartiallyEvaluated(argType) ||
                                argType.details.mro.some((t) => (0, types_1.isClass)(t) && types_1.ClassType.isPartiallyEvaluated(t))) {
                                // If the base class is partially evaluated, install a callback
                                // so we can fix up this class (e.g. compute the MRO) when the
                                // dependent class is completed.
                                registerDeferredClassCompletion(node, argType);
                            }
                            if (types_1.ClassType.isBuiltIn(argType, 'Protocol')) {
                                if (!fileInfo.isStubFile &&
                                    !types_1.ClassType.isTypingExtensionClass(argType) &&
                                    fileInfo.executionEnvironment.pythonVersion.isLessThan(pythonVersion_1.pythonVersion3_7)) {
                                    addError(localize_1.LocMessage.protocolIllegal(), arg.valueExpression);
                                }
                                classType.details.flags |= 512 /* ClassTypeFlags.ProtocolClass */;
                            }
                            if (types_1.ClassType.isBuiltIn(argType, 'property')) {
                                classType.details.flags |= 128 /* ClassTypeFlags.PropertyClass */;
                            }
                            // If the class directly derives from NamedTuple (in Python 3.6 or
                            // newer), it's considered a (read-only) dataclass.
                            if (fileInfo.executionEnvironment.pythonVersion.isGreaterOrEqualTo(pythonVersion_1.pythonVersion3_6)) {
                                if (types_1.ClassType.isBuiltIn(argType, 'NamedTuple')) {
                                    isNamedTupleSubclass = true;
                                    classType.details.flags |= 524288 /* ClassTypeFlags.ReadOnlyInstanceVariables */;
                                }
                            }
                            // If the class directly derives from TypedDict or from a class that is
                            // a TypedDict, it is considered a TypedDict.
                            if (types_1.ClassType.isBuiltIn(argType, 'TypedDict') || types_1.ClassType.isTypedDictClass(argType)) {
                                classType.details.flags |= 4 /* ClassTypeFlags.TypedDictClass */;
                                // Propagate the "effectively closed" flag from base classes.
                                if (types_1.ClassType.isTypedDictEffectivelyClosed(argType)) {
                                    classType.details.flags |= 16 /* ClassTypeFlags.TypedDictEffectivelyClosed */;
                                }
                            }
                            // Validate that the class isn't deriving from itself, creating a
                            // circular dependency.
                            if ((0, typeUtils_1.derivesFromClassRecursive)(argType, classType, /* ignoreUnknown */ true)) {
                                addError(localize_1.LocMessage.baseClassCircular(), arg);
                                argType = types_1.UnknownType.create();
                            }
                            // If the class is attempting to derive from a TypeAliasType,
                            // generate an error.
                            if (argType.specialForm && types_1.ClassType.isBuiltIn(argType.specialForm, 'TypeAliasType')) {
                                addError(localize_1.LocMessage.typeAliasTypeBaseClass(), arg);
                                argType = types_1.UnknownType.create();
                            }
                        }
                    }
                    if ((0, types_1.isUnknown)(argType)) {
                        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportUntypedBaseClass, localize_1.LocMessage.baseClassUnknown(), arg);
                    }
                    // Check for a duplicate class.
                    if (classType.details.baseClasses.some((prevBaseClass) => {
                        return ((0, types_1.isInstantiableClass)(prevBaseClass) &&
                            (0, types_1.isInstantiableClass)(argType) &&
                            types_1.ClassType.isSameGenericClass(argType, prevBaseClass));
                    })) {
                        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.duplicateBaseClass(), arg.name || arg);
                    }
                    classType.details.baseClasses.push(argType);
                    if ((0, types_1.isInstantiableClass)(argType)) {
                        if (types_1.ClassType.isEnumClass(argType)) {
                            classType.details.flags |= 65536 /* ClassTypeFlags.EnumClass */;
                        }
                        // Determine if the class is abstract. Protocol classes support abstract methods
                        // because they are constructed by the _ProtocolMeta metaclass, which derives
                        // from ABCMeta. We'll exclude built-in protocol classes because these are known
                        // not to contain any abstract methods and getAbstractMethods causes problems
                        // because of dependencies on some of these built-in protocol classes.
                        if (types_1.ClassType.supportsAbstractMethods(argType) ||
                            (types_1.ClassType.isProtocolClass(argType) && !types_1.ClassType.isBuiltIn(argType))) {
                            classType.details.flags |= 64 /* ClassTypeFlags.SupportsAbstractMethods */;
                        }
                        if (types_1.ClassType.isPropertyClass(argType)) {
                            classType.details.flags |= 128 /* ClassTypeFlags.PropertyClass */;
                        }
                        if (types_1.ClassType.isFinal(argType)) {
                            const className = printObjectTypeForClass(argType);
                            addError(localize_1.LocMessage.baseClassFinal().format({ type: className }), arg.valueExpression);
                        }
                    }
                    (0, typeUtils_1.addTypeVarsToListIfUnique)(typeParameters, (0, typeUtils_1.getTypeVarArgumentsRecursive)(argType));
                    if ((0, types_1.isInstantiableClass)(argType)) {
                        if (types_1.ClassType.isBuiltIn(argType, 'Generic')) {
                            // 'Generic' is implicitly added if type parameter syntax is used.
                            if (node.typeParameters) {
                                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.genericBaseClassNotAllowed(), arg.valueExpression);
                            }
                            else {
                                if (!genericTypeParameters) {
                                    if (protocolTypeParameters) {
                                        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.duplicateGenericAndProtocolBase(), arg.valueExpression);
                                    }
                                    genericTypeParameters = [];
                                    (0, typeUtils_1.addTypeVarsToListIfUnique)(genericTypeParameters, (0, typeUtils_1.getTypeVarArgumentsRecursive)(argType));
                                }
                            }
                        }
                        else if (types_1.ClassType.isBuiltIn(argType, 'Protocol') &&
                            argType.typeArguments &&
                            argType.typeArguments.length > 0) {
                            if (!protocolTypeParameters) {
                                if (genericTypeParameters) {
                                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.duplicateGenericAndProtocolBase(), arg.valueExpression);
                                }
                                protocolTypeParameters = [];
                                (0, typeUtils_1.addTypeVarsToListIfUnique)(protocolTypeParameters, (0, typeUtils_1.getTypeVarArgumentsRecursive)(argType));
                                if (node.typeParameters && protocolTypeParameters.length > 0) {
                                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.protocolBaseClassWithTypeArgs(), arg.valueExpression);
                                    protocolTypeParameters = [];
                                }
                            }
                        }
                    }
                }
                else if (types_1.ClassType.isTypedDictClass(classType)) {
                    if (arg.name.value === 'total' || arg.name.value === 'closed') {
                        // The "total" and "readonly" parameters apply only for TypedDict classes.
                        // PEP 589 specifies that the parameter must be either True or False.
                        const constArgValue = (0, staticExpressions_1.evaluateStaticBoolExpression)(arg.valueExpression, fileInfo.executionEnvironment, fileInfo.definedConstants);
                        if (constArgValue === undefined) {
                            addError(localize_1.LocMessage.typedDictBoolParam().format({ name: arg.name.value }), arg.valueExpression);
                        }
                        else if (arg.name.value === 'total' && !constArgValue) {
                            classType.details.flags |= 32 /* ClassTypeFlags.CanOmitDictValues */;
                        }
                        else if (arg.name.value === 'closed' && constArgValue) {
                            // This is an experimental feature because PEP 728 hasn't been accepted yet.
                            if (AnalyzerNodeInfo.getFileInfo(node).diagnosticRuleSet.enableExperimentalFeatures) {
                                classType.details.flags |=
                                    8 /* ClassTypeFlags.TypedDictMarkedClosed */ | 16 /* ClassTypeFlags.TypedDictEffectivelyClosed */;
                            }
                        }
                    }
                    else {
                        addError(localize_1.LocMessage.typedDictInitsubclassParameter().format({ name: arg.name.value }), arg);
                    }
                }
                else if (arg.name.value === 'metaclass') {
                    if (metaclassNode) {
                        addError(localize_1.LocMessage.metaclassDuplicate(), arg);
                    }
                    else {
                        metaclassNode = arg.valueExpression;
                    }
                }
                else {
                    // Collect arguments that will be passed to the `__init_subclass__`
                    // method described in PEP 487.
                    initSubclassArgs.push({
                        argumentCategory: 0 /* ArgumentCategory.Simple */,
                        node: arg,
                        name: arg.name,
                        valueExpression: arg.valueExpression,
                    });
                }
            });
            // Check for NamedTuple multiple inheritance.
            if (classType.details.baseClasses.length > 1) {
                let derivesFromNamedTuple = false;
                let foundIllegalBaseClass = false;
                classType.details.baseClasses.forEach((baseClass) => {
                    if ((0, types_1.isInstantiableClass)(baseClass)) {
                        if (types_1.ClassType.isBuiltIn(baseClass, 'NamedTuple')) {
                            derivesFromNamedTuple = true;
                        }
                        else if (!types_1.ClassType.isBuiltIn(baseClass, 'Generic')) {
                            foundIllegalBaseClass = true;
                        }
                    }
                });
                if (derivesFromNamedTuple && foundIllegalBaseClass) {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.namedTupleMultipleInheritance(), node.name);
                }
            }
            // Make sure we don't have 'object' derive from itself. Infinite
            // recursion will result.
            if (!types_1.ClassType.isBuiltIn(classType, 'object') &&
                classType.details.baseClasses.filter((baseClass) => (0, types_1.isClass)(baseClass)).length === 0) {
                // If there are no other (known) base classes, the class implicitly derives from object.
                classType.details.baseClasses.push(getBuiltInType(node, 'object'));
            }
            // If genericTypeParameters or protocolTypeParameters are provided,
            // make sure that typeParameters is a proper subset.
            genericTypeParameters = genericTypeParameters !== null && genericTypeParameters !== void 0 ? genericTypeParameters : protocolTypeParameters;
            if (genericTypeParameters && !node.typeParameters) {
                verifyGenericTypeParameters(node.name, typeParameters, genericTypeParameters);
            }
            classType.details.typeParameters = genericTypeParameters !== null && genericTypeParameters !== void 0 ? genericTypeParameters : typeParameters;
            // Determine if one or more type parameters is autovariance.
            if (classType.details.typeParameters.some((param) => param.details.declaredVariance === 0 /* Variance.Auto */ && param.computedVariance === undefined)) {
                classType.details.requiresVarianceInference = true;
            }
            // Make sure there's at most one variadic type parameter.
            const variadics = typeParameters.filter((param) => (0, types_1.isVariadicTypeVar)(param));
            if (variadics.length > 1) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.variadicTypeParamTooManyClass().format({
                    names: variadics.map((v) => `"${v.details.name}"`).join(', '),
                }), node.name, textRange_1.TextRange.combine(node.arguments) || node.name);
            }
            else if (variadics.length > 0) {
                // Make sure a TypeVar with a default doesn't come after a variadic type parameter.
                const firstVariadicIndex = classType.details.typeParameters.findIndex((param) => (0, types_1.isVariadicTypeVar)(param));
                const typeVarWithDefaultIndex = classType.details.typeParameters.findIndex((param, index) => index > firstVariadicIndex && !param.details.isParamSpec && param.details.isDefaultExplicit);
                if (typeVarWithDefaultIndex >= 0) {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeVarWithDefaultFollowsVariadic().format({
                        typeVarName: typeParameters[typeVarWithDefaultIndex].details.name,
                        variadicName: typeParameters[firstVariadicIndex].details.name,
                    }), node.typeParameters ? node.typeParameters.parameters[typeVarWithDefaultIndex].name : node.name);
                }
            }
            // Validate the default types for all type parameters.
            classType.details.typeParameters.forEach((typeParam, index) => {
                var _a;
                let bestErrorNode = node.name;
                if (node.typeParameters && index < node.typeParameters.parameters.length) {
                    const typeParamNode = node.typeParameters.parameters[index];
                    bestErrorNode = (_a = typeParamNode.defaultExpression) !== null && _a !== void 0 ? _a : typeParamNode.name;
                }
                validateTypeParameterDefault(bestErrorNode, typeParam, classType.details.typeParameters.slice(0, index), classType.details.typeVarScopeId);
            });
            if (!(0, typeUtils_1.computeMroLinearization)(classType)) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.methodOrdering(), node.name);
            }
            // The scope for this class becomes the "fields" for the corresponding type.
            const innerScope = ScopeUtils.getScopeForNode(node.suite);
            classType.details.fields = (innerScope === null || innerScope === void 0 ? void 0 : innerScope.symbolTable)
                ? new Map(innerScope.symbolTable)
                : new Map();
            // Determine whether the class should inherit __hash__. If a class defines
            // __eq__ but doesn't define __hash__ then __hash__ is set to None.
            if (classType.details.fields.has('__eq__') && !classType.details.fields.has('__hash__')) {
                classType.details.fields.set('__hash__', symbol_1.Symbol.createWithType(4 /* SymbolFlags.ClassMember */ |
                    128 /* SymbolFlags.ClassVar */ |
                    64 /* SymbolFlags.IgnoredForProtocolMatch */ |
                    4096 /* SymbolFlags.IgnoredForOverrideChecks */, getNoneType()));
            }
            // Determine whether the class's instance variables are constrained
            // to those defined by __slots__. We need to do this prior to dataclass
            // processing because dataclasses can implicitly add to the slots
            // list.
            const slotsNames = innerScope === null || innerScope === void 0 ? void 0 : innerScope.getSlotsNames();
            if (slotsNames) {
                classType.details.localSlotsNames = slotsNames;
            }
            // Determine if the class should be a "pseudo-generic" class, characterized
            // by having an __init__ method with parameters that lack type annotations.
            // For such classes, we'll treat them as generic, with the type arguments provided
            // by the callers of the constructor.
            if (!fileInfo.isStubFile && classType.details.typeParameters.length === 0) {
                const initMethod = classType.details.fields.get('__init__');
                if (initMethod) {
                    const initDecls = initMethod.getTypedDeclarations();
                    if (initDecls.length === 1 && initDecls[0].type === 5 /* DeclarationType.Function */) {
                        const initDeclNode = initDecls[0].node;
                        const initParams = initDeclNode.parameters;
                        if (initParams.length > 1 &&
                            !initParams.some((param, index) => !!ParseTreeUtils.getTypeAnnotationForParameter(initDeclNode, index))) {
                            const genericParams = initParams.filter((param, index) => index > 0 &&
                                param.name &&
                                param.category === 0 /* ParameterCategory.Simple */ &&
                                !param.defaultValue);
                            if (genericParams.length > 0) {
                                classType.details.flags |= 1024 /* ClassTypeFlags.PseudoGenericClass */;
                                // Create a type parameter for each simple, named parameter
                                // in the __init__ method.
                                classType.details.typeParameters = genericParams.map((param) => {
                                    const typeVar = types_1.TypeVarType.createInstance(getPseudoGenericTypeVarName(param.name.value));
                                    typeVar.details.isSynthesized = true;
                                    typeVar.scopeId = ParseTreeUtils.getScopeIdForNode(initDeclNode);
                                    typeVar.details.boundType = types_1.UnknownType.create();
                                    return types_1.TypeVarType.cloneForScopeId(typeVar, ParseTreeUtils.getScopeIdForNode(node), node.name.value, 0 /* TypeVarScopeType.Class */);
                                });
                            }
                        }
                    }
                }
            }
            // Determine if the class has a custom __class_getitem__ method. This applies
            // only to classes that have no type parameters, since those with type parameters
            // are assumed to follow normal subscripting semantics for generic classes.
            if (classType.details.typeParameters.length === 0 && !types_1.ClassType.isBuiltIn(classType, 'type')) {
                if (classType.details.baseClasses.some((baseClass) => (0, types_1.isInstantiableClass)(baseClass) && types_1.ClassType.hasCustomClassGetItem(baseClass)) ||
                    classType.details.fields.has('__class_getitem__')) {
                    classType.details.flags |= 16384 /* ClassTypeFlags.HasCustomClassGetItem */;
                }
            }
            // Determine the effective metaclass.
            if (metaclassNode) {
                const metaclassType = getTypeOfExpression(metaclassNode, exprFlags).type;
                if ((0, types_1.isInstantiableClass)(metaclassType) || (0, types_1.isUnknown)(metaclassType)) {
                    if ((0, typeUtils_1.requiresSpecialization)(metaclassType, { ignorePseudoGeneric: true })) {
                        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.metaclassIsGeneric(), metaclassNode);
                    }
                    classType.details.declaredMetaclass = metaclassType;
                    if ((0, types_1.isInstantiableClass)(metaclassType)) {
                        if ((0, enums_1.isEnumMetaclass)(metaclassType)) {
                            classType.details.flags |= 65536 /* ClassTypeFlags.EnumClass */;
                        }
                        if (types_1.ClassType.isBuiltIn(metaclassType, 'ABCMeta')) {
                            classType.details.flags |= 64 /* ClassTypeFlags.SupportsAbstractMethods */;
                        }
                    }
                }
            }
            const effectiveMetaclass = computeEffectiveMetaclass(classType, node.name);
            // Clear the "partially constructed" flag.
            classType.details.flags &= ~8192 /* ClassTypeFlags.PartiallyEvaluated */;
            // Now determine the decorated type of the class.
            let decoratedType = classType;
            let foundUnknown = false;
            for (let i = node.decorators.length - 1; i >= 0; i--) {
                const decorator = node.decorators[i];
                const newDecoratedType = (0, decorators_1.applyClassDecorator)(evaluatorInterface, decoratedType, classType, decorator);
                const unknownOrAny = (0, typeUtils_1.containsAnyOrUnknown)(newDecoratedType, /* recurse */ false);
                if (unknownOrAny && (0, types_1.isUnknown)(unknownOrAny)) {
                    // Report this error only on the first unknown type.
                    if (!foundUnknown) {
                        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportUntypedClassDecorator, localize_1.LocMessage.classDecoratorTypeUnknown(), node.decorators[i].expression);
                        foundUnknown = true;
                    }
                }
                else {
                    // Apply the decorator only if the type is known.
                    decoratedType = newDecoratedType;
                }
            }
            // Determine whether this class derives from (or has a metaclass) that imbues
            // it with dataclass-like behaviors. If so, we'll apply those here.
            let dataClassBehaviors;
            if ((0, types_1.isInstantiableClass)(effectiveMetaclass) && effectiveMetaclass.details.classDataClassTransform) {
                dataClassBehaviors = effectiveMetaclass.details.classDataClassTransform;
            }
            else {
                const baseClassDataTransform = classType.details.mro.find((mroClass) => {
                    return ((0, types_1.isClass)(mroClass) &&
                        mroClass.details.classDataClassTransform !== undefined &&
                        !types_1.ClassType.isSameGenericClass(mroClass, classType));
                });
                if (baseClassDataTransform) {
                    dataClassBehaviors = baseClassDataTransform.details.classDataClassTransform;
                }
            }
            if (dataClassBehaviors) {
                (0, dataClasses_1.applyDataClassClassBehaviorOverrides)(evaluatorInterface, node.name, classType, initSubclassArgs, dataClassBehaviors);
            }
            // Run any deferred class completions that depend on this class.
            runDeferredClassCompletions(classType);
            // If there are any outstanding deferred class completions registered that
            // were not removed by the call to runDeferredClassCompletions, assume that
            // the current class may depend on them and register for deferred completion.
            registerDeferredClassCompletion(node, /* dependsUpon */ undefined);
            // Synthesize TypedDict methods.
            if (types_1.ClassType.isTypedDictClass(classType)) {
                // TypedDict classes must derive only from other TypedDict classes.
                let foundInvalidBaseClass = false;
                const diag = new diagnostic_1.DiagnosticAddendum();
                classType.details.baseClasses.forEach((baseClass) => {
                    if ((0, types_1.isClass)(baseClass) &&
                        !types_1.ClassType.isTypedDictClass(baseClass) &&
                        !types_1.ClassType.isBuiltIn(baseClass, ['_TypedDict', 'Generic'])) {
                        foundInvalidBaseClass = true;
                        diag.addMessage(localize_1.LocAddendum.typedDictBaseClass().format({ type: baseClass.details.name }));
                    }
                });
                if (foundInvalidBaseClass) {
                    addError(localize_1.LocMessage.typedDictBaseClass() + diag.getString(), node.name);
                }
                (0, typedDicts_1.synthesizeTypedDictClassMethods)(evaluatorInterface, node, classType);
            }
            // Synthesize dataclass methods.
            if (types_1.ClassType.isDataClass(classType) || isNamedTupleSubclass) {
                const skipSynthesizedInit = types_1.ClassType.isDataClassSkipGenerateInit(classType);
                let hasExistingInitMethod = skipSynthesizedInit;
                // See if there's already a non-synthesized __init__ method.
                // We shouldn't override it.
                if (!skipSynthesizedInit) {
                    const initSymbol = classType.details.fields.get('__init__');
                    if (initSymbol && initSymbol.isClassMember()) {
                        hasExistingInitMethod = true;
                    }
                }
                let skipSynthesizeHash = false;
                const hashSymbol = classType.details.fields.get('__hash__');
                // If there is a hash symbol defined in the class (i.e. one that we didn't
                // synthesize above), then we shouldn't synthesize a new one for the dataclass.
                if (hashSymbol && hashSymbol.isClassMember() && !hashSymbol.getSynthesizedType()) {
                    skipSynthesizeHash = true;
                }
                const synthesizeMethods = () => (0, dataClasses_1.synthesizeDataClassMethods)(evaluatorInterface, node, classType, isNamedTupleSubclass, skipSynthesizedInit, hasExistingInitMethod, skipSynthesizeHash);
                // If this is a NamedTuple subclass, immediately synthesize dataclass methods
                // because we also need to update the MRO classes in this case. For regular
                // dataclasses, we'll defer the  method synthesis to avoid circular dependencies.
                if (isNamedTupleSubclass) {
                    synthesizeMethods();
                }
                else {
                    classType.details.synthesizeMethodsDeferred = () => {
                        delete classType.details.synthesizeMethodsDeferred;
                        synthesizeMethods();
                    };
                }
            }
            // Build a complete list of all slots names defined by the class hierarchy.
            // This needs to be done after dataclass processing.
            classType.details.calculateInheritedSlotsNamesDeferred = () => {
                delete classType.details.calculateInheritedSlotsNamesDeferred;
                if (classType.details.localSlotsNames) {
                    let isLimitedToSlots = true;
                    const extendedSlotsNames = Array.from(classType.details.localSlotsNames);
                    classType.details.baseClasses.forEach((baseClass) => {
                        if ((0, types_1.isInstantiableClass)(baseClass)) {
                            if (!types_1.ClassType.isBuiltIn(baseClass, 'object') &&
                                !types_1.ClassType.isBuiltIn(baseClass, 'type') &&
                                !types_1.ClassType.isBuiltIn(baseClass, 'Generic')) {
                                const inheritedSlotsNames = types_1.ClassType.getInheritedSlotsNames(baseClass);
                                if (inheritedSlotsNames) {
                                    (0, collectionUtils_1.appendArray)(extendedSlotsNames, inheritedSlotsNames);
                                }
                                else {
                                    isLimitedToSlots = false;
                                }
                            }
                        }
                        else {
                            isLimitedToSlots = false;
                        }
                    });
                    if (isLimitedToSlots) {
                        classType.details.inheritedSlotsNamesCached = extendedSlotsNames;
                    }
                }
            };
            // Update the undecorated class type.
            writeTypeCache(node.name, { type: classType }, 0 /* EvalFlags.None */);
            // Update the decorated class type.
            writeTypeCache(node, { type: decoratedType }, 0 /* EvalFlags.None */);
            return { classType, decoratedType };
        });
    }
    // Determines whether the type parameters has a default that refers to another
    // type parameter. If so, validates that it is in the list of "live" type
    // parameters and updates the scope of the type parameter referred to in the
    // default type expression.
    function validateTypeParameterDefault(errorNode, typeParam, otherLiveTypeParams, scopeId) {
        if (!typeParam.details.isDefaultExplicit &&
            !typeParam.details.isSynthesized &&
            !typeParam.details.isSynthesizedSelf) {
            const typeVarWithDefault = otherLiveTypeParams.find((param) => param.details.isDefaultExplicit && param.scopeId === scopeId);
            if (typeVarWithDefault) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeVarWithoutDefault().format({
                    name: typeParam.details.name,
                    other: typeVarWithDefault.details.name,
                }), errorNode);
            }
            return;
        }
        const invalidTypeVars = new Set();
        (0, typeUtils_1.validateTypeVarDefault)(typeParam, otherLiveTypeParams, invalidTypeVars);
        // If we found one or more unapplied type variable, report an error.
        if (invalidTypeVars.size > 0) {
            const diag = new diagnostic_1.DiagnosticAddendum();
            invalidTypeVars.forEach((name) => {
                diag.addMessage(localize_1.LocAddendum.typeVarDefaultOutOfScope().format({ name }));
            });
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeVarDefaultInvalidTypeVar().format({
                name: typeParam.details.name,
            }) + diag.getString(), errorNode);
        }
    }
    function inferTypeParameterVarianceForClass(classType) {
        if (!classType.details.requiresVarianceInference) {
            return;
        }
        // Presumptively mark the variance inference as complete. This
        // prevents potential recursion.
        classType.details.requiresVarianceInference = false;
        // Presumptively mark the computed variance to "unknown". We'll
        // replace this below once the variance has been inferred.
        classType.details.typeParameters.forEach((param) => {
            if (param.details.declaredVariance === 0 /* Variance.Auto */) {
                param.computedVariance = 1 /* Variance.Unknown */;
            }
        });
        const dummyTypeObject = types_1.ClassType.createInstantiable('__varianceDummy', '', '', uri_1.Uri.empty(), 0, 0, undefined, undefined);
        classType.details.typeParameters.forEach((param, paramIndex) => {
            // Skip variadics and ParamSpecs.
            if (param.details.isVariadic || param.details.isParamSpec) {
                return;
            }
            // Skip type variables without auto-variance.
            if (param.details.declaredVariance !== 0 /* Variance.Auto */) {
                return;
            }
            // Replace all type arguments with a dummy type except for the
            // TypeVar of interest, which is replaced with an object instance.
            const srcTypeArgs = classType.details.typeParameters.map((p, i) => {
                if (p.details.isVariadic) {
                    return p;
                }
                return i === paramIndex ? getObjectType() : dummyTypeObject;
            });
            // Replace all type arguments with a dummy type except for the
            // TypeVar of interest, which is replaced with itself.
            const destTypeArgs = classType.details.typeParameters.map((p, i) => {
                return i === paramIndex || p.details.isVariadic ? p : dummyTypeObject;
            });
            const srcType = types_1.ClassType.cloneForSpecialization(classType, srcTypeArgs, /* isTypeArgumentExplicit */ true);
            const destType = types_1.ClassType.cloneForSpecialization(classType, destTypeArgs, 
            /* isTypeArgumentExplicit */ true);
            const isDestSubtypeOfSrc = assignClassToSelf(srcType, destType, 3 /* Variance.Covariant */, 
            /* ignoreBaseClassVariance */ false);
            let inferredVariance;
            if (isDestSubtypeOfSrc) {
                inferredVariance = 3 /* Variance.Covariant */;
            }
            else {
                const isSrcSubtypeOfDest = assignClassToSelf(destType, srcType, 4 /* Variance.Contravariant */, 
                /* ignoreBaseClassVariance */ false);
                if (isSrcSubtypeOfDest) {
                    inferredVariance = 4 /* Variance.Contravariant */;
                }
                else {
                    inferredVariance = 2 /* Variance.Invariant */;
                }
            }
            // We assume here that we don't need to clone the type var object
            // because it was already cloned when it was associated with this
            // class scope.
            classType.details.typeParameters[paramIndex].computedVariance = inferredVariance;
        });
    }
    function evaluateTypeParameterList(node) {
        const paramTypes = [];
        const typeParamScope = AnalyzerNodeInfo.getScope(node);
        node.parameters.forEach((param) => {
            var _a;
            const paramSymbol = typeParamScope === null || typeParamScope === void 0 ? void 0 : typeParamScope.symbolTable.get(param.name.value);
            if (!paramSymbol) {
                // This can happen if the code is unreachable.
                return;
            }
            const typeOfParam = (_a = getDeclaredTypeOfSymbol(paramSymbol, param.name)) === null || _a === void 0 ? void 0 : _a.type;
            if (!typeOfParam || !(0, types_1.isTypeVar)(typeOfParam)) {
                return;
            }
            writeTypeCache(param.name, { type: typeOfParam }, 0 /* EvalFlags.None */);
            paramTypes.push(typeOfParam);
        });
        return paramTypes;
    }
    function computeEffectiveMetaclass(classType, errorNode) {
        let effectiveMetaclass = classType.details.declaredMetaclass;
        let reportedMetaclassConflict = false;
        if (!effectiveMetaclass || (0, types_1.isInstantiableClass)(effectiveMetaclass)) {
            for (const baseClass of classType.details.baseClasses) {
                if ((0, types_1.isInstantiableClass)(baseClass)) {
                    const baseClassMeta = baseClass.details.effectiveMetaclass || typeClass;
                    if (baseClassMeta && (0, types_1.isInstantiableClass)(baseClassMeta)) {
                        // Make sure there is no metaclass conflict.
                        if (!effectiveMetaclass) {
                            effectiveMetaclass = baseClassMeta;
                        }
                        else if ((0, typeUtils_1.derivesFromClassRecursive)(baseClassMeta, effectiveMetaclass, /* ignoreUnknown */ false)) {
                            effectiveMetaclass = baseClassMeta;
                        }
                        else if (!(0, typeUtils_1.derivesFromClassRecursive)(effectiveMetaclass, baseClassMeta, /* ignoreUnknown */ false)) {
                            if (!reportedMetaclassConflict) {
                                const diag = new diagnostic_1.DiagnosticAddendum();
                                diag.addMessage(localize_1.LocAddendum.metaclassConflict().format({
                                    metaclass1: printType((0, typeUtils_1.convertToInstance)(effectiveMetaclass)),
                                    metaclass2: printType((0, typeUtils_1.convertToInstance)(baseClassMeta)),
                                }));
                                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.metaclassConflict() + diag.getString(), errorNode);
                                // Don't report more than once.
                                reportedMetaclassConflict = true;
                            }
                        }
                    }
                    else {
                        effectiveMetaclass = baseClassMeta ? types_1.UnknownType.create() : undefined;
                        break;
                    }
                }
                else {
                    // If one of the base classes is unknown, then the effective
                    // metaclass is also unknowable.
                    effectiveMetaclass = types_1.UnknownType.create();
                    break;
                }
            }
        }
        // If we haven't found an effective metaclass, assume "type", which
        // is the metaclass for "object".
        if (!effectiveMetaclass) {
            const typeMetaclass = getBuiltInType(errorNode, 'type');
            effectiveMetaclass =
                typeMetaclass && (0, types_1.isInstantiableClass)(typeMetaclass) ? typeMetaclass : types_1.UnknownType.create();
        }
        classType.details.effectiveMetaclass = effectiveMetaclass;
        return effectiveMetaclass;
    }
    // Verifies that the type variables provided outside of "Generic"
    // or "Protocol" are also provided within the "Generic". For example:
    //    class Foo(Mapping[K, V], Generic[V])
    // is illegal because K is not included in Generic.
    function verifyGenericTypeParameters(errorNode, typeVars, genericTypeVars) {
        const missingFromGeneric = typeVars.filter((typeVar) => {
            return !genericTypeVars.some((genericTypeVar) => genericTypeVar.details.name === typeVar.details.name);
        });
        if (missingFromGeneric.length > 0) {
            const diag = new diagnostic_1.DiagnosticAddendum();
            diag.addMessage(localize_1.LocAddendum.typeVarsMissing().format({
                names: missingFromGeneric.map((typeVar) => `"${typeVar.details.name}"`).join(', '),
            }));
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeVarsNotInGenericOrProtocol() + diag.getString(), errorNode);
        }
    }
    // Records the fact that the specified class requires "deferred completion" because
    // one of its base classes has not yet been fully evaluated. If the caller passes
    // undefined for "dependsUpon", then the class is added to all outstanding deferred
    // completions.
    function registerDeferredClassCompletion(classToComplete, dependsUpon) {
        if (dependsUpon) {
            // See if there is an existing entry for this dependency.
            const entry = deferredClassCompletions.find((e) => types_1.ClassType.isSameGenericClass(e.dependsUpon, dependsUpon));
            if (entry) {
                entry.classesToComplete.push(classToComplete);
            }
            else {
                deferredClassCompletions.push({ dependsUpon, classesToComplete: [classToComplete] });
            }
        }
        else {
            deferredClassCompletions.forEach((e) => {
                e.classesToComplete.push(classToComplete);
            });
        }
    }
    // Runs any registered "deferred class completions" that depend on the specified
    // class type. This allows us to complete any work that requires dependent classes
    // to be completed.
    function runDeferredClassCompletions(type) {
        deferredClassCompletions.forEach((e) => {
            if (types_1.ClassType.isSameGenericClass(e.dependsUpon, type)) {
                e.classesToComplete.forEach((classNode) => {
                    const classType = readTypeCache(classNode.name, 0 /* EvalFlags.None */);
                    if (classType) {
                        completeClassTypeDeferred(classType, classNode.name);
                    }
                });
            }
        });
        // Remove any completions that depend on this type.
        deferredClassCompletions = deferredClassCompletions.filter((e) => !types_1.ClassType.isSameGenericClass(e.dependsUpon, type));
    }
    // Recomputes the MRO and effective metaclass for the class after dependent
    // classes have been fully constructed.
    function completeClassTypeDeferred(type, errorNode) {
        // Recompute the MRO linearization.
        if (!(0, typeUtils_1.computeMroLinearization)(type)) {
            addError(localize_1.LocMessage.methodOrdering(), errorNode);
        }
        // Recompute the effective metaclass.
        computeEffectiveMetaclass(type, errorNode);
    }
    function validateInitSubclassArgs(node, classType) {
        var _a, _b;
        // Collect arguments that will be passed to the `__init_subclass__`
        // method described in PEP 487 and validate it.
        const argList = [];
        node.arguments.forEach((arg) => {
            if (arg.name && arg.name.value !== 'metaclass') {
                argList.push({
                    argumentCategory: 0 /* ArgumentCategory.Simple */,
                    node: arg,
                    name: arg.name,
                    valueExpression: arg.valueExpression,
                });
            }
        });
        const errorNode = argList.length > 0 ? (_b = (_a = argList[0].node) === null || _a === void 0 ? void 0 : _a.valueExpression) !== null && _b !== void 0 ? _b : node.name : node.name;
        let newMethodMember;
        // See if the class has a metaclass that overrides `__new__`. If so, we
        // will validate the signature of the `__new__` method.
        if (classType.details.effectiveMetaclass && (0, types_1.isClass)(classType.details.effectiveMetaclass)) {
            // If the metaclass is 'type' or 'ABCMeta', we'll assume it will call through to
            // __init_subclass__, so we'll skip the `__new__` method check. We need to exclude
            // TypedDict classes here because _TypedDict uses ABCMeta as its metaclass, but its
            // typeshed definition doesn't override __init_subclass__.
            const metaclassCallsInitSubclass = types_1.ClassType.isBuiltIn(classType.details.effectiveMetaclass, ['ABCMeta', 'type']) &&
                !types_1.ClassType.isTypedDictClass(classType);
            if (!metaclassCallsInitSubclass) {
                // See if the metaclass has a `__new__` method that accepts keyword parameters.
                newMethodMember = (0, typeUtils_1.lookUpClassMember)(classType.details.effectiveMetaclass, '__new__', 8 /* MemberAccessFlags.SkipTypeBaseClass */);
            }
        }
        if (newMethodMember) {
            const newMethodType = getTypeOfMember(newMethodMember);
            if ((0, types_1.isFunction)(newMethodType)) {
                const paramListDetails = (0, parameterUtils_1.getParameterListDetails)(newMethodType);
                if (paramListDetails.firstKeywordOnlyIndex !== undefined) {
                    // Build a map of the keyword-only parameters.
                    const paramMap = new Map();
                    for (let i = paramListDetails.firstKeywordOnlyIndex; i < paramListDetails.params.length; i++) {
                        const paramInfo = paramListDetails.params[i];
                        if (paramInfo.param.category === 0 /* ParameterCategory.Simple */ && paramInfo.param.name) {
                            paramMap.set(paramInfo.param.name, i);
                        }
                    }
                    argList.forEach((arg) => {
                        var _a, _b, _c;
                        const signatureTracker = new typeUtils_1.UniqueSignatureTracker();
                        if (arg.argumentCategory === 0 /* ArgumentCategory.Simple */ && arg.name) {
                            const paramIndex = (_a = paramMap.get(arg.name.value)) !== null && _a !== void 0 ? _a : paramListDetails.kwargsIndex;
                            if (paramIndex !== undefined) {
                                const paramInfo = paramListDetails.params[paramIndex];
                                const argParam = {
                                    paramCategory: paramInfo.param.category,
                                    paramType: paramInfo.type,
                                    requiresTypeVarMatching: false,
                                    argument: arg,
                                    errorNode: (_b = arg.valueExpression) !== null && _b !== void 0 ? _b : errorNode,
                                };
                                validateArgType(argParam, new typeVarContext_1.TypeVarContext(), signatureTracker, { type: newMethodType }, { skipUnknownArgCheck: true, skipOverloadArg: true });
                                paramMap.delete(arg.name.value);
                            }
                            else {
                                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.paramNameMissing().format({ name: arg.name.value }), (_c = arg.name) !== null && _c !== void 0 ? _c : errorNode);
                            }
                        }
                    });
                    // See if we have any remaining unmatched parameters without
                    // default values.
                    const unassignedParams = [];
                    paramMap.forEach((index, paramName) => {
                        const paramInfo = paramListDetails.params[index];
                        if (!paramInfo.param.hasDefault) {
                            unassignedParams.push(paramName);
                        }
                    });
                    if (unassignedParams.length > 0) {
                        const missingParamNames = unassignedParams.map((p) => `"${p}"`).join(', ');
                        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, unassignedParams.length === 1
                            ? localize_1.LocMessage.argMissingForParam().format({ name: missingParamNames })
                            : localize_1.LocMessage.argMissingForParams().format({ names: missingParamNames }), errorNode);
                    }
                }
            }
        }
        else {
            // If there was no custom metaclass __new__ method, see if there is an __init_subclass__
            // method present somewhere in the class hierarchy.
            const initSubclassMethodInfo = getTypeOfBoundMember(errorNode, classType, '__init_subclass__', 
            /* usage */ undefined, 
            /* diag */ undefined, 32 /* MemberAccessFlags.SkipClassMembers */ |
                1 /* MemberAccessFlags.SkipOriginalClass */ |
                512 /* MemberAccessFlags.SkipAttributeAccessOverride */);
            if (initSubclassMethodInfo) {
                const initSubclassMethodType = initSubclassMethodInfo.type;
                if (initSubclassMethodType && initSubclassMethodInfo.classType) {
                    const callResult = validateCallArguments(errorNode, argList, { type: initSubclassMethodType }, 
                    /* typeVarContext */ undefined, 
                    /* skipUnknownArgCheck */ false, (0, typeUtils_1.makeInferenceContext)(getNoneType()), 
                    /* signatureTracker */ undefined);
                    if (callResult.argumentErrors) {
                        const diag = addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.initSubclassCallFailed(), node.name);
                        const initSubclassFunction = (0, types_1.isOverloadedFunction)(initSubclassMethodType)
                            ? types_1.OverloadedFunctionType.getOverloads(initSubclassMethodType)[0]
                            : initSubclassMethodType;
                        const initSubclassDecl = (0, types_1.isFunction)(initSubclassFunction)
                            ? initSubclassFunction.details.declaration
                            : undefined;
                        if (diag && initSubclassDecl) {
                            diag.addRelatedInfo(localize_1.LocAddendum.initSubclassLocation().format({
                                name: printType((0, typeUtils_1.convertToInstance)(initSubclassMethodInfo.classType)),
                            }), initSubclassDecl.uri, initSubclassDecl.range);
                        }
                    }
                }
            }
        }
        // Evaluate all of the expressions so they are checked and marked referenced.
        argList.forEach((arg) => {
            if (arg.valueExpression) {
                getTypeOfExpression(arg.valueExpression);
            }
        });
    }
    function getTypeOfFunction(node) {
        initializePrefetchedTypes(node);
        // Is this predecorated function type cached?
        let functionType = readTypeCache(node.name, 0 /* EvalFlags.None */);
        if (functionType) {
            if (!(0, types_1.isFunction)(functionType)) {
                // This can happen in certain rare circumstances where the
                // function declaration falls within an unreachable code block.
                return undefined;
            }
            if (types_1.FunctionType.isPartiallyEvaluated(functionType)) {
                return { functionType, decoratedType: functionType };
            }
        }
        else {
            functionType = getTypeOfFunctionPredecorated(node);
        }
        // Is the decorated function type cached?
        let decoratedType = readTypeCache(node, 0 /* EvalFlags.None */);
        if (decoratedType) {
            return { functionType, decoratedType };
        }
        // Populate the cache with a temporary value to handle recursion.
        writeTypeCache(node, { type: functionType }, /* flags */ undefined);
        // If it's an async function, wrap the return type in an Awaitable or Generator.
        // Set the "partially evaluated" flag around this logic to detect recursion.
        functionType.details.flags |= 131072 /* FunctionTypeFlags.PartiallyEvaluated */;
        const preDecoratedType = node.isAsync ? createAsyncFunction(node, functionType) : functionType;
        functionType.details.flags &= ~131072 /* FunctionTypeFlags.PartiallyEvaluated */;
        // Apply all of the decorators in reverse order.
        decoratedType = preDecoratedType;
        let foundUnknown = false;
        for (let i = node.decorators.length - 1; i >= 0; i--) {
            const decorator = node.decorators[i];
            const newDecoratedType = (0, decorators_1.applyFunctionDecorator)(evaluatorInterface, decoratedType, functionType, decorator, node);
            const unknownOrAny = (0, typeUtils_1.containsAnyOrUnknown)(newDecoratedType, /* recurse */ false);
            if (unknownOrAny && (0, types_1.isUnknown)(unknownOrAny)) {
                // Report this error only on the first unknown type.
                if (!foundUnknown) {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportUntypedFunctionDecorator, localize_1.LocMessage.functionDecoratorTypeUnknown(), node.decorators[i].expression);
                    foundUnknown = true;
                }
            }
            else {
                // Apply the decorator only if the type is known.
                decoratedType = newDecoratedType;
            }
        }
        // See if there are any overloads provided by previous function declarations.
        if ((0, types_1.isFunction)(decoratedType)) {
            decoratedType.details.deprecatedMessage = functionType.details.deprecatedMessage;
            if (types_1.FunctionType.isOverloaded(decoratedType)) {
                // Mark all the parameters as accessed.
                node.parameters.forEach((param) => {
                    markParamAccessed(param);
                });
            }
            decoratedType = (0, decorators_1.addOverloadsToFunctionType)(evaluatorInterface, node, decoratedType);
        }
        writeTypeCache(node, { type: decoratedType }, 0 /* EvalFlags.None */);
        return { functionType, decoratedType };
    }
    // Evaluates the type of a "def" statement without applying an async
    // modifier or any decorators.
    function getTypeOfFunctionPredecorated(node) {
        var _a;
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        // Is this type already cached?
        const cachedFunctionType = readTypeCache(node.name, 0 /* EvalFlags.None */);
        if (cachedFunctionType && (0, types_1.isFunction)(cachedFunctionType)) {
            return cachedFunctionType;
        }
        let functionDecl;
        const decl = AnalyzerNodeInfo.getDeclaration(node);
        if (decl) {
            functionDecl = decl;
        }
        // There was no cached type, so create a new one.
        // Retrieve the containing class node if the function is a method.
        const containingClassNode = ParseTreeUtils.getEnclosingClass(node, /* stopAtFunction */ true);
        let containingClassType;
        if (containingClassNode) {
            containingClassType = (_a = getTypeOfClass(containingClassNode)) === null || _a === void 0 ? void 0 : _a.classType;
        }
        const functionInfo = (0, decorators_1.getFunctionInfoFromDecorators)(evaluatorInterface, node, !!containingClassNode);
        let functionFlags = functionInfo.flags;
        if (functionDecl === null || functionDecl === void 0 ? void 0 : functionDecl.isGenerator) {
            functionFlags |= 16 /* FunctionTypeFlags.Generator */;
        }
        if (fileInfo.isStubFile) {
            functionFlags |= 2048 /* FunctionTypeFlags.StubDefinition */;
        }
        else if (fileInfo.isInPyTypedPackage) {
            functionFlags |= 4096 /* FunctionTypeFlags.PyTypedDefinition */;
        }
        if (node.isAsync) {
            functionFlags |= 512 /* FunctionTypeFlags.Async */;
        }
        const functionType = types_1.FunctionType.createInstance(node.name.value, getFunctionFullName(node, fileInfo.moduleName, node.name.value), fileInfo.moduleName, functionFlags | 131072 /* FunctionTypeFlags.PartiallyEvaluated */, ParseTreeUtils.getDocString(node.suite.statements));
        functionType.details.typeVarScopeId = ParseTreeUtils.getScopeIdForNode(node);
        functionType.details.deprecatedMessage = functionInfo.deprecationMessage;
        functionType.details.methodClass = containingClassType;
        if (node.name.value === '__init__' || node.name.value === '__new__') {
            if (containingClassNode) {
                functionType.details.constructorTypeVarScopeId = ParseTreeUtils.getScopeIdForNode(containingClassNode);
            }
        }
        if (fileInfo.isBuiltInStubFile || fileInfo.isTypingStubFile || fileInfo.isTypingExtensionsStubFile) {
            // Stash away the name of the function since we need to handle
            // 'namedtuple', 'abstractmethod', 'dataclass' and 'NewType'
            // specially.
            functionType.details.builtInName = node.name.value;
        }
        functionType.details.declaration = functionDecl;
        // Allow recursion by caching and registering the partially-constructed function type.
        const scope = ScopeUtils.getScopeForNode(node);
        const functionSymbol = scope === null || scope === void 0 ? void 0 : scope.lookUpSymbolRecursive(node.name.value);
        if (functionDecl && functionSymbol) {
            setSymbolResolutionPartialType(functionSymbol.symbol, functionDecl, functionType);
        }
        return (0, cancellationUtils_1.invalidateTypeCacheIfCanceled)(() => {
            var _a, _b;
            writeTypeCache(node.name, { type: functionType }, /* flags */ undefined);
            // Is this an "__init__" method within a pseudo-generic class? If so,
            // we'll add generic types to the constructor's parameters.
            const addGenericParamTypes = containingClassType &&
                types_1.ClassType.isPseudoGenericClass(containingClassType) &&
                node.name.value === '__init__';
            const paramTypes = [];
            // Determine if the first parameter should be skipped for comment-based
            // function annotations.
            let firstCommentAnnotationIndex = 0;
            if (containingClassType && (functionType.details.flags & 4 /* FunctionTypeFlags.StaticMethod */) === 0) {
                firstCommentAnnotationIndex = 1;
            }
            // If there is a function annotation comment, validate that it has the correct
            // number of parameter annotations.
            if (node.functionAnnotationComment && !node.functionAnnotationComment.isParamListEllipsis) {
                const expected = node.parameters.length - firstCommentAnnotationIndex;
                const received = node.functionAnnotationComment.paramTypeAnnotations.length;
                // For methods with "self" or "cls" parameters, the annotation list
                // can either include or exclude the annotation for the first parameter.
                if (firstCommentAnnotationIndex > 0 && received === node.parameters.length) {
                    firstCommentAnnotationIndex = 0;
                }
                else if (received !== expected) {
                    addError(localize_1.LocMessage.annotatedParamCountMismatch().format({
                        expected,
                        received,
                    }), node.functionAnnotationComment);
                }
            }
            // If this function uses PEP 695 syntax for type parameters,
            // accumulate the list of type parameters upfront.
            const typeParametersSeen = [];
            if (node.typeParameters) {
                functionType.details.typeParameters = evaluateTypeParameterList(node.typeParameters).map((typeParam) => (0, typeUtils_1.convertToInstance)(typeParam));
            }
            else {
                functionType.details.typeParameters = typeParametersSeen;
            }
            let paramsArePositionOnly = true;
            const isFirstParamClsOrSelf = containingClassType &&
                (types_1.FunctionType.isClassMethod(functionType) ||
                    types_1.FunctionType.isInstanceMethod(functionType) ||
                    types_1.FunctionType.isConstructorMethod(functionType));
            const firstNonClsSelfParamIndex = isFirstParamClsOrSelf ? 1 : 0;
            node.parameters.forEach((param, index) => {
                let paramType;
                let annotatedType;
                let paramTypeNode;
                if (param.name) {
                    if (index === 0 && isFirstParamClsOrSelf) {
                        // Mark "self/cls" as accessed.
                        markParamAccessed(param);
                    }
                    else if (types_1.FunctionType.isAbstractMethod(functionType)) {
                        // Mark all parameters in abstract methods as accessed.
                        markParamAccessed(param);
                    }
                    else if (containingClassType && types_1.ClassType.isProtocolClass(containingClassType)) {
                        // Mark all parameters in protocol methods as accessed.
                        markParamAccessed(param);
                    }
                }
                if (param.typeAnnotation) {
                    paramTypeNode = param.typeAnnotation;
                }
                else if (param.typeAnnotationComment) {
                    paramTypeNode = param.typeAnnotationComment;
                }
                else if (node.functionAnnotationComment && !node.functionAnnotationComment.isParamListEllipsis) {
                    const adjustedIndex = index - firstCommentAnnotationIndex;
                    if (adjustedIndex >= 0 &&
                        adjustedIndex < node.functionAnnotationComment.paramTypeAnnotations.length) {
                        paramTypeNode = node.functionAnnotationComment.paramTypeAnnotations[adjustedIndex];
                    }
                }
                if (paramTypeNode) {
                    if ((functionInfo.flags & 524288 /* FunctionTypeFlags.NoTypeCheck */) !== 0) {
                        annotatedType = types_1.UnknownType.create();
                    }
                    else {
                        annotatedType = getTypeOfParameterAnnotation(paramTypeNode, param.category);
                    }
                    if (annotatedType) {
                        (0, typeUtils_1.addTypeVarsToListIfUnique)(typeParametersSeen, (0, typeUtils_1.getTypeVarArgumentsRecursive)(annotatedType), functionType.details.typeVarScopeId);
                    }
                    if ((0, types_1.isVariadicTypeVar)(annotatedType) && !annotatedType.isVariadicUnpacked) {
                        addError(localize_1.LocMessage.unpackedTypeVarTupleExpected().format({
                            name1: annotatedType.details.name,
                            name2: annotatedType.details.name,
                        }), paramTypeNode);
                        annotatedType = types_1.UnknownType.create();
                    }
                }
                if (!annotatedType && addGenericParamTypes) {
                    if (index > 0 && param.category === 0 /* ParameterCategory.Simple */ && param.name && !param.defaultValue) {
                        const typeParamName = getPseudoGenericTypeVarName(param.name.value);
                        annotatedType = containingClassType.details.typeParameters.find((param) => param.details.name === typeParamName);
                    }
                }
                if (annotatedType) {
                    const adjustedAnnotatedType = adjustParameterAnnotatedType(param, annotatedType);
                    if (adjustedAnnotatedType !== annotatedType) {
                        annotatedType = adjustedAnnotatedType;
                    }
                }
                let defaultValueType;
                if (param.defaultValue) {
                    // If this is a stub file, a protocol, an overload, or a class
                    // whose body is a placeholder implementation, treat a "...", as
                    // an "Any" value.
                    let treatEllipsisAsAny = fileInfo.isStubFile || ParseTreeUtils.isSuiteEmpty(node.suite);
                    if (containingClassType && types_1.ClassType.isProtocolClass(containingClassType)) {
                        treatEllipsisAsAny = true;
                    }
                    if (types_1.FunctionType.isOverloaded(functionType) || types_1.FunctionType.isAbstractMethod(functionType)) {
                        treatEllipsisAsAny = true;
                    }
                    defaultValueType = getTypeOfExpression(param.defaultValue, treatEllipsisAsAny ? 1 /* EvalFlags.ConvertEllipsisToAny */ : 0 /* EvalFlags.None */, (0, typeUtils_1.makeInferenceContext)(annotatedType)).type;
                }
                if (annotatedType) {
                    // If there was both a type annotation and a default value, verify
                    // that the default value matches the annotation.
                    if (param.defaultValue && defaultValueType) {
                        const diagAddendum = new diagnostic_1.DiagnosticAddendum();
                        const typeVarContext = new typeVarContext_1.TypeVarContext(functionType.details.typeVarScopeId);
                        if (containingClassType && containingClassType.details.typeVarScopeId !== undefined) {
                            if (node.name.value === '__init__' || node.name.value === '__new__') {
                                typeVarContext.addSolveForScope(containingClassType.details.typeVarScopeId);
                            }
                        }
                        if (!assignType(annotatedType, defaultValueType, diagAddendum, typeVarContext)) {
                            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportArgumentType, localize_1.LocMessage.paramAssignmentMismatch().format({
                                sourceType: printType(defaultValueType),
                                paramType: printType(annotatedType),
                            }) + diagAddendum.getString(), param.defaultValue);
                        }
                    }
                    paramType = annotatedType;
                }
                // Determine whether we need to insert an implied position-only parameter.
                // This is needed when a function's parameters are named using the old-style
                // way of specifying position-only parameters.
                if (index >= firstNonClsSelfParamIndex) {
                    let isImplicitPositionOnlyParam = false;
                    if (param.category === 0 /* ParameterCategory.Simple */ && param.name) {
                        if ((0, symbolNameUtils_1.isPrivateName)(param.name.value) &&
                            !node.parameters.some((p) => p.category === 0 /* ParameterCategory.Simple */ && !p.name)) {
                            isImplicitPositionOnlyParam = true;
                            // If the parameter name indicates an implicit position-only parameter
                            // but we have already seen non-position-only parameters, report an error.
                            if (!paramsArePositionOnly &&
                                functionType.details.parameters.every((p) => p.category === 0 /* ParameterCategory.Simple */)) {
                                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.positionOnlyAfterNon(), param.name);
                            }
                        }
                    }
                    else {
                        paramsArePositionOnly = false;
                    }
                    if (paramsArePositionOnly &&
                        !isImplicitPositionOnlyParam &&
                        functionType.details.parameters.length > firstNonClsSelfParamIndex) {
                        types_1.FunctionType.addPositionOnlyParameterSeparator(functionType);
                    }
                    if (!isImplicitPositionOnlyParam) {
                        paramsArePositionOnly = false;
                    }
                }
                // If there was no annotation for the parameter, infer its type if possible.
                let isTypeInferred = false;
                if (!paramTypeNode) {
                    isTypeInferred = true;
                    const inferredType = inferParameterType(node, functionType.details.flags, index, containingClassType);
                    if (inferredType) {
                        paramType = inferredType;
                    }
                }
                const functionParam = {
                    category: param.category,
                    name: param.name ? param.name.value : undefined,
                    hasDefault: !!param.defaultValue,
                    defaultValueExpression: param.defaultValue,
                    defaultType: defaultValueType,
                    type: paramType !== null && paramType !== void 0 ? paramType : types_1.UnknownType.create(),
                    typeAnnotation: paramTypeNode,
                    hasDeclaredType: !!paramTypeNode,
                    isTypeInferred,
                };
                types_1.FunctionType.addParameter(functionType, functionParam);
                if (functionParam.hasDeclaredType) {
                    (0, typeUtils_1.addTypeVarsToListIfUnique)(typeParametersSeen, (0, typeUtils_1.getTypeVarArgumentsRecursive)(functionParam.type), functionType.details.typeVarScopeId);
                }
                if (param.name) {
                    const variadicParamType = transformVariadicParamType(node, param.category, functionParam.type);
                    paramTypes.push(variadicParamType);
                }
                else {
                    paramTypes.push(functionParam.type);
                }
            });
            if (paramsArePositionOnly && functionType.details.parameters.length > firstNonClsSelfParamIndex) {
                types_1.FunctionType.addPositionOnlyParameterSeparator(functionType);
            }
            // Update the types for the nodes associated with the parameters.
            paramTypes.forEach((paramType, index) => {
                const paramNameNode = node.parameters[index].name;
                if (paramNameNode) {
                    if ((0, types_1.isUnknown)(paramType)) {
                        functionType.details.flags |= 16384 /* FunctionTypeFlags.UnannotatedParams */;
                    }
                    writeTypeCache(paramNameNode, { type: paramType }, 0 /* EvalFlags.None */);
                }
            });
            // If the function ends in P.args and P.kwargs parameters, make it exempt from
            // args/kwargs compatibility checks. This is important for protocol comparisons.
            if (paramTypes.length >= 2) {
                const paramType1 = paramTypes[paramTypes.length - 2];
                const paramType2 = paramTypes[paramTypes.length - 1];
                if ((0, types_1.isParamSpec)(paramType1) &&
                    paramType1.paramSpecAccess === 'args' &&
                    (0, types_1.isParamSpec)(paramType2) &&
                    paramType2.paramSpecAccess === 'kwargs') {
                    functionType.details.flags |= 32768 /* FunctionTypeFlags.GradualCallableForm */;
                }
            }
            // If the function contains an *args and a **kwargs parameter and both
            // are annotated as Any or are unannotated, make it exempt from
            // args/kwargs compatibility checks.
            const variadicsWithAnyType = functionType.details.parameters.filter((param) => param.category !== 0 /* ParameterCategory.Simple */ && param.name && (0, types_1.isAnyOrUnknown)(param.type));
            if (variadicsWithAnyType.length >= 2) {
                functionType.details.flags |= 32768 /* FunctionTypeFlags.GradualCallableForm */;
            }
            // If there was a defined return type, analyze that first so when we
            // walk the contents of the function, return statements can be
            // validated against this type.
            const returnTypeAnnotationNode = (_a = node.returnTypeAnnotation) !== null && _a !== void 0 ? _a : (_b = node.functionAnnotationComment) === null || _b === void 0 ? void 0 : _b.returnTypeAnnotation;
            if (returnTypeAnnotationNode) {
                // Temporarily set the return type to unknown in case of recursion.
                functionType.details.declaredReturnType = types_1.UnknownType.create();
                const returnType = getTypeOfAnnotation(returnTypeAnnotationNode, {
                    associateTypeVarsWithScope: true,
                });
                functionType.details.declaredReturnType = returnType;
            }
            else {
                // If there was no return type annotation and this is a type stub,
                // we have no opportunity to infer the return type, so we'll indicate
                // that it's unknown.
                if (fileInfo.isStubFile) {
                    // Special-case the __init__ method, which is commonly left without
                    // an annotated return type, but we can assume it returns None.
                    if (node.name.value === '__init__') {
                        functionType.details.declaredReturnType = getNoneType();
                    }
                    else {
                        functionType.details.declaredReturnType = types_1.UnknownType.create();
                    }
                }
            }
            // Accumulate any type parameters used in the return type.
            if (functionType.details.declaredReturnType && returnTypeAnnotationNode) {
                (0, typeUtils_1.addTypeVarsToListIfUnique)(typeParametersSeen, (0, typeUtils_1.getTypeVarArgumentsRecursive)(functionType.details.declaredReturnType), functionType.details.typeVarScopeId);
            }
            // If the return type is explicitly annotated as a generator, mark the
            // function as a generator even though it may not contain a "yield" statement.
            // This is important for generator functions declared in stub files, abstract
            // methods or protocol definitions.
            if (fileInfo.isStubFile || ParseTreeUtils.isSuiteEmpty(node.suite)) {
                if (functionType.details.declaredReturnType &&
                    (0, types_1.isClassInstance)(functionType.details.declaredReturnType) &&
                    types_1.ClassType.isBuiltIn(functionType.details.declaredReturnType, [
                        'Generator',
                        'AsyncGenerator',
                        'AwaitableGenerator',
                    ])) {
                    functionType.details.flags |= 16 /* FunctionTypeFlags.Generator */;
                }
            }
            // Validate the default types for all type parameters.
            functionType.details.typeParameters.forEach((typeParam, index) => {
                var _a;
                let bestErrorNode = node.name;
                if (node.typeParameters && index < node.typeParameters.parameters.length) {
                    const typeParamNode = node.typeParameters.parameters[index];
                    bestErrorNode = (_a = typeParamNode.defaultExpression) !== null && _a !== void 0 ? _a : typeParamNode.name;
                }
                validateTypeParameterDefault(bestErrorNode, typeParam, functionType.details.typeParameters.slice(0, index), functionType.details.typeVarScopeId);
            });
            // Clear the "partially evaluated" flag to indicate that the functionType
            // is fully evaluated.
            functionType.details.flags &= ~131072 /* FunctionTypeFlags.PartiallyEvaluated */;
            writeTypeCache(node.name, { type: functionType }, 0 /* EvalFlags.None */);
            return functionType;
        });
    }
    function markParamAccessed(param) {
        if (param.name) {
            const symbolWithScope = lookUpSymbolRecursive(param.name, param.name.value, /* honorCodeFlow */ false);
            if (symbolWithScope) {
                setSymbolAccessed(AnalyzerNodeInfo.getFileInfo(param), symbolWithScope.symbol, param.name);
            }
        }
    }
    function adjustParameterAnnotatedType(param, type) {
        var _a;
        // PEP 484 indicates that if a parameter has a default value of 'None'
        // the type checker should assume that the type is optional (i.e. a union
        // of the specified type and 'None'). Skip this step if the type is already
        // optional to avoid losing alias names when combining the types.
        if (((_a = param.defaultValue) === null || _a === void 0 ? void 0 : _a.nodeType) === 14 /* ParseNodeType.Constant */ &&
            param.defaultValue.constType === 26 /* KeywordType.None */ &&
            !(0, typeUtils_1.isOptionalType)(type) &&
            !AnalyzerNodeInfo.getFileInfo(param).diagnosticRuleSet.strictParameterNoneValue) {
            return (0, types_1.combineTypes)([type, getNoneType()]);
        }
        return type;
    }
    // Attempts to infer an unannotated parameter type from available context.
    function inferParameterType(functionNode, functionFlags, paramIndex, containingClassType) {
        var _a;
        // Is the function a method within a class? If so, see if a base class
        // defines the same method and provides annotations.
        if (containingClassType) {
            if (paramIndex === 0) {
                if ((functionFlags & 4 /* FunctionTypeFlags.StaticMethod */) === 0) {
                    const hasClsParam = (functionFlags & (2 /* FunctionTypeFlags.ClassMethod */ | 1 /* FunctionTypeFlags.ConstructorMethod */)) !== 0;
                    return (0, typeUtils_1.synthesizeTypeVarForSelfCls)(containingClassType, hasClsParam);
                }
            }
            const methodName = functionNode.name.value;
            const baseClassMemberInfo = (0, typeUtils_1.lookUpClassMember)(containingClassType, methodName, 1 /* MemberAccessFlags.SkipOriginalClass */);
            if (baseClassMemberInfo) {
                const memberDecls = baseClassMemberInfo.symbol.getDeclarations();
                if (memberDecls.length === 1 && memberDecls[0].type === 5 /* DeclarationType.Function */) {
                    const baseClassMethodNode = memberDecls[0].node;
                    // Does the signature match exactly with the exception of annotations?
                    if (baseClassMethodNode.parameters.length === functionNode.parameters.length &&
                        baseClassMethodNode.parameters.every((param, index) => {
                            var _a, _b;
                            const overrideParam = functionNode.parameters[index];
                            return (((_a = overrideParam.name) === null || _a === void 0 ? void 0 : _a.value) === ((_b = param.name) === null || _b === void 0 ? void 0 : _b.value) &&
                                overrideParam.category === param.category);
                        })) {
                        const baseClassParam = baseClassMethodNode.parameters[paramIndex];
                        const baseClassParamAnnotation = (_a = baseClassParam.typeAnnotation) !== null && _a !== void 0 ? _a : baseClassParam.typeAnnotationComment;
                        if (baseClassParamAnnotation) {
                            let inferredParamType = getTypeOfParameterAnnotation(baseClassParamAnnotation, functionNode.parameters[paramIndex].category);
                            // If the parameter type is generic, specialize it in the context
                            // of the child class.
                            if ((0, typeUtils_1.requiresSpecialization)(inferredParamType) && (0, types_1.isClass)(baseClassMemberInfo.classType)) {
                                const typeVarContext = (0, typeUtils_1.buildTypeVarContextFromSpecializedClass)(baseClassMemberInfo.classType);
                                // Add the scope of the method to handle any function-scoped TypeVars.
                                typeVarContext.addSolveForScope(ParseTreeUtils.getScopeIdForNode(baseClassMethodNode));
                                // Replace any unsolved TypeVars with Unknown (including all function-scoped TypeVars).
                                inferredParamType = (0, typeUtils_1.applySolvedTypeVars)(inferredParamType, typeVarContext, {
                                    unknownIfNotFound: true,
                                    tupleClassType: getTupleClassType(),
                                });
                            }
                            const fileInfo = AnalyzerNodeInfo.getFileInfo(functionNode);
                            if (fileInfo.isInPyTypedPackage && !fileInfo.isStubFile) {
                                inferredParamType = types_1.TypeBase.cloneForAmbiguousType(inferredParamType);
                            }
                            return inferredParamType;
                        }
                    }
                }
            }
        }
        // If the parameter has a default argument value, we may be able to infer its
        // type from this information.
        const paramValueExpr = functionNode.parameters[paramIndex].defaultValue;
        if (paramValueExpr) {
            return inferParameterTypeFromDefaultValue(paramValueExpr);
        }
        return undefined;
    }
    function inferParameterTypeFromDefaultValue(paramValueExpr) {
        const defaultValueType = getTypeOfExpression(paramValueExpr, 1 /* EvalFlags.ConvertEllipsisToAny */).type;
        let inferredParamType;
        // Is the default value a "None" or an instance of some private class (one
        // whose name starts with an underscore)? If so, we will assume that the
        // value is a singleton sentinel. The actual supported type is going to be
        // a union of this type and Unknown.
        if ((0, typeUtils_1.isNoneInstance)(defaultValueType) ||
            ((0, types_1.isClassInstance)(defaultValueType) && (0, symbolNameUtils_1.isPrivateOrProtectedName)(defaultValueType.details.name))) {
            inferredParamType = (0, types_1.combineTypes)([defaultValueType, types_1.UnknownType.create()]);
        }
        else {
            let skipInference = false;
            if ((0, types_1.isFunction)(defaultValueType) || (0, types_1.isOverloadedFunction)(defaultValueType)) {
                // Do not infer parameter types that use a lambda or another function as a
                // default value. We're likely to generate false positives in this case.
                // It's not clear whether parameters should be positional-only or not.
                skipInference = true;
            }
            else if ((0, types_1.isClassInstance)(defaultValueType) &&
                types_1.ClassType.isBuiltIn(defaultValueType, ['tuple', 'list', 'set', 'dict'])) {
                // Do not infer certain types like tuple because it's likely to be
                // more restrictive (narrower) than intended.
                skipInference = true;
            }
            if (!skipInference) {
                inferredParamType = stripLiteralValue(defaultValueType);
            }
        }
        if (inferredParamType) {
            const fileInfo = AnalyzerNodeInfo.getFileInfo(paramValueExpr);
            if (fileInfo.isInPyTypedPackage && !fileInfo.isStubFile) {
                inferredParamType = types_1.TypeBase.cloneForAmbiguousType(inferredParamType);
            }
        }
        return inferredParamType;
    }
    // Transforms the parameter type based on its category. If it's a simple parameter,
    // no transform is applied. If it's a var-arg or keyword-arg parameter, the type
    // is wrapped in a List or Dict.
    function transformVariadicParamType(node, paramCategory, type) {
        switch (paramCategory) {
            case 0 /* ParameterCategory.Simple */: {
                return type;
            }
            case 1 /* ParameterCategory.ArgsList */: {
                if ((0, types_1.isTypeVar)(type) && type.paramSpecAccess) {
                    return type;
                }
                if ((0, types_1.isUnpackedClass)(type)) {
                    return types_1.ClassType.cloneForUnpacked(type, /* isUnpackedTuple */ false);
                }
                return makeTupleObject([{ type, isUnbounded: !(0, types_1.isVariadicTypeVar)(type) }]);
            }
            case 2 /* ParameterCategory.KwargsDict */: {
                // Leave a ParamSpec alone.
                if ((0, types_1.isTypeVar)(type) && type.paramSpecAccess) {
                    return type;
                }
                // Is this an unpacked TypedDict? If so, return it unmodified.
                if ((0, types_1.isClassInstance)(type) && types_1.ClassType.isTypedDictClass(type) && type.isUnpacked) {
                    return type;
                }
                // Wrap the type in a dict with str keys.
                const dictType = getBuiltInType(node, 'dict');
                const strType = getBuiltInObject(node, 'str');
                if ((0, types_1.isInstantiableClass)(dictType) && (0, types_1.isClassInstance)(strType)) {
                    return types_1.ClassType.cloneAsInstance(types_1.ClassType.cloneForSpecialization(dictType, [strType, type], /* isTypeArgumentExplicit */ true));
                }
                return types_1.UnknownType.create();
            }
        }
    }
    function createAsyncFunction(node, functionType) {
        (0, debug_1.assert)(types_1.FunctionType.isAsync(functionType));
        // Clone the original function and replace its return type with an
        // Awaitable[<returnType>]. Mark the new function as no longer async.
        const awaitableFunctionType = types_1.FunctionType.cloneWithNewFlags(functionType, functionType.details.flags & ~(512 /* FunctionTypeFlags.Async */ | 131072 /* FunctionTypeFlags.PartiallyEvaluated */));
        if (functionType.details.declaredReturnType) {
            awaitableFunctionType.details.declaredReturnType = createAwaitableReturnType(node, functionType.details.declaredReturnType, types_1.FunctionType.isGenerator(functionType));
        }
        else {
            awaitableFunctionType.inferredReturnType = createAwaitableReturnType(node, getFunctionInferredReturnType(functionType), types_1.FunctionType.isGenerator(functionType));
        }
        return awaitableFunctionType;
    }
    function createAwaitableReturnType(node, returnType, isGenerator, useCoroutine = true) {
        let awaitableReturnType;
        if ((0, types_1.isClassInstance)(returnType)) {
            if (types_1.ClassType.isBuiltIn(returnType)) {
                if (returnType.details.name === 'Generator') {
                    // If the return type is a Generator, change it to an AsyncGenerator.
                    const asyncGeneratorType = getTypingType(node, 'AsyncGenerator');
                    if (asyncGeneratorType && (0, types_1.isInstantiableClass)(asyncGeneratorType)) {
                        const typeArgs = [];
                        const generatorTypeArgs = returnType.typeArguments;
                        if (generatorTypeArgs && generatorTypeArgs.length > 0) {
                            typeArgs.push(generatorTypeArgs[0]);
                        }
                        if (generatorTypeArgs && generatorTypeArgs.length > 1) {
                            typeArgs.push(generatorTypeArgs[1]);
                        }
                        awaitableReturnType = types_1.ClassType.cloneAsInstance(types_1.ClassType.cloneForSpecialization(asyncGeneratorType, typeArgs, 
                        /* isTypeArgumentExplicit */ true));
                    }
                }
                else if (['AsyncGenerator', 'AsyncIterator', 'AsyncIterable'].some((name) => name === returnType.details.name)) {
                    // If it's already an AsyncGenerator, AsyncIterator or AsyncIterable,
                    // leave it as is.
                    awaitableReturnType = returnType;
                }
            }
        }
        if (!awaitableReturnType || !isGenerator) {
            // Wrap in either an Awaitable or a Coroutine, which is a subclass of Awaitable.
            const awaitableType = getTypingType(node, useCoroutine ? 'Coroutine' : 'Awaitable');
            if (awaitableType && (0, types_1.isInstantiableClass)(awaitableType)) {
                awaitableReturnType = types_1.ClassType.cloneAsInstance(types_1.ClassType.cloneForSpecialization(awaitableType, useCoroutine ? [types_1.AnyType.create(), types_1.AnyType.create(), returnType] : [returnType], 
                /* isTypeArgumentExplicit */ true));
            }
            else {
                awaitableReturnType = types_1.UnknownType.create();
            }
        }
        return awaitableReturnType;
    }
    function inferFunctionReturnType(node, isAbstract) {
        var _a;
        const returnAnnotation = node.returnTypeAnnotation || ((_a = node.functionAnnotationComment) === null || _a === void 0 ? void 0 : _a.returnTypeAnnotation);
        // This shouldn't be called if there is a declared return type, but it
        // can happen if there are unexpected cycles between decorators and
        // classes that they decorate. We'll just return an undefined type
        // in this case.
        if (returnAnnotation) {
            return undefined;
        }
        // Is this type already cached?
        let inferredReturnType = readTypeCache(node.suite, 0 /* EvalFlags.None */);
        let isIncomplete = false;
        if (inferredReturnType) {
            return { type: inferredReturnType, isIncomplete };
        }
        if (functionRecursionMap.has(node.id) || functionRecursionMap.size >= maxInferFunctionReturnRecursionCount) {
            inferredReturnType = types_1.UnknownType.create();
            isIncomplete = true;
        }
        else {
            functionRecursionMap.add(node.id);
            try {
                let functionDecl;
                const decl = AnalyzerNodeInfo.getDeclaration(node);
                if (decl) {
                    functionDecl = decl;
                }
                const functionNeverReturns = !isAfterNodeReachable(node);
                const implicitlyReturnsNone = isAfterNodeReachable(node.suite);
                // Infer the return type based on all of the return statements in the function's body.
                if (AnalyzerNodeInfo.getFileInfo(node).isStubFile) {
                    // If a return type annotation is missing in a stub file, assume
                    // it's an "unknown" type. In normal source files, we can infer the
                    // type from the implementation.
                    inferredReturnType = types_1.UnknownType.create();
                }
                else {
                    if (functionNeverReturns) {
                        // If the function always raises and never returns, assume a "NoReturn" type.
                        // Skip this for abstract methods which often are implemented with "raise
                        // NotImplementedError()".
                        if (isAbstract || methodAlwaysRaisesNotImplemented(functionDecl)) {
                            inferredReturnType = types_1.UnknownType.create();
                        }
                        else {
                            inferredReturnType = types_1.NeverType.createNoReturn();
                        }
                    }
                    else {
                        const inferredReturnTypes = [];
                        if (functionDecl === null || functionDecl === void 0 ? void 0 : functionDecl.returnStatements) {
                            functionDecl.returnStatements.forEach((returnNode) => {
                                if (isNodeReachable(returnNode)) {
                                    if (returnNode.returnExpression) {
                                        const returnTypeResult = getTypeOfExpression(returnNode.returnExpression);
                                        if (returnTypeResult.isIncomplete) {
                                            isIncomplete = true;
                                        }
                                        let returnType = returnTypeResult.type;
                                        // If the type is a special form, use the special form instead.
                                        if (returnType.specialForm) {
                                            returnType = returnType.specialForm;
                                        }
                                        // If the return type includes an instance of a class with isEmptyContainer
                                        // set, clear that because we don't want this flag to "leak" into the
                                        // inferred return type.
                                        returnType = (0, typeUtils_1.mapSubtypes)(returnType, (subtype) => {
                                            if ((0, types_1.isClassInstance)(subtype) && subtype.isEmptyContainer) {
                                                return types_1.ClassType.cloneForSpecialization(subtype, subtype.typeArguments, !!subtype.isTypeArgumentExplicit, subtype.includeSubclasses, subtype.tupleTypeArguments, 
                                                /* isEmptyContainer */ false);
                                            }
                                            return subtype;
                                        });
                                        inferredReturnTypes.push(returnType);
                                    }
                                    else {
                                        inferredReturnTypes.push(getNoneType());
                                    }
                                }
                            });
                        }
                        if (!functionNeverReturns && implicitlyReturnsNone) {
                            inferredReturnTypes.push(getNoneType());
                        }
                        inferredReturnType = (0, types_1.combineTypes)(inferredReturnTypes);
                        // Remove any unbound values since those would generate an exception
                        // before being returned.
                        inferredReturnType = (0, types_1.removeUnbound)(inferredReturnType);
                    }
                    // Is it a generator?
                    if (functionDecl === null || functionDecl === void 0 ? void 0 : functionDecl.isGenerator) {
                        const inferredYieldTypes = [];
                        let useAwaitableGenerator = false;
                        let isYieldResultUsed = false;
                        if (functionDecl.yieldStatements) {
                            functionDecl.yieldStatements.forEach((yieldNode) => {
                                var _a, _b;
                                if (isNodeReachable(yieldNode)) {
                                    if (yieldNode.nodeType === 61 /* ParseNodeType.YieldFrom */) {
                                        isYieldResultUsed = true;
                                        const iteratorTypeResult = getTypeOfExpression(yieldNode.expression);
                                        if ((0, types_1.isClassInstance)(iteratorTypeResult.type) &&
                                            types_1.ClassType.isBuiltIn(iteratorTypeResult.type, 'Coroutine')) {
                                            const yieldType = iteratorTypeResult.type.typeArguments &&
                                                iteratorTypeResult.type.typeArguments.length > 0
                                                ? iteratorTypeResult.type.typeArguments[0]
                                                : types_1.UnknownType.create();
                                            // Handle old-style (pre-await) Coroutines.
                                            inferredYieldTypes.push(yieldType);
                                            useAwaitableGenerator = true;
                                        }
                                        else {
                                            const yieldType = (_a = getTypeOfIterator(iteratorTypeResult, 
                                            /* isAsync */ false, yieldNode)) === null || _a === void 0 ? void 0 : _a.type;
                                            inferredYieldTypes.push(yieldType !== null && yieldType !== void 0 ? yieldType : types_1.UnknownType.create());
                                        }
                                    }
                                    else {
                                        // If the yield expression is not by itself in a statement list,
                                        // assume that its result is consumed.
                                        if (((_b = yieldNode === null || yieldNode === void 0 ? void 0 : yieldNode.parent) === null || _b === void 0 ? void 0 : _b.nodeType) !== 47 /* ParseNodeType.StatementList */) {
                                            isYieldResultUsed = true;
                                        }
                                        if (yieldNode.expression) {
                                            const yieldType = getTypeOfExpression(yieldNode.expression).type;
                                            inferredYieldTypes.push(yieldType !== null && yieldType !== void 0 ? yieldType : types_1.UnknownType.create());
                                        }
                                        else {
                                            inferredYieldTypes.push(getNoneType());
                                        }
                                    }
                                }
                            });
                        }
                        const inferredYieldType = (0, types_1.combineTypes)(inferredYieldTypes);
                        // Inferred yield types need to be wrapped in a Generator or
                        // AwaitableGenerator to produce the final result.
                        const generatorType = getTypingType(node, useAwaitableGenerator ? 'AwaitableGenerator' : 'Generator');
                        if (generatorType && (0, types_1.isInstantiableClass)(generatorType)) {
                            const typeArgs = [];
                            // The "send type" for the generator (the second type argument) is
                            // not generally inferrable, but we can assume that it's Any
                            // if the function never uses the value and Unknown if it does.
                            // This eliminates any "partially unknown" errors in strict mode
                            // in the common case.
                            const sendType = isYieldResultUsed ? types_1.UnknownType.create() : types_1.AnyType.create();
                            typeArgs.push(inferredYieldType, sendType, inferredReturnType);
                            if (useAwaitableGenerator) {
                                typeArgs.push(types_1.AnyType.create());
                            }
                            inferredReturnType = types_1.ClassType.cloneAsInstance(types_1.ClassType.cloneForSpecialization(generatorType, typeArgs, 
                            /* isTypeArgumentExplicit */ true));
                        }
                        else {
                            inferredReturnType = types_1.UnknownType.create();
                        }
                    }
                }
                writeTypeCache(node.suite, { type: inferredReturnType, isIncomplete }, 0 /* EvalFlags.None */);
            }
            finally {
                functionRecursionMap.delete(node.id);
            }
        }
        return inferredReturnType ? { type: inferredReturnType, isIncomplete } : undefined;
    }
    // Determines whether the method consists only of a "raise" statement
    // and the exception type raised is a NotImplementedError or a subclass
    // thereof. This is commonly used for abstract methods.
    function methodAlwaysRaisesNotImplemented(functionDecl) {
        if (!functionDecl ||
            !functionDecl.isMethod ||
            functionDecl.returnStatements ||
            functionDecl.yieldStatements ||
            !functionDecl.raiseStatements) {
            return false;
        }
        const statements = functionDecl.node.suite.statements;
        if (statements.some((statement) => statement.nodeType !== 47 /* ParseNodeType.StatementList */)) {
            return false;
        }
        for (const raiseStatement of functionDecl.raiseStatements) {
            if (!raiseStatement.typeExpression || raiseStatement.valueExpression) {
                return false;
            }
            const raiseType = getTypeOfExpression(raiseStatement.typeExpression).type;
            const classType = (0, types_1.isInstantiableClass)(raiseType)
                ? raiseType
                : (0, types_1.isClassInstance)(raiseType)
                    ? raiseType
                    : undefined;
            if (!classType || !(0, typeUtils_1.derivesFromStdlibClass)(classType, 'NotImplementedError')) {
                return false;
            }
        }
        return true;
    }
    function evaluateTypesForForStatement(node) {
        var _a, _b;
        if (isTypeCached(node)) {
            return;
        }
        const iteratorTypeResult = getTypeOfExpression(node.iterableExpression);
        const iteratedType = (_b = (_a = getTypeOfIterator(iteratorTypeResult, !!node.isAsync, node.iterableExpression)) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : types_1.UnknownType.create();
        assignTypeToExpression(node.targetExpression, { type: iteratedType, isIncomplete: iteratorTypeResult.isIncomplete }, node.targetExpression);
        writeTypeCache(node, { type: iteratedType, isIncomplete: !!iteratorTypeResult.isIncomplete }, 0 /* EvalFlags.None */);
    }
    function evaluateTypesForExceptStatement(node) {
        // This should be called only if the except node has a target exception.
        (0, debug_1.assert)(node.typeExpression !== undefined);
        if (isTypeCached(node)) {
            return;
        }
        const exceptionTypeResult = getTypeOfExpression(node.typeExpression);
        const exceptionTypes = exceptionTypeResult.type;
        function getExceptionType(exceptionType, errorNode) {
            var _a, _b;
            exceptionType = makeTopLevelTypeVarsConcrete(exceptionType);
            if ((0, types_1.isAnyOrUnknown)(exceptionType)) {
                return exceptionType;
            }
            if ((0, types_1.isInstantiableClass)(exceptionType)) {
                return types_1.ClassType.cloneAsInstance(exceptionType);
            }
            if ((0, types_1.isClassInstance)(exceptionType)) {
                const iterableType = (_b = (_a = getTypeOfIterator({ type: exceptionType, isIncomplete: exceptionTypeResult.isIncomplete }, 
                /* isAsync */ false, errorNode)) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : types_1.UnknownType.create();
                return (0, typeUtils_1.mapSubtypes)(iterableType, (subtype) => {
                    if ((0, types_1.isAnyOrUnknown)(subtype)) {
                        return subtype;
                    }
                    return types_1.UnknownType.create();
                });
            }
            return types_1.UnknownType.create();
        }
        let targetType = (0, typeUtils_1.mapSubtypes)(exceptionTypes, (subType) => {
            // If more than one type was specified for the exception, we'll receive
            // a specialized tuple object here.
            const tupleType = (0, typeUtils_1.getSpecializedTupleType)(subType);
            if (tupleType && tupleType.tupleTypeArguments) {
                const entryTypes = tupleType.tupleTypeArguments.map((t) => {
                    return getExceptionType(t.type, node.typeExpression);
                });
                return (0, types_1.combineTypes)(entryTypes);
            }
            return getExceptionType(subType, node.typeExpression);
        });
        // If this is an except group, wrap the exception type in an BaseExceptionGroup.
        if (node.isExceptGroup) {
            targetType = getBuiltInObject(node, 'BaseExceptionGroup', [targetType]);
        }
        if (node.name) {
            assignTypeToExpression(node.name, { type: targetType }, node.name);
        }
        writeTypeCache(node, { type: targetType }, 0 /* EvalFlags.None */);
    }
    function evaluateTypesForWithStatement(node) {
        if (isTypeCached(node)) {
            return;
        }
        const exprTypeResult = getTypeOfExpression(node.expression);
        let exprType = exprTypeResult.type;
        const isAsync = node.parent && node.parent.nodeType === 58 /* ParseNodeType.With */ && !!node.parent.isAsync;
        if ((0, typeUtils_1.isOptionalType)(exprType)) {
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportOptionalContextManager, localize_1.LocMessage.noneNotUsableWith(), node.expression);
            exprType = (0, typeUtils_1.removeNoneFromUnion)(exprType);
        }
        // Verify that the target has an __enter__ or __aenter__ method defined.
        const enterMethodName = isAsync ? '__aenter__' : '__enter__';
        const scopedType = (0, typeUtils_1.mapSubtypes)(exprType, (subtype) => {
            subtype = makeTopLevelTypeVarsConcrete(subtype);
            if ((0, types_1.isAnyOrUnknown)(subtype)) {
                return subtype;
            }
            const additionalHelp = new diagnostic_1.DiagnosticAddendum();
            if ((0, types_1.isClass)(subtype)) {
                let enterType = getTypeOfMagicMethodCall(subtype, enterMethodName, [], node.expression, 
                /* inferenceContext */ undefined, additionalHelp.createAddendum());
                if (enterType) {
                    // For "async while", an implicit "await" is performed.
                    if (isAsync) {
                        enterType = getTypeOfAwaitable(enterType, node.expression);
                    }
                    return enterType;
                }
                if (!isAsync) {
                    if (getTypeOfMagicMethodCall(subtype, '__aenter__', [], node.expression, 
                    /* inferenceContext */ undefined)) {
                        additionalHelp.addMessage(localize_1.LocAddendum.asyncHelp());
                    }
                }
            }
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeNotUsableWith().format({ type: printType(subtype), method: enterMethodName }) +
                additionalHelp.getString(), node.expression);
            return types_1.UnknownType.create();
        });
        // Verify that the target has an __exit__ or __aexit__ method defined.
        const exitMethodName = isAsync ? '__aexit__' : '__exit__';
        (0, typeUtils_1.doForEachSubtype)(exprType, (subtype) => {
            subtype = makeTopLevelTypeVarsConcrete(subtype);
            if ((0, types_1.isAnyOrUnknown)(subtype)) {
                return;
            }
            if ((0, types_1.isClass)(subtype)) {
                const anyArg = { type: types_1.AnyType.create() };
                const exitType = getTypeOfMagicMethodCall(subtype, exitMethodName, [anyArg, anyArg, anyArg], node.expression, 
                /* inferenceContext */ undefined);
                if (exitType) {
                    return;
                }
            }
            addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeNotUsableWith().format({ type: printType(subtype), method: exitMethodName }), node.expression);
        });
        if (node.target) {
            assignTypeToExpression(node.target, { type: scopedType, isIncomplete: exprTypeResult.isIncomplete }, node.target);
        }
        writeTypeCache(node, { type: scopedType, isIncomplete: !!exprTypeResult.isIncomplete }, 0 /* EvalFlags.None */);
    }
    function evaluateTypesForImportAs(node) {
        var _a;
        if (isTypeCached(node)) {
            return;
        }
        let symbolNameNode;
        if (node.alias) {
            // The symbol name is defined by the alias.
            symbolNameNode = node.alias;
        }
        else {
            // There was no alias, so we need to use the first element of
            // the name parts as the symbol.
            symbolNameNode = node.module.nameParts[0];
        }
        if (!symbolNameNode) {
            // This can happen in certain cases where there are parse errors.
            return;
        }
        // Look up the symbol to find the alias declaration.
        let symbolType = (_a = getAliasedSymbolTypeForName(node, symbolNameNode.value)) !== null && _a !== void 0 ? _a : types_1.UnknownType.create();
        // Is there a cached module type associated with this node? If so, use
        // it instead of the type we just created.
        const cachedModuleType = readTypeCache(node, 0 /* EvalFlags.None */);
        if (cachedModuleType && (0, types_1.isModule)(cachedModuleType) && symbolType) {
            if ((0, types_1.isTypeSame)(symbolType, cachedModuleType)) {
                symbolType = cachedModuleType;
            }
        }
        assignTypeToNameNode(symbolNameNode, { type: symbolType }, /* ignoreEmptyContainers */ false);
        writeTypeCache(node, { type: symbolType }, 0 /* EvalFlags.None */);
    }
    function evaluateTypesForImportFromAs(node) {
        var _a;
        if (isTypeCached(node)) {
            return;
        }
        const aliasNode = node.alias || node.name;
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        // If this is a redundant form of an import, assume it is an intentional
        // export and mark the symbol as accessed.
        if (((_a = node.alias) === null || _a === void 0 ? void 0 : _a.value) === node.name.value) {
            const symbolInScope = lookUpSymbolRecursive(node, node.name.value, /* honorCodeFlow */ true);
            if (symbolInScope) {
                setSymbolAccessed(fileInfo, symbolInScope.symbol, node);
            }
        }
        // If this is an import into a class scope, mark the symbol as accessed.
        const classNode = ParseTreeUtils.getEnclosingClass(node, /* stopAtFunction */ true);
        if (classNode) {
            const symbolInScope = lookUpSymbolRecursive(node, aliasNode.value, /* honorCodeFlow */ true);
            if (symbolInScope) {
                setSymbolAccessed(fileInfo, symbolInScope.symbol, node);
            }
        }
        let symbolType = getAliasedSymbolTypeForName(node, aliasNode.value);
        if (!symbolType) {
            const parentNode = node.parent;
            (0, debug_1.assert)(parentNode && parentNode.nodeType === 25 /* ParseNodeType.ImportFrom */);
            (0, debug_1.assert)(!parentNode.isWildcardImport);
            const importInfo = AnalyzerNodeInfo.getImportInfo(parentNode.module);
            if (importInfo && importInfo.isImportFound && !importInfo.isNativeLib) {
                const resolvedPath = importInfo.resolvedUris[importInfo.resolvedUris.length - 1];
                const importLookupInfo = importLookup(resolvedPath);
                let reportError = false;
                // If we were able to resolve the import, report the error as
                // an unresolved symbol.
                if (importLookupInfo) {
                    reportError = true;
                    // Handle PEP 562 support for module-level __getattr__ function,
                    // introduced in Python 3.7.
                    if (fileInfo.executionEnvironment.pythonVersion.isGreaterOrEqualTo(pythonVersion_1.pythonVersion3_7) ||
                        fileInfo.isStubFile) {
                        const getAttrSymbol = importLookupInfo.symbolTable.get('__getattr__');
                        if (getAttrSymbol) {
                            const getAttrType = getEffectiveTypeOfSymbol(getAttrSymbol);
                            if ((0, types_1.isFunction)(getAttrType)) {
                                symbolType = getFunctionEffectiveReturnType(getAttrType);
                                reportError = false;
                            }
                        }
                    }
                }
                else if (resolvedPath.isEmpty()) {
                    // This corresponds to the "from . import a" form.
                    reportError = true;
                }
                if (reportError) {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportAttributeAccessIssue, localize_1.LocMessage.importSymbolUnknown().format({ name: node.name.value }), node.name);
                }
            }
            if (!symbolType) {
                symbolType = types_1.UnknownType.create();
            }
        }
        assignTypeToNameNode(aliasNode, { type: symbolType }, /* ignoreEmptyContainers */ false);
        writeTypeCache(node, { type: symbolType }, 0 /* EvalFlags.None */);
    }
    function evaluateTypesForMatchStatement(node) {
        if (isTypeCached(node)) {
            return;
        }
        const subjectTypeResult = getTypeOfExpression(node.subjectExpression);
        let subjectType = subjectTypeResult.type;
        // Apply negative narrowing for each of the cases that doesn't have a guard statement.
        for (const caseStatement of node.cases) {
            if (!caseStatement.guardExpression) {
                subjectType = (0, patternMatching_1.narrowTypeBasedOnPattern)(evaluatorInterface, subjectType, caseStatement.pattern, 
                /* isPositiveTest */ false);
            }
        }
        writeTypeCache(node, { type: subjectType, isIncomplete: !!subjectTypeResult.isIncomplete }, 0 /* EvalFlags.None */);
    }
    function evaluateTypesForCaseStatement(node) {
        if (isTypeCached(node)) {
            return;
        }
        if (!node.parent || node.parent.nodeType !== 63 /* ParseNodeType.Match */) {
            (0, debug_1.fail)('Expected parent of case statement to be match statement');
            return;
        }
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        const subjectTypeResult = getTypeOfExpression(node.parent.subjectExpression);
        let subjectType = subjectTypeResult.type;
        // Apply negative narrowing for each of the cases prior to the current one
        // except for those that have a guard expression.
        for (const caseStatement of node.parent.cases) {
            if (caseStatement === node) {
                if (fileInfo.diagnosticRuleSet.reportUnnecessaryComparison !== 'none') {
                    if (!subjectTypeResult.isIncomplete) {
                        (0, patternMatching_1.checkForUnusedPattern)(evaluatorInterface, node.pattern, subjectType);
                    }
                }
                break;
            }
            if (!caseStatement.guardExpression) {
                subjectType = (0, patternMatching_1.narrowTypeBasedOnPattern)(evaluatorInterface, subjectType, caseStatement.pattern, 
                /* isPositiveTest */ false);
            }
        }
        const narrowedSubjectType = (0, patternMatching_1.assignTypeToPatternTargets)(evaluatorInterface, subjectType, !!subjectTypeResult.isIncomplete, node.pattern);
        writeTypeCache(node, { type: narrowedSubjectType, isIncomplete: !!subjectTypeResult.isIncomplete }, 0 /* EvalFlags.None */);
    }
    function evaluateTypesForImportFrom(node) {
        if (isTypeCached(node)) {
            return;
        }
        if (node.isWildcardImport) {
            // Write back a dummy type so we don't evaluate this node again.
            writeTypeCache(node, { type: types_1.AnyType.create() }, 0 /* EvalFlags.None */);
            const flowNode = AnalyzerNodeInfo.getFlowNode(node);
            if (flowNode && (flowNode.flags & codeFlowTypes_1.FlowFlags.WildcardImport) !== 0) {
                const wildcardFlowNode = flowNode;
                wildcardFlowNode.names.forEach((name) => {
                    var _a, _b;
                    const importedSymbolType = getAliasedSymbolTypeForName(node, name);
                    if (!importedSymbolType) {
                        return;
                    }
                    const symbolWithScope = lookUpSymbolRecursive(node, name, /* honorCodeFlow */ false);
                    if (!symbolWithScope) {
                        return;
                    }
                    const declaredType = (_a = getDeclaredTypeOfSymbol(symbolWithScope.symbol)) === null || _a === void 0 ? void 0 : _a.type;
                    if (!declaredType) {
                        return;
                    }
                    const diagAddendum = new diagnostic_1.DiagnosticAddendum();
                    if (!assignType(declaredType, importedSymbolType, diagAddendum)) {
                        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportAssignmentType, localize_1.LocMessage.typeAssignmentMismatchWildcard().format({
                            ...printSrcDestTypes(importedSymbolType, declaredType),
                            name,
                        }) + diagAddendum.getString(), node, (_b = node.wildcardToken) !== null && _b !== void 0 ? _b : node);
                    }
                });
            }
        }
        else {
            // Use the first element of the name parts as the symbol.
            const symbolNameNode = node.module.nameParts[0];
            // Look up the symbol to find the alias declaration.
            let symbolType = getAliasedSymbolTypeForName(node, symbolNameNode.value);
            if (!symbolType) {
                return;
            }
            // Is there a cached module type associated with this node? If so, use
            // it instead of the type we just created.
            const cachedModuleType = readTypeCache(node, 0 /* EvalFlags.None */);
            if (cachedModuleType && (0, types_1.isModule)(cachedModuleType) && symbolType) {
                if ((0, types_1.isTypeSame)(symbolType, cachedModuleType)) {
                    symbolType = cachedModuleType;
                }
            }
            assignTypeToNameNode(symbolNameNode, { type: symbolType }, /* ignoreEmptyContainers */ false);
            writeTypeCache(node, { type: symbolType }, 0 /* EvalFlags.None */);
        }
    }
    function evaluateTypesForTypeAnnotationNode(node) {
        var _a;
        // If this node is part of an assignment statement, use specialized
        // logic that performs bidirectional inference and assignment
        // type narrowing.
        if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* ParseNodeType.Assignment */) {
            evaluateTypesForAssignmentStatement(node.parent);
        }
        else {
            const annotationType = getTypeOfAnnotation(node.typeAnnotation, {
                isVariableAnnotation: true,
                allowFinal: ParseTreeUtils.isFinalAllowedForAssignmentTarget(node.valueExpression),
                allowClassVar: ParseTreeUtils.isClassVarAllowedForAssignmentTarget(node.valueExpression),
            });
            writeTypeCache(node.valueExpression, { type: annotationType }, 0 /* EvalFlags.None */);
        }
    }
    function getAliasedSymbolTypeForName(node, name) {
        const symbolWithScope = lookUpSymbolRecursive(node, name, /* honorCodeFlow */ true);
        if (!symbolWithScope) {
            return undefined;
        }
        // Normally there will be at most one decl associated with the import node, but
        // there can be multiple in the case of the "from .X import X" statement. In such
        // case, we want to choose the last declaration.
        const filteredDecls = symbolWithScope.symbol
            .getDeclarations()
            .filter((decl) => ParseTreeUtils.isNodeContainedWithin(node, decl.node) && decl.type === 8 /* DeclarationType.Alias */);
        let aliasDecl = filteredDecls.length > 0 ? filteredDecls[filteredDecls.length - 1] : undefined;
        // If we didn't find an exact match, look for any alias associated with
        // this symbol. In cases where we have multiple ImportAs nodes that share
        // the same first-part name (e.g. "import asyncio" and "import asyncio.tasks"),
        // we may not find the declaration associated with this node.
        if (!aliasDecl) {
            aliasDecl = symbolWithScope.symbol.getDeclarations().find((decl) => decl.type === 8 /* DeclarationType.Alias */);
        }
        if (!aliasDecl) {
            return undefined;
        }
        (0, debug_1.assert)(aliasDecl.type === 8 /* DeclarationType.Alias */);
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        // Try to resolve the alias while honoring external visibility.
        const resolvedAliasInfo = resolveAliasDeclarationWithInfo(aliasDecl, /* resolveLocalNames */ true, {
            allowExternallyHiddenAccess: fileInfo.isStubFile,
        });
        if (!resolvedAliasInfo) {
            return undefined;
        }
        if (!resolvedAliasInfo.declaration) {
            return evaluatorOptions.evaluateUnknownImportsAsAny ? types_1.AnyType.create() : types_1.UnknownType.create();
        }
        if (node.nodeType === 26 /* ParseNodeType.ImportFromAs */) {
            if (resolvedAliasInfo.isPrivate) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportPrivateUsage, localize_1.LocMessage.privateUsedOutsideOfModule().format({
                    name: node.name.value,
                }), node.name);
            }
            if (resolvedAliasInfo.privatePyTypedImporter) {
                const diag = new diagnostic_1.DiagnosticAddendum();
                if (resolvedAliasInfo.privatePyTypedImported) {
                    diag.addMessage(localize_1.LocAddendum.privateImportFromPyTypedSource().format({
                        module: resolvedAliasInfo.privatePyTypedImported,
                    }));
                }
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportPrivateImportUsage, localize_1.LocMessage.privateImportFromPyTypedModule().format({
                    name: node.name.value,
                    module: resolvedAliasInfo.privatePyTypedImporter,
                }) + diag.getString(), node.name);
            }
        }
        return getInferredTypeOfDeclaration(symbolWithScope.symbol, aliasDecl);
    }
    // In some cases, an expression must be evaluated in the context of another
    // expression or statement that contains it. This contextual evaluation
    // allows for bidirectional type evaluation.
    function evaluateTypesForExpressionInContext(node) {
        var _a, _b, _c, _d, _e, _f;
        // Check for a couple of special cases where the node is a NameNode but
        // is technically not part of an expression. We'll handle these here so
        // callers don't need to include special-case logic.
        if (node.nodeType === 38 /* ParseNodeType.Name */ && node.parent) {
            if (node.parent.nodeType === 31 /* ParseNodeType.Function */ && node.parent.name === node) {
                getTypeOfFunction(node.parent);
                return;
            }
            if (node.parent.nodeType === 10 /* ParseNodeType.Class */ && node.parent.name === node) {
                getTypeOfClass(node.parent);
                return;
            }
            if (node.parent.nodeType === 26 /* ParseNodeType.ImportFromAs */) {
                evaluateTypesForImportFromAs(node.parent);
                return;
            }
            if (node.parent.nodeType === 24 /* ParseNodeType.ImportAs */) {
                evaluateTypesForImportAs(node.parent);
                return;
            }
            if (node.parent.nodeType === 77 /* ParseNodeType.TypeAlias */ && node.parent.name === node) {
                getTypeOfTypeAlias(node.parent);
                return;
            }
            if (node.parent.nodeType === 32 /* ParseNodeType.Global */ || node.parent.nodeType === 39 /* ParseNodeType.Nonlocal */) {
                // For global and nonlocal statements, allow forward references so
                // we don't use code flow during symbol lookups.
                getTypeOfExpression(node, 4 /* EvalFlags.ForwardRefs */);
                return;
            }
            if (node.parent.nodeType === 37 /* ParseNodeType.ModuleName */) {
                // A name within a module name isn't an expression,
                // so there's nothing we can evaluate here.
                return;
            }
        }
        // If the expression is part of a type annotation, we need to evaluate
        // it with special evaluation flags.
        const annotationNode = ParseTreeUtils.getParentAnnotationNode(node);
        if (annotationNode) {
            // Annotations need to be evaluated with specialized evaluation flags.
            const annotationParent = annotationNode.parent;
            (0, debug_1.assert)(annotationParent !== undefined);
            if (annotationParent.nodeType === 3 /* ParseNodeType.Assignment */) {
                if (annotationNode === annotationParent.typeAnnotationComment) {
                    getTypeOfAnnotation(annotationNode, {
                        isVariableAnnotation: true,
                        allowFinal: ParseTreeUtils.isFinalAllowedForAssignmentTarget(annotationParent.leftExpression),
                        allowClassVar: ParseTreeUtils.isClassVarAllowedForAssignmentTarget(annotationParent.leftExpression),
                    });
                }
                else {
                    evaluateTypesForAssignmentStatement(annotationParent);
                }
                return;
            }
            if (annotationParent.nodeType === 54 /* ParseNodeType.TypeAnnotation */) {
                evaluateTypesForTypeAnnotationNode(annotationParent);
                return;
            }
            if (annotationParent.nodeType === 31 /* ParseNodeType.Function */ &&
                annotationNode === annotationParent.returnTypeAnnotation) {
                getTypeOfAnnotation(annotationNode, {
                    associateTypeVarsWithScope: true,
                });
                return;
            }
            getTypeOfAnnotation(annotationNode, {
                isVariableAnnotation: ((_a = annotationNode.parent) === null || _a === void 0 ? void 0 : _a.nodeType) === 54 /* ParseNodeType.TypeAnnotation */,
                allowUnpackedTuple: annotationParent.nodeType === 41 /* ParseNodeType.Parameter */ &&
                    annotationParent.category === 1 /* ParameterCategory.ArgsList */,
                allowUnpackedTypedDict: annotationParent.nodeType === 41 /* ParseNodeType.Parameter */ &&
                    annotationParent.category === 2 /* ParameterCategory.KwargsDict */,
            });
            return;
        }
        // See if the expression is part of a pattern used in a case statement.
        const possibleCaseNode = ParseTreeUtils.getParentNodeOfType(node, 64 /* ParseNodeType.Case */);
        if (possibleCaseNode) {
            if (ParseTreeUtils.isNodeContainedWithin(node, possibleCaseNode.pattern)) {
                evaluateTypesForCaseStatement(possibleCaseNode);
                return;
            }
        }
        // Scan up the parse tree until we find a node that doesn't
        // require any context to be evaluated.
        let nodeToEvaluate = node;
        let flags = 0 /* EvalFlags.None */;
        while (true) {
            // If we're within an argument node in a call or index expression, skip
            // all of the nodes between because the entire argument expression
            // needs to be evaluated contextually.
            const argumentNode = ParseTreeUtils.getParentNodeOfType(nodeToEvaluate, 1 /* ParseNodeType.Argument */);
            if (argumentNode && argumentNode !== nodeToEvaluate) {
                (0, debug_1.assert)(argumentNode.parent !== undefined);
                if (argumentNode.parent.nodeType === 9 /* ParseNodeType.Call */ ||
                    argumentNode.parent.nodeType === 27 /* ParseNodeType.Index */) {
                    nodeToEvaluate = argumentNode.parent;
                    continue;
                }
                if (argumentNode.parent.nodeType === 10 /* ParseNodeType.Class */) {
                    // If this is an argument node within a class declaration,
                    // evaluate the full class declaration node.
                    getTypeOfClass(argumentNode.parent);
                    return;
                }
            }
            let parent = nodeToEvaluate.parent;
            if (!parent) {
                break;
            }
            // If this is the target of an assignment expression, evaluate the
            // assignment expression node instead.
            if (parent.nodeType === 4 /* ParseNodeType.AssignmentExpression */ && nodeToEvaluate === parent.name) {
                nodeToEvaluate = parent;
                continue;
            }
            // Forward-declared type annotation expressions need to be be evaluated
            // in context so they have the appropriate flags set. Most of these cases
            // will have been detected above when calling getParentAnnotationNode,
            // but TypeAlias expressions are not handled there.
            const stringEnclosure = ParseTreeUtils.getParentNodeOfType(parent, 48 /* ParseNodeType.StringList */);
            if (stringEnclosure) {
                nodeToEvaluate = stringEnclosure;
                continue;
            }
            // The left expression of a call or member access expression is not generally contextual.
            if (parent.nodeType === 9 /* ParseNodeType.Call */ || parent.nodeType === 35 /* ParseNodeType.MemberAccess */) {
                if (nodeToEvaluate === parent.leftExpression) {
                    // Handle the special case where the LHS is a call to super().
                    if (nodeToEvaluate.nodeType === 9 /* ParseNodeType.Call */ &&
                        nodeToEvaluate.leftExpression.nodeType === 38 /* ParseNodeType.Name */ &&
                        nodeToEvaluate.leftExpression.value === 'super') {
                        nodeToEvaluate = parent;
                        continue;
                    }
                    // Handle the special case where the LHS is a call to a lambda.
                    if (parent.nodeType === 9 /* ParseNodeType.Call */ && nodeToEvaluate.nodeType === 33 /* ParseNodeType.Lambda */) {
                        nodeToEvaluate = parent;
                        continue;
                    }
                    flags = 2 /* EvalFlags.CallBaseDefaults */;
                    break;
                }
            }
            else if (parent.nodeType === 27 /* ParseNodeType.Index */) {
                // The base expression of an index expression is not contextual.
                if (nodeToEvaluate === parent.baseExpression) {
                    flags = 2 /* EvalFlags.IndexBaseDefaults */;
                }
            }
            if (!(0, parseNodes_1.isExpressionNode)(parent)) {
                // If we've hit a non-expression node, we generally want to
                // stop. However, there are a few special "pass through"
                // node types that we can skip over to get to a known
                // expression node.
                if (parent.nodeType === 20 /* ParseNodeType.DictionaryKeyEntry */ ||
                    parent.nodeType === 19 /* ParseNodeType.DictionaryExpandEntry */ ||
                    parent.nodeType === 12 /* ParseNodeType.ComprehensionFor */ ||
                    parent.nodeType === 13 /* ParseNodeType.ComprehensionIf */) {
                    (0, debug_1.assert)(parent.parent !== undefined && (0, parseNodes_1.isExpressionNode)(parent.parent));
                    parent = parent.parent;
                }
                else if (parent.nodeType === 41 /* ParseNodeType.Parameter */) {
                    (0, debug_1.assert)(parent.parent !== undefined);
                    // Parameters are contextual for lambdas.
                    if (parent.parent.nodeType === 33 /* ParseNodeType.Lambda */) {
                        parent = parent.parent;
                    }
                    else {
                        break;
                    }
                }
                else if (parent.nodeType === 75 /* ParseNodeType.TypeParameter */) {
                    // If this is a bound or default expression in a type parameter list,
                    // we need to evaluate it in the context of the type parameter.
                    if (node === parent.boundExpression || node === parent.defaultExpression) {
                        getTypeOfTypeParameter(parent);
                        return;
                    }
                    break;
                }
                else {
                    break;
                }
            }
            nodeToEvaluate = parent;
        }
        const parent = nodeToEvaluate.parent;
        (0, debug_1.assert)(parent !== undefined);
        switch (parent.nodeType) {
            case 17 /* ParseNodeType.Del */: {
                verifyDeleteExpression(nodeToEvaluate);
                return;
            }
            case 75 /* ParseNodeType.TypeParameter */: {
                // If this is the name node within a type parameter list, see if it's a type alias
                // definition. If so, we need to evaluate the type alias contextually.
                if (nodeToEvaluate === parent.name &&
                    ((_b = parent.parent) === null || _b === void 0 ? void 0 : _b.nodeType) === 76 /* ParseNodeType.TypeParameterList */ &&
                    ((_c = parent.parent.parent) === null || _c === void 0 ? void 0 : _c.nodeType) === 77 /* ParseNodeType.TypeAlias */) {
                    getTypeOfTypeAlias(parent.parent.parent);
                    return;
                }
                break;
            }
            case 77 /* ParseNodeType.TypeAlias */: {
                getTypeOfTypeAlias(parent);
                return;
            }
            case 16 /* ParseNodeType.Decorator */: {
                if (((_d = parent.parent) === null || _d === void 0 ? void 0 : _d.nodeType) === 10 /* ParseNodeType.Class */) {
                    getTypeOfClass(parent.parent);
                }
                else if (((_e = parent.parent) === null || _e === void 0 ? void 0 : _e.nodeType) === 31 /* ParseNodeType.Function */) {
                    getTypeOfFunction(parent.parent);
                }
                return;
            }
            case 41 /* ParseNodeType.Parameter */: {
                if (nodeToEvaluate !== parent.defaultValue) {
                    evaluateTypeOfParameter(parent);
                    return;
                }
                break;
            }
            case 1 /* ParseNodeType.Argument */: {
                if (nodeToEvaluate === parent.name) {
                    // A name used to specify a named parameter in an argument isn't an
                    // expression, so there's nothing we can evaluate here.
                    return;
                }
                if (((_f = parent.parent) === null || _f === void 0 ? void 0 : _f.nodeType) === 10 /* ParseNodeType.Class */) {
                    // A class argument must be evaluated in the context of the class declaration.
                    getTypeOfClass(parent.parent);
                    return;
                }
                break;
            }
            case 44 /* ParseNodeType.Return */: {
                // Return expressions must be evaluated in the context of the expected return type.
                if (parent.returnExpression) {
                    const enclosingFunctionNode = ParseTreeUtils.getEnclosingFunction(node);
                    const declaredReturnType = enclosingFunctionNode
                        ? getFunctionDeclaredReturnType(enclosingFunctionNode)
                        : undefined;
                    getTypeOfExpression(parent.returnExpression, 0 /* EvalFlags.None */, (0, typeUtils_1.makeInferenceContext)(declaredReturnType));
                    return;
                }
                break;
            }
            case 54 /* ParseNodeType.TypeAnnotation */: {
                evaluateTypesForTypeAnnotationNode(parent);
                return;
            }
            case 3 /* ParseNodeType.Assignment */: {
                evaluateTypesForAssignmentStatement(parent);
                return;
            }
        }
        if (nodeToEvaluate.nodeType === 54 /* ParseNodeType.TypeAnnotation */) {
            evaluateTypesForTypeAnnotationNode(nodeToEvaluate);
            return;
        }
        getTypeOfExpression(nodeToEvaluate, flags);
    }
    function evaluateTypeOfParameter(node) {
        // If this parameter has no name, we have nothing to do.
        if (!node.name) {
            return;
        }
        // We need to handle lambdas differently from functions because
        // the former never have parameter type annotations but can
        // be inferred, whereas the latter sometimes have type annotations
        // but cannot be inferred.
        const parent = node.parent;
        if (parent.nodeType === 33 /* ParseNodeType.Lambda */) {
            evaluateTypesForExpressionInContext(parent);
            return;
        }
        (0, debug_1.assert)(parent.nodeType === 31 /* ParseNodeType.Function */);
        const functionNode = parent;
        const paramIndex = functionNode.parameters.findIndex((param) => param === node);
        const typeAnnotation = ParseTreeUtils.getTypeAnnotationForParameter(functionNode, paramIndex);
        if (typeAnnotation) {
            const param = functionNode.parameters[paramIndex];
            const annotatedType = getTypeOfParameterAnnotation(typeAnnotation, functionNode.parameters[paramIndex].category);
            const adjType = transformVariadicParamType(node, node.category, adjustParameterAnnotatedType(param, annotatedType));
            writeTypeCache(node.name, { type: adjType }, 0 /* EvalFlags.None */);
            return;
        }
        const containingClassNode = ParseTreeUtils.getEnclosingClass(functionNode, /* stopAtFunction */ true);
        const classInfo = containingClassNode ? getTypeOfClass(containingClassNode) : undefined;
        if (classInfo &&
            types_1.ClassType.isPseudoGenericClass(classInfo === null || classInfo === void 0 ? void 0 : classInfo.classType) &&
            functionNode.name.value === '__init__') {
            const typeParamName = getPseudoGenericTypeVarName(node.name.value);
            const paramType = classInfo.classType.details.typeParameters.find((param) => param.details.name === typeParamName);
            if (paramType) {
                writeTypeCache(node.name, { type: paramType }, 0 /* EvalFlags.None */);
                return;
            }
        }
        // See if the function is a method in a child class. We may be able to
        // infer the type of the parameter from a method of the same name in
        // a parent class if it has an annotated type.
        const functionFlags = (0, decorators_1.getFunctionInfoFromDecorators)(evaluatorInterface, functionNode, 
        /* isInClass */ true).flags;
        const inferredParamType = inferParameterType(functionNode, functionFlags, paramIndex, classInfo === null || classInfo === void 0 ? void 0 : classInfo.classType);
        writeTypeCache(node.name, { type: transformVariadicParamType(node, node.category, inferredParamType !== null && inferredParamType !== void 0 ? inferredParamType : types_1.UnknownType.create()) }, 0 /* EvalFlags.None */);
    }
    // Evaluates the types that are assigned within the statement that contains
    // the specified parse node. In some cases, a broader statement may need to
    // be evaluated to provide sufficient context for the type. Evaluated types
    // are written back to the type cache for later retrieval.
    function evaluateTypesForStatement(node) {
        initializePrefetchedTypes(node);
        let curNode = node;
        while (curNode) {
            switch (curNode.nodeType) {
                case 3 /* ParseNodeType.Assignment */: {
                    // See if the assignment is part of a chain of assignments. If so,
                    // evaluate the entire chain.
                    const isInAssignmentChain = curNode.parent &&
                        (curNode.parent.nodeType === 3 /* ParseNodeType.Assignment */ ||
                            curNode.parent.nodeType === 4 /* ParseNodeType.AssignmentExpression */ ||
                            curNode.parent.nodeType === 5 /* ParseNodeType.AugmentedAssignment */) &&
                        curNode.parent.rightExpression === curNode;
                    if (!isInAssignmentChain) {
                        evaluateTypesForAssignmentStatement(curNode);
                        return;
                    }
                    break;
                }
                case 77 /* ParseNodeType.TypeAlias */: {
                    getTypeOfTypeAlias(curNode);
                    return;
                }
                case 4 /* ParseNodeType.AssignmentExpression */: {
                    evaluateTypesForExpressionInContext(curNode);
                    return;
                }
                case 5 /* ParseNodeType.AugmentedAssignment */: {
                    evaluateTypesForAugmentedAssignment(curNode);
                    return;
                }
                case 10 /* ParseNodeType.Class */: {
                    getTypeOfClass(curNode);
                    return;
                }
                case 41 /* ParseNodeType.Parameter */: {
                    evaluateTypeOfParameter(curNode);
                    return;
                }
                case 33 /* ParseNodeType.Lambda */: {
                    evaluateTypesForExpressionInContext(curNode);
                    return;
                }
                case 31 /* ParseNodeType.Function */: {
                    getTypeOfFunction(curNode);
                    return;
                }
                case 29 /* ParseNodeType.For */: {
                    evaluateTypesForForStatement(curNode);
                    return;
                }
                case 28 /* ParseNodeType.Except */: {
                    evaluateTypesForExceptStatement(curNode);
                    return;
                }
                case 59 /* ParseNodeType.WithItem */: {
                    evaluateTypesForWithStatement(curNode);
                    return;
                }
                case 12 /* ParseNodeType.ComprehensionFor */: {
                    const comprehension = curNode.parent;
                    (0, debug_1.assert)(comprehension.nodeType === 11 /* ParseNodeType.Comprehension */);
                    if (curNode === comprehension.expression) {
                        evaluateTypesForExpressionInContext(comprehension);
                    }
                    else {
                        // Evaluate the individual iterations starting with the first
                        // up to the curNode.
                        for (const forIfNode of comprehension.forIfNodes) {
                            evaluateComprehensionForIf(forIfNode);
                            if (forIfNode === curNode) {
                                break;
                            }
                        }
                    }
                    return;
                }
                case 24 /* ParseNodeType.ImportAs */: {
                    evaluateTypesForImportAs(curNode);
                    return;
                }
                case 26 /* ParseNodeType.ImportFromAs */: {
                    evaluateTypesForImportFromAs(curNode);
                    return;
                }
                case 25 /* ParseNodeType.ImportFrom */: {
                    evaluateTypesForImportFrom(curNode);
                    return;
                }
                case 64 /* ParseNodeType.Case */: {
                    evaluateTypesForCaseStatement(curNode);
                    return;
                }
            }
            curNode = curNode.parent;
        }
        (0, debug_1.fail)('Unexpected statement');
        return undefined;
    }
    // Helper function for cases where we need to evaluate the types
    // for a subtree so we can determine the type of one of the subnodes
    // within that tree. If the type cannot be determined (because it's part
    // of a cyclical dependency), the function returns undefined.
    function evaluateTypeForSubnode(subnode, callback) {
        // If the type cache is already populated with a complete type,
        // don't bother doing additional work.
        let cacheEntry = readTypeCacheEntry(subnode);
        if (cacheEntry && !cacheEntry.typeResult.isIncomplete) {
            const typeResult = cacheEntry.typeResult;
            // Handle the special case where a function or class is partially evaluated.
            // Indicate that these are not complete types.
            if ((0, types_1.isFunction)(typeResult.type) && types_1.FunctionType.isPartiallyEvaluated(typeResult.type)) {
                return { ...typeResult, isIncomplete: true };
            }
            if ((0, types_1.isClass)(typeResult.type) && types_1.ClassType.isPartiallyEvaluated(typeResult.type)) {
                return { ...typeResult, isIncomplete: true };
            }
            return typeResult;
        }
        callback();
        cacheEntry = readTypeCacheEntry(subnode);
        if (cacheEntry) {
            return cacheEntry.typeResult;
        }
        return undefined;
    }
    function getCodeFlowAnalyzerForNode(nodeId, typeAtStart) {
        let entries = codeFlowAnalyzerCache.get(nodeId);
        if (entries) {
            const cachedEntry = entries.find((entry) => {
                if (!typeAtStart || !entry.typeAtStart) {
                    return !typeAtStart && !entry.typeAtStart;
                }
                if (!typeAtStart.isIncomplete !== !entry.typeAtStart.isIncomplete) {
                    return false;
                }
                return (0, types_1.isTypeSame)(typeAtStart.type, entry.typeAtStart.type);
            });
            if (cachedEntry) {
                return cachedEntry.codeFlowAnalyzer;
            }
        }
        // Allocate a new code flow analyzer.
        const analyzer = codeFlowEngine.createCodeFlowAnalyzer();
        if (entries) {
            entries.push({ typeAtStart, codeFlowAnalyzer: analyzer });
        }
        else {
            entries = [{ typeAtStart, codeFlowAnalyzer: analyzer }];
            codeFlowAnalyzerCache.set(nodeId, entries);
        }
        return analyzer;
    }
    // Attempts to determine the type of the reference expression at the
    // point in the code. If the code flow analysis has nothing to say
    // about that expression, it returns un undefined type. Normally
    // flow analysis starts from the reference node, but startNode can be
    // specified to override this in a few special cases (functions and
    // lambdas) to support analysis of captured variables.
    function getFlowTypeOfReference(reference, startNode, options) {
        var _a;
        // See if this execution scope requires code flow for this reference expression.
        const referenceKey = (0, codeFlowTypes_1.createKeyForReference)(reference);
        const executionNode = ParseTreeUtils.getExecutionScopeNode((_a = startNode === null || startNode === void 0 ? void 0 : startNode.parent) !== null && _a !== void 0 ? _a : reference);
        const codeFlowExpressions = AnalyzerNodeInfo.getCodeFlowExpressions(executionNode);
        if (!codeFlowExpressions ||
            (!codeFlowExpressions.has(referenceKey) && !codeFlowExpressions.has(codeFlowTypes_1.wildcardImportReferenceKey))) {
            return { type: undefined, isIncomplete: false };
        }
        if (checkCodeFlowTooComplex(reference)) {
            return { type: undefined, isIncomplete: true };
        }
        // Is there an code flow analyzer cached for this execution scope?
        let analyzer;
        if (isNodeInReturnTypeInferenceContext(executionNode)) {
            // If we're performing the analysis within a temporary
            // context of a function for purposes of inferring its
            // return type for a specified set of arguments, use
            // a temporary analyzer that we'll use only for this context.
            analyzer = getCodeFlowAnalyzerForReturnTypeInferenceContext();
        }
        else {
            analyzer = getCodeFlowAnalyzerForNode(executionNode.id, options === null || options === void 0 ? void 0 : options.typeAtStart);
        }
        const flowNode = AnalyzerNodeInfo.getFlowNode(startNode !== null && startNode !== void 0 ? startNode : reference);
        if (flowNode === undefined) {
            return { type: undefined, isIncomplete: false };
        }
        return analyzer.getTypeFromCodeFlow(flowNode, reference, options);
    }
    // Specializes the specified (potentially generic) class type using
    // the specified type arguments, reporting errors as appropriate.
    // Returns the specialized type and a boolean indicating whether
    // the type indicates a class type (true) or an object type (false).
    function createSpecializedClassType(classType, typeArgs, flags, errorNode) {
        // Handle the special-case classes that are not defined
        // in the type stubs.
        if (types_1.ClassType.isSpecialBuiltIn(classType)) {
            const aliasedName = classType.aliasName || classType.details.name;
            switch (aliasedName) {
                case 'Callable': {
                    return { type: createCallableType(classType, typeArgs, errorNode) };
                }
                case 'Never': {
                    if (typeArgs && typeArgs.length > 0) {
                        addError(localize_1.LocMessage.typeArgsExpectingNone().format({ name: 'Never' }), typeArgs[0].node);
                    }
                    return { type: types_1.NeverType.createNever() };
                }
                case 'NoReturn': {
                    if (typeArgs && typeArgs.length > 0) {
                        addError(localize_1.LocMessage.typeArgsExpectingNone().format({ name: 'NoReturn' }), typeArgs[0].node);
                    }
                    return { type: types_1.NeverType.createNoReturn() };
                }
                case 'Optional': {
                    return { type: createOptionalType(classType, errorNode, typeArgs, flags) };
                }
                case 'Type': {
                    let typeType = createSpecialType(classType, typeArgs, 1, 
                    /* allowParamSpec */ undefined, 
                    /* isSpecialForm */ false);
                    if ((0, types_1.isInstantiableClass)(typeType)) {
                        typeType = (0, typeUtils_1.explodeGenericClass)(typeType);
                    }
                    return { type: typeType };
                }
                case 'ClassVar': {
                    return { type: createClassVarType(classType, errorNode, typeArgs, flags) };
                }
                case 'Protocol': {
                    if ((flags & (67108864 /* EvalFlags.NoNonTypeSpecialForms */ | 256 /* EvalFlags.TypeExpression */)) !== 0) {
                        addError(localize_1.LocMessage.protocolNotAllowed(), errorNode);
                    }
                    typeArgs === null || typeArgs === void 0 ? void 0 : typeArgs.forEach((typeArg) => {
                        if (typeArg.typeList || !(0, types_1.isTypeVar)(typeArg.type)) {
                            addError(localize_1.LocMessage.protocolTypeArgMustBeTypeParam(), typeArg.node);
                        }
                    });
                    return {
                        type: createSpecialType(classType, typeArgs, 
                        /* paramLimit */ undefined, 
                        /* allowParamSpec */ true),
                    };
                }
                case 'TypedDict': {
                    if ((flags & (67108864 /* EvalFlags.NoNonTypeSpecialForms */ | 256 /* EvalFlags.TypeExpression */)) !== 0) {
                        addError(localize_1.LocMessage.typedDictNotAllowed(), errorNode);
                    }
                    break;
                }
                case 'Literal': {
                    if ((flags & (67108864 /* EvalFlags.NoNonTypeSpecialForms */ | 256 /* EvalFlags.TypeExpression */)) !== 0) {
                        addError(localize_1.LocMessage.literalNotAllowed(), errorNode);
                    }
                    break;
                }
                case 'Tuple': {
                    return {
                        type: createSpecialType(classType, typeArgs, 
                        /* paramLimit */ undefined, 
                        /* allowParamSpec */ false, 
                        /* isSpecialForm */ false),
                    };
                }
                case 'Union': {
                    return { type: createUnionType(classType, errorNode, typeArgs, flags) };
                }
                case 'Generic': {
                    return { type: createGenericType(classType, errorNode, typeArgs, flags) };
                }
                case 'Final': {
                    return { type: createFinalType(classType, errorNode, typeArgs, flags) };
                }
                case 'Annotated': {
                    return createAnnotatedType(classType, errorNode, typeArgs, flags);
                }
                case 'Concatenate': {
                    return { type: createConcatenateType(classType, errorNode, typeArgs, flags) };
                }
                case 'TypeGuard':
                case 'TypeIs': {
                    return { type: createTypeGuardType(classType, errorNode, typeArgs, flags) };
                }
                case 'Unpack': {
                    return { type: createUnpackType(classType, errorNode, typeArgs, flags) };
                }
                case 'Required':
                case 'NotRequired': {
                    return createRequiredOrReadOnlyType(classType, errorNode, typeArgs, flags);
                }
                case 'ReadOnly': {
                    return createRequiredOrReadOnlyType(classType, errorNode, typeArgs, flags);
                }
                case 'Self': {
                    return { type: createSelfType(classType, errorNode, typeArgs, flags) };
                }
                case 'LiteralString': {
                    return { type: createSpecialType(classType, typeArgs, 0) };
                }
            }
        }
        const fileInfo = AnalyzerNodeInfo.getFileInfo(errorNode);
        if (fileInfo.isStubFile ||
            fileInfo.executionEnvironment.pythonVersion.isGreaterOrEqualTo(pythonVersion_1.pythonVersion3_9) ||
            (0, analyzerFileInfo_1.isAnnotationEvaluationPostponed)(AnalyzerNodeInfo.getFileInfo(errorNode)) ||
            (flags & 4 /* EvalFlags.ForwardRefs */) !== 0) {
            // Handle "type" specially, since it needs to act like "Type"
            // in Python 3.9 and newer.
            if (types_1.ClassType.isBuiltIn(classType, 'type') && typeArgs) {
                if (typeArgs.length >= 1) {
                    // Treat type[function] as illegal.
                    if ((0, types_1.isFunction)(typeArgs[0].type) || (0, types_1.isOverloadedFunction)(typeArgs[0].type)) {
                        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportInvalidTypeForm, localize_1.LocMessage.typeAnnotationWithCallable(), typeArgs[0].node);
                        return { type: types_1.UnknownType.create() };
                    }
                }
                if (typeClass && (0, types_1.isInstantiableClass)(typeClass)) {
                    let typeType = createSpecialType(typeClass, typeArgs, 1, 
                    /* allowParamSpec */ undefined, 
                    /* isSpecialForm */ false);
                    if ((0, types_1.isInstantiableClass)(typeType)) {
                        typeType = (0, typeUtils_1.explodeGenericClass)(typeType);
                    }
                    return { type: typeType };
                }
            }
            // Handle "tuple" specially, since it needs to act like "Tuple"
            // in Python 3.9 and newer.
            if ((0, typeUtils_1.isTupleClass)(classType)) {
                return {
                    type: createSpecialType(classType, typeArgs, 
                    /* paramLimit */ undefined, 
                    /* allowParamSpec */ undefined, 
                    /* isSpecialForm */ false),
                };
            }
        }
        let typeArgCount = typeArgs ? typeArgs.length : 0;
        // Make sure the argument list count is correct.
        const typeParameters = types_1.ClassType.isPseudoGenericClass(classType) ? [] : types_1.ClassType.getTypeParameters(classType);
        // If there are no type parameters or args, the class is already specialized.
        // No need to do any more work.
        if (typeParameters.length === 0 && typeArgCount === 0) {
            return { type: classType };
        }
        const variadicTypeParamIndex = typeParameters.findIndex((param) => (0, types_1.isVariadicTypeVar)(param));
        if (typeArgs) {
            let minTypeArgCount = typeParameters.length;
            const firstDefaultParamIndex = typeParameters.findIndex((param) => !!param.details.isDefaultExplicit);
            if (firstDefaultParamIndex >= 0) {
                minTypeArgCount = firstDefaultParamIndex;
            }
            if (typeArgCount > typeParameters.length) {
                if (!types_1.ClassType.isPartiallyEvaluated(classType) && !types_1.ClassType.isTupleClass(classType)) {
                    if (typeParameters.length === 0) {
                        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportInvalidTypeArguments, localize_1.LocMessage.typeArgsExpectingNone().format({
                            name: classType.aliasName || classType.details.name,
                        }), typeArgs[typeParameters.length].node);
                    }
                    else if (typeParameters.length !== 1 || !(0, types_1.isParamSpec)(typeParameters[0])) {
                        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportInvalidTypeArguments, localize_1.LocMessage.typeArgsTooMany().format({
                            name: classType.aliasName || classType.details.name,
                            expected: typeParameters.length,
                            received: typeArgCount,
                        }), typeArgs[typeParameters.length].node);
                    }
                    typeArgCount = typeParameters.length;
                }
            }
            else if (typeArgCount < minTypeArgCount) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportInvalidTypeArguments, localize_1.LocMessage.typeArgsTooFew().format({
                    name: classType.aliasName || classType.details.name,
                    expected: minTypeArgCount,
                    received: typeArgCount,
                }), typeArgs.length > 0 ? typeArgs[0].node.parent : errorNode);
            }
            typeArgs.forEach((typeArg, index) => {
                if (index === variadicTypeParamIndex) {
                    // The types that make up the tuple that maps to the variadic
                    // type variable have already been validated when the tuple
                    // object was created in adjustTypeArgumentsForVariadicTypeVar.
                    if ((0, types_1.isClassInstance)(typeArg.type) && (0, typeUtils_1.isTupleClass)(typeArg.type)) {
                        return;
                    }
                    if ((0, types_1.isVariadicTypeVar)(typeArg.type)) {
                        validateVariadicTypeVarIsUnpacked(typeArg.type, typeArg.node);
                        return;
                    }
                }
                const typeParam = index < typeParameters.length ? typeParameters[index] : undefined;
                const isParamSpecTarget = typeParam === null || typeParam === void 0 ? void 0 : typeParam.details.isParamSpec;
                validateTypeArg(typeArg, {
                    allowParamSpec: true,
                    allowTypeArgList: isParamSpecTarget,
                });
            });
        }
        // Handle ParamSpec arguments and fill in any missing type arguments with Unknown.
        let typeArgTypes = [];
        const fullTypeParams = types_1.ClassType.getTypeParameters(classType);
        // PEP 612 says that if the class has only one type parameter consisting
        // of a ParamSpec, the list of arguments does not need to be enclosed in
        // a list. We'll handle that case specially here.
        if (fullTypeParams.length === 1 && fullTypeParams[0].details.isParamSpec && typeArgs) {
            if (typeArgs.every((typeArg) => !(0, typeUtils_1.isEllipsisType)(typeArg.type) && !typeArg.typeList && !(0, types_1.isParamSpec)(typeArg.type))) {
                if (typeArgs.length !== 1 ||
                    !(0, types_1.isInstantiableClass)(typeArgs[0].type) ||
                    !types_1.ClassType.isBuiltIn(typeArgs[0].type, 'Concatenate')) {
                    // Package up the type arguments into a typeList.
                    typeArgs = [
                        {
                            type: types_1.UnknownType.create(),
                            node: typeArgs[0].node,
                            typeList: typeArgs,
                        },
                    ];
                }
            }
            else if (typeArgs.length > 1) {
                const paramSpecTypeArg = typeArgs.find((typeArg) => (0, types_1.isParamSpec)(typeArg.type));
                if (paramSpecTypeArg) {
                    addError(localize_1.LocMessage.paramSpecContext(), paramSpecTypeArg.node);
                }
                const listTypeArg = typeArgs.find((typeArg) => !!typeArg.typeList);
                if (listTypeArg) {
                    addError(localize_1.LocMessage.typeArgListNotAllowed(), listTypeArg.node);
                }
            }
        }
        const typeVarContext = new typeVarContext_1.TypeVarContext(classType.details.typeVarScopeId);
        fullTypeParams.forEach((typeParam, index) => {
            if (typeArgs && index < typeArgs.length) {
                if (typeParam.details.isParamSpec) {
                    const typeArg = typeArgs[index];
                    const functionType = types_1.FunctionType.createSynthesizedInstance('', 65536 /* FunctionTypeFlags.ParamSpecValue */);
                    if ((0, typeUtils_1.isEllipsisType)(typeArg.type)) {
                        types_1.FunctionType.addDefaultParameters(functionType);
                        functionType.details.flags |= 32768 /* FunctionTypeFlags.GradualCallableForm */;
                        typeArgTypes.push(functionType);
                        typeVarContext.setTypeVarType(typeParam, (0, typeUtils_1.convertTypeToParamSpecValue)(functionType));
                        return;
                    }
                    if (typeArg.typeList) {
                        typeArg.typeList.forEach((paramType, paramIndex) => {
                            types_1.FunctionType.addParameter(functionType, {
                                category: 0 /* ParameterCategory.Simple */,
                                name: `__p${paramIndex}`,
                                isNameSynthesized: true,
                                type: (0, typeUtils_1.convertToInstance)(paramType.type),
                                hasDeclaredType: true,
                            });
                        });
                        if (typeArg.typeList.length > 0) {
                            types_1.FunctionType.addPositionOnlyParameterSeparator(functionType);
                        }
                        typeArgTypes.push(functionType);
                        typeVarContext.setTypeVarType(typeParam, (0, typeUtils_1.convertTypeToParamSpecValue)(functionType));
                        return;
                    }
                    if ((0, types_1.isInstantiableClass)(typeArg.type) && types_1.ClassType.isBuiltIn(typeArg.type, 'Concatenate')) {
                        const concatTypeArgs = typeArg.type.typeArguments;
                        if (concatTypeArgs && concatTypeArgs.length > 0) {
                            concatTypeArgs.forEach((typeArg, index) => {
                                if (index === concatTypeArgs.length - 1) {
                                    if ((0, types_1.isParamSpec)(typeArg)) {
                                        types_1.FunctionType.addParamSpecVariadics(functionType, typeArg);
                                    }
                                    else if ((0, typeUtils_1.isEllipsisType)(typeArg)) {
                                        types_1.FunctionType.addDefaultParameters(functionType);
                                        functionType.details.flags |= 32768 /* FunctionTypeFlags.GradualCallableForm */;
                                    }
                                }
                                else {
                                    types_1.FunctionType.addParameter(functionType, {
                                        category: 0 /* ParameterCategory.Simple */,
                                        name: `__p${index}`,
                                        isNameSynthesized: true,
                                        hasDeclaredType: true,
                                        type: typeArg,
                                    });
                                }
                            });
                        }
                        typeArgTypes.push(functionType);
                        return;
                    }
                }
                const typeArgType = (0, typeUtils_1.convertToInstance)(typeArgs[index].type);
                typeArgTypes.push(typeArgType);
                typeVarContext.setTypeVarType(typeParam, typeArgType);
                return;
            }
            const solvedDefaultType = (0, typeUtils_1.applySolvedTypeVars)(typeParam, typeVarContext, {
                unknownIfNotFound: true,
                tupleClassType: getTupleClassType(),
            });
            typeArgTypes.push(solvedDefaultType);
            if ((0, types_1.isParamSpec)(typeParam)) {
                typeVarContext.setTypeVarType(typeParam, (0, typeUtils_1.convertTypeToParamSpecValue)(solvedDefaultType));
            }
            else {
                typeVarContext.setTypeVarType(typeParam, solvedDefaultType);
            }
        });
        typeArgTypes = typeArgTypes.map((typeArgType, index) => {
            if (index < typeArgCount) {
                const diag = new diagnostic_1.DiagnosticAddendum();
                let adjustedTypeArgType = applyTypeArgToTypeVar(typeParameters[index], typeArgType, diag);
                // Determine if the variance must match.
                if (adjustedTypeArgType && (flags & 16384 /* EvalFlags.EnforceVarianceConsistency */) !== 0) {
                    const destType = typeParameters[index];
                    const declaredVariance = destType.details.declaredVariance;
                    if (!(0, typeUtils_1.isVarianceOfTypeArgumentCompatible)(adjustedTypeArgType, declaredVariance)) {
                        diag.addMessage(localize_1.LocAddendum.varianceMismatchForClass().format({
                            typeVarName: printType(adjustedTypeArgType),
                            className: classType.details.name,
                        }));
                        adjustedTypeArgType = undefined;
                    }
                }
                if (adjustedTypeArgType) {
                    typeArgType = adjustedTypeArgType;
                }
                else {
                    // Avoid emitting this error for a partially-constructed class.
                    if (!(0, types_1.isClassInstance)(typeArgType) || !types_1.ClassType.isPartiallyEvaluated(typeArgType)) {
                        (0, debug_1.assert)(typeArgs !== undefined);
                        addDiagnostic(diagnosticRules_1.DiagnosticRule.reportInvalidTypeArguments, localize_1.LocMessage.typeVarAssignmentMismatch().format({
                            type: printType(typeArgType),
                            name: types_1.TypeVarType.getReadableName(typeParameters[index]),
                        }) + diag.getString(), typeArgs[index].node);
                    }
                }
            }
            return typeArgType;
        });
        // If the class is partially constructed and doesn't yet have
        // type parameters, assume that the number and types of supplied type
        // arguments are correct.
        if (typeArgs && classType.details.typeParameters.length === 0 && types_1.ClassType.isPartiallyEvaluated(classType)) {
            typeArgTypes = typeArgs.map((t) => (0, typeUtils_1.convertToInstance)(t.type));
        }
        const specializedClass = types_1.ClassType.cloneForSpecialization(classType, typeArgTypes, typeArgs !== undefined);
        return { type: specializedClass };
    }
    function getTypeOfArgument(arg, inferenceContext, signatureTracker) {
        var _a, _b;
        if (arg.typeResult) {
            const type = (_b = (_a = arg.typeResult.type) === null || _a === void 0 ? void 0 : _a.specialForm) !== null && _b !== void 0 ? _b : arg.typeResult.type;
            return { type, isIncomplete: arg.typeResult.isIncomplete };
        }
        if (!arg.valueExpression) {
            // We shouldn't ever get here, but just in case.
            return { type: types_1.UnknownType.create() };
        }
        // If there was no defined type provided, there should always
        // be a value expression from which we can retrieve the type.
        const typeResult = getTypeOfExpression(arg.valueExpression, 
        /* flags */ undefined, inferenceContext, signatureTracker);
        if (signatureTracker) {
            typeResult.type = (0, typeUtils_1.ensureFunctionSignaturesAreUnique)(typeResult.type, signatureTracker, arg.valueExpression.start);
        }
        return typeResult;
    }
    // This function is like getTypeOfArgument except that it is
    // used in cases where the argument is expected to be a type
    // and therefore follows the normal rules of types (e.g. they
    // can be forward-declared in stubs, etc.).
    function getTypeOfArgumentExpectingType(arg, options) {
        if (arg.typeResult) {
            return { type: arg.typeResult.type, isIncomplete: arg.typeResult.isIncomplete };
        }
        // If there was no defined type provided, there should always
        // be a value expression from which we can retrieve the type.
        (0, debug_1.assert)(arg.valueExpression !== undefined);
        return getTypeOfExpressionExpectingType(arg.valueExpression, options);
    }
    function getTypeOfExpressionExpectingType(node, options) {
        let flags = 128 /* EvalFlags.InstantiableType */ | 8 /* EvalFlags.StrLiteralAsType */ | 131072 /* EvalFlags.NoClassVar */;
        if (options === null || options === void 0 ? void 0 : options.allowTypeVarsWithoutScopeId) {
            flags |= 4096 /* EvalFlags.AllowTypeVarWithoutScopeId */;
        }
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        if (fileInfo.isStubFile || (options === null || options === void 0 ? void 0 : options.allowForwardReference)) {
            flags |= 4 /* EvalFlags.ForwardRefs */;
        }
        else {
            flags |= 8388608 /* EvalFlags.ParsesStringLiteral */;
        }
        if (!options || !options.allowFinal) {
            flags |= 16 /* EvalFlags.NoFinal */;
        }
        if (options === null || options === void 0 ? void 0 : options.allowRequired) {
            flags |= 1048576 /* EvalFlags.AllowRequired */ | 256 /* EvalFlags.TypeExpression */;
        }
        if (options === null || options === void 0 ? void 0 : options.allowUnpackedTuple) {
            flags |= 2097152 /* EvalFlags.AllowUnpackedTuple */;
        }
        else {
            flags |= 64 /* EvalFlags.NoTypeVarTuple */;
        }
        if (!options || !options.allowParamSpec) {
            flags |= 32 /* EvalFlags.NoParamSpec */;
        }
        if (options === null || options === void 0 ? void 0 : options.enforceTypeAnnotationRules) {
            flags |= 256 /* EvalFlags.TypeExpression */;
        }
        if (options === null || options === void 0 ? void 0 : options.disallowProtocolAndTypedDict) {
            flags |= 67108864 /* EvalFlags.NoNonTypeSpecialForms */;
        }
        return getTypeOfExpression(node, flags);
    }
    function getBuiltInType(node, name) {
        const scope = ScopeUtils.getScopeForNode(node);
        if (scope) {
            const builtInScope = ScopeUtils.getBuiltInScope(scope);
            const nameType = builtInScope.lookUpSymbol(name);
            if (nameType) {
                return getEffectiveTypeOfSymbol(nameType);
            }
        }
        return types_1.UnknownType.create();
    }
    function getBuiltInObject(node, name, typeArguments) {
        const nameType = getBuiltInType(node, name);
        if ((0, types_1.isInstantiableClass)(nameType)) {
            let classType = nameType;
            if (typeArguments) {
                classType = types_1.ClassType.cloneForSpecialization(classType, typeArguments, 
                /* isTypeArgumentExplicit */ typeArguments !== undefined);
            }
            return types_1.ClassType.cloneAsInstance(classType);
        }
        return nameType;
    }
    function lookUpSymbolRecursive(node, name, honorCodeFlow, preferGlobalScope = false) {
        var _a;
        const scopeNodeInfo = ParseTreeUtils.getEvaluationScopeNode(node);
        const scope = AnalyzerNodeInfo.getScope(scopeNodeInfo.node);
        let symbolWithScope = scope === null || scope === void 0 ? void 0 : scope.lookUpSymbolRecursive(name, { useProxyScope: !!scopeNodeInfo.useProxyScope });
        const scopeType = (_a = scope === null || scope === void 0 ? void 0 : scope.type) !== null && _a !== void 0 ? _a : 4 /* ScopeType.Module */;
        // Functions and list comprehensions don't allow access to implicitly
        // aliased symbols in outer scopes if they haven't yet been assigned
        // within the local scope.
        let scopeTypeHonorsCodeFlow = scopeType !== 2 /* ScopeType.Function */ && scopeType !== 1 /* ScopeType.Comprehension */;
        // TypeParameter scopes don't honor code flow, but if the symbol is resolved
        // using the proxy scope for the TypeParameter scope, we should use code flow.
        if (scopeType === 0 /* ScopeType.TypeParameter */ && symbolWithScope && symbolWithScope.scope === scope) {
            scopeTypeHonorsCodeFlow = false;
        }
        if (symbolWithScope && honorCodeFlow && scopeTypeHonorsCodeFlow) {
            // Filter the declarations based on flow reachability.
            const reachableDecl = symbolWithScope.symbol.getDeclarations().find((decl) => {
                if (decl.type !== 8 /* DeclarationType.Alias */ && decl.type !== 0 /* DeclarationType.Intrinsic */) {
                    // Is the declaration in the same execution scope as the "usageNode" node?
                    const usageScope = ParseTreeUtils.getExecutionScopeNode(node);
                    const declNode = decl.type === 6 /* DeclarationType.Class */ ||
                        decl.type === 5 /* DeclarationType.Function */ ||
                        decl.type === 4 /* DeclarationType.TypeAlias */
                        ? decl.node.name
                        : decl.node;
                    const declScope = ParseTreeUtils.getExecutionScopeNode(declNode);
                    if (usageScope === declScope) {
                        if (!isFlowPathBetweenNodes(declNode, node)) {
                            // If there was no control flow path from the usage back
                            // to the source, see if the usage node is reachable by
                            // any path.
                            const flowNode = AnalyzerNodeInfo.getFlowNode(node);
                            const isReachable = flowNode &&
                                codeFlowEngine.isFlowNodeReachable(flowNode, 
                                /* sourceFlowNode */ undefined, 
                                /* ignoreNoReturn */ true);
                            return !isReachable;
                        }
                    }
                }
                return true;
            });
            // If none of the declarations are reachable from the current node,
            // search for the symbol in outer scopes.
            if (!reachableDecl) {
                if (symbolWithScope.scope.type !== 2 /* ScopeType.Function */) {
                    let nextScopeToSearch = symbolWithScope.scope.parent;
                    const isOutsideCallerModule = symbolWithScope.isOutsideCallerModule || symbolWithScope.scope.type === 4 /* ScopeType.Module */;
                    let isBeyondExecutionScope = symbolWithScope.isBeyondExecutionScope || symbolWithScope.scope.isIndependentlyExecutable();
                    if (symbolWithScope.scope.type === 3 /* ScopeType.Class */) {
                        // There is an odd documented behavior for classes in that
                        // symbol resolution skips to the global scope rather than
                        // the next scope in the chain.
                        const globalScopeResult = symbolWithScope.scope.getGlobalScope();
                        nextScopeToSearch = globalScopeResult.scope;
                        if (globalScopeResult.isBeyondExecutionScope) {
                            isBeyondExecutionScope = true;
                        }
                    }
                    if (nextScopeToSearch) {
                        symbolWithScope = nextScopeToSearch.lookUpSymbolRecursive(name, {
                            isOutsideCallerModule,
                            isBeyondExecutionScope,
                        });
                    }
                    else {
                        symbolWithScope = undefined;
                    }
                }
                else {
                    symbolWithScope = undefined;
                }
            }
        }
        // PEP 563 indicates that if a forward reference can be resolved in the module
        // scope (or, by implication, in the builtins scope), it should prefer that
        // resolution over local resolutions.
        if (symbolWithScope && preferGlobalScope) {
            let curSymbolWithScope = symbolWithScope;
            while (curSymbolWithScope.scope.type !== 4 /* ScopeType.Module */ &&
                curSymbolWithScope.scope.type !== 5 /* ScopeType.Builtin */ &&
                curSymbolWithScope.scope.type !== 0 /* ScopeType.TypeParameter */ &&
                curSymbolWithScope.scope.parent) {
                curSymbolWithScope = curSymbolWithScope.scope.parent.lookUpSymbolRecursive(name, {
                    isOutsideCallerModule: curSymbolWithScope.isOutsideCallerModule,
                    isBeyondExecutionScope: curSymbolWithScope.isBeyondExecutionScope ||
                        curSymbolWithScope.scope.isIndependentlyExecutable(),
                });
                if (!curSymbolWithScope) {
                    break;
                }
            }
            if ((curSymbolWithScope === null || curSymbolWithScope === void 0 ? void 0 : curSymbolWithScope.scope.type) === 4 /* ScopeType.Module */ ||
                (curSymbolWithScope === null || curSymbolWithScope === void 0 ? void 0 : curSymbolWithScope.scope.type) === 5 /* ScopeType.Builtin */) {
                symbolWithScope = curSymbolWithScope;
            }
        }
        return symbolWithScope;
    }
    // Disables recording of errors and warnings.
    function suppressDiagnostics(node, callback, diagCallback) {
        suppressedNodeStack.push({ node, suppressedDiags: diagCallback ? [] : undefined });
        try {
            const result = callback();
            const poppedNode = suppressedNodeStack.pop();
            if (diagCallback && (poppedNode === null || poppedNode === void 0 ? void 0 : poppedNode.suppressedDiags)) {
                diagCallback(poppedNode.suppressedDiags);
            }
            return result;
        }
        catch (e) {
            // We don't use finally here because the TypeScript debugger doesn't
            // handle finally well when single stepping.
            suppressedNodeStack.pop();
            throw e;
        }
    }
    // Disables recording of errors and warnings and disables any caching of
    // types, under the assumption that we're performing speculative evaluations.
    // If speculativeNode is undefined, speculative mode is not used. This is
    // useful in cases where we conditionally want to use speculative mode.
    function useSpeculativeMode(speculativeNode, callback, options) {
        if (!speculativeNode) {
            return callback();
        }
        speculativeTypeTracker.enterSpeculativeContext(speculativeNode, options);
        try {
            const result = callback();
            speculativeTypeTracker.leaveSpeculativeContext();
            return result;
        }
        catch (e) {
            // We don't use finally here because the TypeScript debugger doesn't
            // handle finally well when single stepping.
            speculativeTypeTracker.leaveSpeculativeContext();
            throw e;
        }
    }
    function disableSpeculativeMode(callback) {
        const stack = speculativeTypeTracker.disableSpeculativeMode();
        try {
            callback();
            speculativeTypeTracker.enableSpeculativeMode(stack);
        }
        catch (e) {
            // We don't use finally here because the TypeScript debugger doesn't
            // handle finally well when single stepping.
            speculativeTypeTracker.enableSpeculativeMode(stack);
            throw e;
        }
    }
    // Indicates whether the specified node is within a context that
    // is currently being evaluated speculative. If node is undefined,
    // returns true if any node is being evaluated speculatively.
    function isSpeculativeModeInUse(node) {
        return speculativeTypeTracker.isSpeculative(node);
    }
    function getDeclarationFromFunctionNamedParameter(type, paramName) {
        if ((0, types_1.isFunction)(type)) {
            if (type.details.declaration) {
                const functionDecl = type.details.declaration;
                if (functionDecl.type === 5 /* DeclarationType.Function */) {
                    const functionNode = functionDecl.node;
                    const functionScope = AnalyzerNodeInfo.getScope(functionNode);
                    if (functionScope) {
                        const paramSymbol = functionScope.lookUpSymbol(paramName);
                        if (paramSymbol) {
                            return paramSymbol
                                .getDeclarations()
                                .find((decl) => decl.type === 2 /* DeclarationType.Parameter */);
                        }
                        const parameterDetails = (0, parameterUtils_1.getParameterListDetails)(type);
                        if (parameterDetails.unpackedKwargsTypedDictType) {
                            const lookupResults = (0, typeUtils_1.lookUpClassMember)(parameterDetails.unpackedKwargsTypedDictType, paramName);
                            if (lookupResults) {
                                return lookupResults.symbol
                                    .getDeclarations()
                                    .find((decl) => decl.type === 1 /* DeclarationType.Variable */);
                            }
                        }
                    }
                }
            }
        }
        return undefined;
    }
    // In general, string nodes don't have any declarations associated with them, but
    // we need to handle the special case of string literals used as keys within a
    // dictionary expression where those keys are associated with a known TypedDict.
    function getDeclarationsForStringNode(node) {
        var _a;
        const declarations = [];
        const expectedType = (_a = getExpectedType(node)) === null || _a === void 0 ? void 0 : _a.type;
        if (expectedType) {
            (0, typeUtils_1.doForEachSubtype)(expectedType, (subtype) => {
                var _a, _b;
                // If the expected type is a TypedDict then the node is either a key expression
                // or a single entry in a set. We then need to check that the value of the node
                // is a valid entry in the TypedDict to avoid resolving declarations for
                // synthesized symbols such as 'get'.
                if ((0, types_1.isClassInstance)(subtype) && types_1.ClassType.isTypedDictClass(subtype)) {
                    const entry = (_a = subtype.details.typedDictEntries) === null || _a === void 0 ? void 0 : _a.knownItems.get(node.value);
                    if (entry) {
                        const symbol = (_b = (0, typeUtils_1.lookUpObjectMember)(subtype, node.value)) === null || _b === void 0 ? void 0 : _b.symbol;
                        if (symbol) {
                            (0, collectionUtils_1.appendArray)(declarations, symbol.getDeclarations());
                        }
                    }
                }
            });
        }
        return declarations.length === 0 ? undefined : declarations;
    }
    function getAliasFromImport(node) {
        if (node.parent &&
            node.parent.nodeType === 26 /* ParseNodeType.ImportFromAs */ &&
            node.parent.alias &&
            node === node.parent.name) {
            return node.parent.alias;
        }
        return undefined;
    }
    function getDeclarationsForNameNode(node, skipUnreachableCode = true) {
        var _a, _b, _c;
        if (skipUnreachableCode && AnalyzerNodeInfo.isCodeUnreachable(node)) {
            return undefined;
        }
        const declarations = [];
        // If the node is part of a "from X import Y as Z" statement and the node
        // is the "Y" (non-aliased) name, we need to look up the alias symbol
        // since the non-aliased name is not in the symbol table.
        const alias = getAliasFromImport(node);
        if (alias) {
            const scope = ScopeUtils.getScopeForNode(node);
            if (scope) {
                // Look up the alias symbol.
                const symbolInScope = scope.lookUpSymbolRecursive(alias.value);
                if (symbolInScope) {
                    // The alias could have more decls that don't refer to this import. Filter
                    // out the one(s) that specifically associated with this import statement.
                    const declsForThisImport = symbolInScope.symbol.getDeclarations().filter((decl) => {
                        return decl.type === 8 /* DeclarationType.Alias */ && decl.node === node.parent;
                    });
                    (0, collectionUtils_1.appendArray)(declarations, (0, declarationUtils_1.getDeclarationsWithUsesLocalNameRemoved)(declsForThisImport));
                }
            }
        }
        else if (node.parent &&
            node.parent.nodeType === 35 /* ParseNodeType.MemberAccess */ &&
            node === node.parent.memberName) {
            let baseType = getType(node.parent.leftExpression);
            if (baseType) {
                baseType = makeTopLevelTypeVarsConcrete(baseType);
                const memberName = node.parent.memberName.value;
                (0, typeUtils_1.doForEachSubtype)(baseType, (subtype) => {
                    let symbol;
                    subtype = makeTopLevelTypeVarsConcrete(subtype);
                    if ((0, types_1.isInstantiableClass)(subtype)) {
                        // Try to find a member that has a declared type. If so, that
                        // overrides any inferred types.
                        let member = (0, typeUtils_1.lookUpClassMember)(subtype, memberName, 64 /* MemberAccessFlags.DeclaredTypesOnly */);
                        if (!member) {
                            member = (0, typeUtils_1.lookUpClassMember)(subtype, memberName);
                        }
                        if (!member) {
                            const metaclass = subtype.details.effectiveMetaclass;
                            if (metaclass && (0, types_1.isInstantiableClass)(metaclass)) {
                                member = (0, typeUtils_1.lookUpClassMember)(metaclass, memberName);
                            }
                        }
                        if (member) {
                            symbol = member.symbol;
                        }
                    }
                    else if ((0, types_1.isClassInstance)(subtype)) {
                        // Try to find a member that has a declared type. If so, that
                        // overrides any inferred types.
                        let member = (0, typeUtils_1.lookUpObjectMember)(subtype, memberName, 64 /* MemberAccessFlags.DeclaredTypesOnly */);
                        if (!member) {
                            member = (0, typeUtils_1.lookUpObjectMember)(subtype, memberName);
                        }
                        if (member) {
                            symbol = member.symbol;
                        }
                    }
                    else if ((0, types_1.isModule)(subtype)) {
                        symbol = types_1.ModuleType.getField(subtype, memberName);
                    }
                    if (symbol) {
                        // By default, report only the declarations that have type annotations.
                        // If there are none, then report all of the unannotated declarations,
                        // which includes every assignment of that symbol.
                        const typedDecls = symbol.getTypedDeclarations();
                        if (typedDecls.length > 0) {
                            (0, collectionUtils_1.appendArray)(declarations, typedDecls);
                        }
                        else {
                            (0, collectionUtils_1.appendArray)(declarations, symbol.getDeclarations());
                        }
                    }
                });
            }
        }
        else if (node.parent && node.parent.nodeType === 37 /* ParseNodeType.ModuleName */) {
            const namePartIndex = node.parent.nameParts.findIndex((part) => part === node);
            const importInfo = AnalyzerNodeInfo.getImportInfo(node.parent);
            if (namePartIndex >= 0 &&
                importInfo &&
                !importInfo.isNativeLib &&
                namePartIndex < importInfo.resolvedUris.length) {
                if (importInfo.resolvedUris[namePartIndex]) {
                    evaluateTypesForStatement(node);
                    // Synthesize an alias declaration for this name part. The only
                    // time this case is used is for IDE services such as
                    // the find all references, hover provider and etc.
                    declarations.push((0, declarationUtils_1.createSynthesizedAliasDeclaration)(importInfo.resolvedUris[namePartIndex]));
                }
            }
        }
        else if (node.parent && node.parent.nodeType === 1 /* ParseNodeType.Argument */ && node === node.parent.name) {
            // The target node is the name in a named argument. We need to determine whether
            // the corresponding named parameter can be determined from the context.
            const argNode = node.parent;
            const paramName = node.value;
            if (((_a = argNode.parent) === null || _a === void 0 ? void 0 : _a.nodeType) === 9 /* ParseNodeType.Call */) {
                const baseType = getType(argNode.parent.leftExpression);
                if (baseType) {
                    if ((0, types_1.isFunction)(baseType) && baseType.details.declaration) {
                        const paramDecl = getDeclarationFromFunctionNamedParameter(baseType, paramName);
                        if (paramDecl) {
                            declarations.push(paramDecl);
                        }
                    }
                    else if ((0, types_1.isOverloadedFunction)(baseType)) {
                        baseType.overloads.forEach((f) => {
                            const paramDecl = getDeclarationFromFunctionNamedParameter(f, paramName);
                            if (paramDecl) {
                                declarations.push(paramDecl);
                            }
                        });
                    }
                    else if ((0, types_1.isInstantiableClass)(baseType)) {
                        const initMethodType = (_b = (0, constructors_1.getBoundInitMethod)(evaluatorInterface, argNode.parent.leftExpression, types_1.ClassType.cloneAsInstance(baseType))) === null || _b === void 0 ? void 0 : _b.type;
                        if (initMethodType && (0, types_1.isFunction)(initMethodType)) {
                            const paramDecl = getDeclarationFromFunctionNamedParameter(initMethodType, paramName);
                            if (paramDecl) {
                                declarations.push(paramDecl);
                            }
                            else if (types_1.ClassType.isDataClass(baseType) || types_1.ClassType.isTypedDictClass(baseType)) {
                                const lookupResults = (0, typeUtils_1.lookUpClassMember)(baseType, paramName);
                                if (lookupResults) {
                                    (0, collectionUtils_1.appendArray)(declarations, lookupResults.symbol.getDeclarations());
                                }
                            }
                        }
                    }
                }
            }
            else if (((_c = argNode.parent) === null || _c === void 0 ? void 0 : _c.nodeType) === 10 /* ParseNodeType.Class */) {
                const classTypeResult = getTypeOfClass(argNode.parent);
                // Validate the init subclass args for this class so we can properly
                // evaluate its custom keyword parameters.
                if (classTypeResult) {
                    validateInitSubclassArgs(argNode.parent, classTypeResult.classType);
                }
            }
        }
        else {
            const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
            // Determine if this node is within a quoted type annotation.
            const isWithinTypeAnnotation = ParseTreeUtils.isWithinTypeAnnotation(node, !(0, analyzerFileInfo_1.isAnnotationEvaluationPostponed)(AnalyzerNodeInfo.getFileInfo(node)));
            // Determine if this is part of a "type" statement.
            const isWithinTypeAliasStatement = !!ParseTreeUtils.getParentNodeOfType(node, 77 /* ParseNodeType.TypeAlias */);
            const allowForwardReferences = isWithinTypeAnnotation || isWithinTypeAliasStatement || fileInfo.isStubFile;
            const symbolWithScope = lookUpSymbolRecursive(node, node.value, !allowForwardReferences, isWithinTypeAnnotation);
            if (symbolWithScope) {
                (0, collectionUtils_1.appendArray)(declarations, symbolWithScope.symbol.getDeclarations());
            }
        }
        return declarations;
    }
    function getTypeForDeclaration(declaration) {
        var _a, _b;
        switch (declaration.type) {
            case 0 /* DeclarationType.Intrinsic */: {
                if (declaration.intrinsicType === 'Any') {
                    return { type: types_1.AnyType.create() };
                }
                if (declaration.intrinsicType === 'type[self]') {
                    const classNode = ParseTreeUtils.getEnclosingClass(declaration.node);
                    const classTypeInfo = getTypeOfClass(classNode);
                    return {
                        type: classTypeInfo
                            ? (0, typeUtils_1.synthesizeTypeVarForSelfCls)(classTypeInfo.classType, /* isClsParam */ true)
                            : types_1.UnknownType.create(),
                    };
                }
                const strType = getBuiltInObject(declaration.node, 'str');
                const intType = getBuiltInObject(declaration.node, 'int');
                if ((0, types_1.isClassInstance)(intType) && (0, types_1.isClassInstance)(strType)) {
                    if (declaration.intrinsicType === 'str') {
                        return { type: strType };
                    }
                    if (declaration.intrinsicType === 'str | None') {
                        return { type: (0, types_1.combineTypes)([strType, getNoneType()]) };
                    }
                    if (declaration.intrinsicType === 'int') {
                        return { type: intType };
                    }
                    if (declaration.intrinsicType === 'Iterable[str]') {
                        const iterableType = getBuiltInType(declaration.node, 'Iterable');
                        if ((0, types_1.isInstantiableClass)(iterableType)) {
                            return {
                                type: types_1.ClassType.cloneAsInstance(types_1.ClassType.cloneForSpecialization(iterableType, [strType], 
                                /* isTypeArgumentExplicit */ true)),
                            };
                        }
                    }
                    if (declaration.intrinsicType === 'Dict[str, Any]') {
                        const dictType = getBuiltInType(declaration.node, 'dict');
                        if ((0, types_1.isInstantiableClass)(dictType)) {
                            return {
                                type: types_1.ClassType.cloneAsInstance(types_1.ClassType.cloneForSpecialization(dictType, [strType, types_1.AnyType.create()], 
                                /* isTypeArgumentExplicit */ true)),
                            };
                        }
                    }
                }
                return { type: types_1.UnknownType.create() };
            }
            case 6 /* DeclarationType.Class */: {
                const classTypeInfo = getTypeOfClass(declaration.node);
                return { type: classTypeInfo === null || classTypeInfo === void 0 ? void 0 : classTypeInfo.decoratedType };
            }
            case 7 /* DeclarationType.SpecialBuiltInClass */: {
                return { type: getTypeOfAnnotation(declaration.node.typeAnnotation) };
            }
            case 5 /* DeclarationType.Function */: {
                const functionTypeInfo = getTypeOfFunction(declaration.node);
                return { type: functionTypeInfo === null || functionTypeInfo === void 0 ? void 0 : functionTypeInfo.decoratedType };
            }
            case 4 /* DeclarationType.TypeAlias */: {
                return { type: getTypeOfTypeAlias(declaration.node) };
            }
            case 2 /* DeclarationType.Parameter */: {
                let typeAnnotationNode = declaration.node.typeAnnotation || declaration.node.typeAnnotationComment;
                // If there wasn't an annotation, see if the parent function
                // has a function-level annotation comment that provides
                // this parameter's annotation type.
                if (!typeAnnotationNode) {
                    if (((_a = declaration.node.parent) === null || _a === void 0 ? void 0 : _a.nodeType) === 31 /* ParseNodeType.Function */) {
                        const functionNode = declaration.node.parent;
                        if (functionNode.functionAnnotationComment &&
                            !functionNode.functionAnnotationComment.isParamListEllipsis) {
                            const paramIndex = functionNode.parameters.findIndex((param) => param === declaration.node);
                            typeAnnotationNode = ParseTreeUtils.getTypeAnnotationForParameter(functionNode, paramIndex);
                        }
                    }
                }
                if (typeAnnotationNode) {
                    const declaredType = getTypeOfParameterAnnotation(typeAnnotationNode, declaration.node.category);
                    return {
                        type: transformVariadicParamType(declaration.node, declaration.node.category, adjustParameterAnnotatedType(declaration.node, declaredType)),
                    };
                }
                return { type: undefined };
            }
            case 3 /* DeclarationType.TypeParameter */: {
                return { type: getTypeOfTypeParameter(declaration.node) };
            }
            case 1 /* DeclarationType.Variable */: {
                const typeAnnotationNode = declaration.typeAnnotationNode;
                if (typeAnnotationNode) {
                    let declaredType;
                    if (declaration.isRuntimeTypeExpression) {
                        declaredType = (0, typeUtils_1.convertToInstance)(getTypeOfExpressionExpectingType(typeAnnotationNode, {
                            allowFinal: true,
                            allowRequired: true,
                        }).type);
                    }
                    else {
                        const declNode = declaration.isDefinedByMemberAccess &&
                            ((_b = declaration.node.parent) === null || _b === void 0 ? void 0 : _b.nodeType) === 35 /* ParseNodeType.MemberAccess */
                            ? declaration.node.parent
                            : declaration.node;
                        declaredType = getTypeOfAnnotation(typeAnnotationNode, {
                            isVariableAnnotation: true,
                            allowClassVar: ParseTreeUtils.isClassVarAllowedForAssignmentTarget(declNode),
                            allowFinal: ParseTreeUtils.isFinalAllowedForAssignmentTarget(declNode),
                            allowRequired: ParseTreeUtils.isRequiredAllowedForAssignmentTarget(declNode),
                        });
                    }
                    if (declaredType) {
                        if ((0, types_1.isClassInstance)(declaredType) && types_1.ClassType.isBuiltIn(declaredType, 'TypeAlias')) {
                            return { type: undefined, isTypeAlias: true };
                        }
                        return { type: declaredType };
                    }
                }
                return { type: undefined };
            }
            case 8 /* DeclarationType.Alias */: {
                return { type: undefined };
            }
        }
    }
    function getTypeOfTypeParameter(node) {
        // Is this type already cached?
        const cachedTypeVarType = readTypeCache(node.name, 0 /* EvalFlags.None */);
        if (cachedTypeVarType && (0, types_1.isTypeVar)(cachedTypeVarType)) {
            return cachedTypeVarType;
        }
        let runtimeClassName = 'TypeVar';
        if (node.typeParamCategory === parseNodes_1.TypeParameterCategory.TypeVarTuple) {
            runtimeClassName = 'TypeVarTuple';
        }
        else if (node.typeParamCategory === parseNodes_1.TypeParameterCategory.ParamSpec) {
            runtimeClassName = 'ParamSpec';
        }
        const runtimeType = getTypingType(node, runtimeClassName);
        const runtimeClass = runtimeType && (0, types_1.isInstantiableClass)(runtimeType) ? runtimeType : undefined;
        let typeVar = types_1.TypeVarType.createInstantiable(node.name.value, node.typeParamCategory === parseNodes_1.TypeParameterCategory.ParamSpec);
        if (runtimeClass) {
            typeVar = types_1.TypeBase.cloneAsSpecialForm(typeVar, types_1.ClassType.cloneAsInstance(runtimeClass));
        }
        typeVar.details.isTypeParamSyntax = true;
        if (node.typeParamCategory === parseNodes_1.TypeParameterCategory.TypeVarTuple) {
            typeVar.details.isVariadic = true;
        }
        // Cache the value before we evaluate the bound or the default type in
        // case it refers to itself in a circular manner.
        writeTypeCache(node, { type: typeVar }, /* flags */ undefined);
        writeTypeCache(node.name, { type: typeVar }, /* flags */ undefined);
        if (node.boundExpression) {
            if (node.boundExpression.nodeType === 52 /* ParseNodeType.Tuple */) {
                const constraints = node.boundExpression.expressions.map((constraint) => {
                    const constraintType = getTypeOfExpressionExpectingType(constraint, {
                        disallowProtocolAndTypedDict: true,
                        allowForwardReference: true,
                    }).type;
                    if ((0, typeUtils_1.requiresSpecialization)(constraintType, {
                        ignorePseudoGeneric: true,
                        ignoreImplicitTypeArgs: true,
                    })) {
                        addError(localize_1.LocMessage.typeVarBoundGeneric(), constraint);
                    }
                    return (0, typeUtils_1.convertToInstance)(constraintType);
                });
                if (constraints.length < 2) {
                    addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.typeVarSingleConstraint(), node.boundExpression);
                }
                else if (node.typeParamCategory === parseNodes_1.TypeParameterCategory.TypeVar) {
                    typeVar.details.constraints = constraints;
                }
            }
            else {
                const boundType = getTypeOfExpressionExpectingType(node.boundExpression, {
                    disallowProtocolAndTypedDict: true,
                    allowForwardReference: true,
                }).type;
                if ((0, typeUtils_1.requiresSpecialization)(boundType, { ignorePseudoGeneric: true })) {
                    addError(localize_1.LocMessage.typeVarConstraintGeneric(), node.boundExpression);
                }
                if (node.typeParamCategory === parseNodes_1.TypeParameterCategory.TypeVar) {
                    typeVar.details.boundType = (0, typeUtils_1.convertToInstance)(boundType);
                }
            }
        }
        if (node.typeParamCategory === parseNodes_1.TypeParameterCategory.ParamSpec) {
            const defaultType = node.defaultExpression
                ? getParamSpecDefaultType(node.defaultExpression, /* isPep695Syntax */ true)
                : undefined;
            if (defaultType) {
                typeVar.details.defaultType = defaultType;
                typeVar.details.isDefaultExplicit = true;
            }
            else {
                typeVar.details.defaultType = (0, typeUtils_1.getUnknownTypeForParamSpec)();
            }
        }
        else if (node.typeParamCategory === parseNodes_1.TypeParameterCategory.TypeVarTuple) {
            const defaultType = node.defaultExpression
                ? getTypeVarTupleDefaultType(node.defaultExpression, /* isPep695Syntax */ true)
                : undefined;
            if (defaultType) {
                typeVar.details.defaultType = defaultType;
                typeVar.details.isDefaultExplicit = true;
            }
            else {
                typeVar.details.defaultType = makeTupleObject([{ type: types_1.UnknownType.create(), isUnbounded: true }]);
            }
        }
        else {
            const defaultType = node.defaultExpression
                ? (0, typeUtils_1.convertToInstance)(getTypeOfExpressionExpectingType(node.defaultExpression, { allowForwardReference: true }).type)
                : undefined;
            if (defaultType) {
                typeVar.details.defaultType = defaultType;
                typeVar.details.isDefaultExplicit = true;
            }
            else {
                typeVar.details.defaultType = types_1.UnknownType.create();
            }
        }
        // If a default is provided, make sure it is compatible with the bound
        // or constraint.
        if (typeVar.details.isDefaultExplicit && node.defaultExpression) {
            verifyTypeVarDefaultIsCompatible(typeVar, node.defaultExpression);
        }
        // Associate the type variable with the owning scope.
        const scopeNode = ParseTreeUtils.getTypeVarScopeNode(node);
        if (scopeNode) {
            let scopeType;
            if (scopeNode.nodeType === 10 /* ParseNodeType.Class */) {
                scopeType = 0 /* TypeVarScopeType.Class */;
                // Set the variance to "auto" for class-scoped TypeVars.
                typeVar.details.declaredVariance = 0 /* Variance.Auto */;
            }
            else if (scopeNode.nodeType === 31 /* ParseNodeType.Function */) {
                scopeType = 1 /* TypeVarScopeType.Function */;
            }
            else {
                (0, debug_1.assert)(scopeNode.nodeType === 77 /* ParseNodeType.TypeAlias */);
                scopeType = 2 /* TypeVarScopeType.TypeAlias */;
            }
            typeVar = types_1.TypeVarType.cloneForScopeId(typeVar, ParseTreeUtils.getScopeIdForNode(scopeNode.nodeType === 77 /* ParseNodeType.TypeAlias */ ? scopeNode.name : scopeNode), scopeNode.name.value, scopeType);
        }
        writeTypeCache(node, { type: typeVar }, /* flags */ undefined);
        writeTypeCache(node.name, { type: typeVar }, /* flags */ undefined);
        return typeVar;
    }
    function getInferredTypeOfDeclaration(symbol, decl) {
        var _a, _b, _c;
        const resolvedDecl = resolveAliasDeclaration(decl, /* resolveLocalNames */ true, {
            allowExternallyHiddenAccess: AnalyzerNodeInfo.getFileInfo(decl.node).isStubFile,
        });
        // We couldn't resolve the alias. Substitute an unknown
        // type in this case.
        if (!resolvedDecl) {
            return evaluatorOptions.evaluateUnknownImportsAsAny ? types_1.AnyType.create() : types_1.UnknownType.create();
        }
        function applyLoaderActionsToModuleType(moduleType, loaderActions, importLookup) {
            if (!loaderActions.uri.isEmpty() && loaderActions.loadSymbolsFromPath) {
                const lookupResults = importLookup(loaderActions.uri);
                if (lookupResults) {
                    moduleType.fields = lookupResults.symbolTable;
                    moduleType.docString = lookupResults.docString;
                }
                else {
                    // Note that all module attributes that are not found in the
                    // symbol table should be treated as Any or Unknown rather than
                    // as an error.
                    moduleType.notPresentFieldType = evaluatorOptions.evaluateUnknownImportsAsAny
                        ? types_1.AnyType.create()
                        : types_1.UnknownType.create();
                }
            }
            if (loaderActions.implicitImports) {
                loaderActions.implicitImports.forEach((implicitImport, name) => {
                    // Recursively apply loader actions.
                    let symbolType;
                    if (implicitImport.isUnresolved) {
                        symbolType = types_1.UnknownType.create();
                    }
                    else {
                        const moduleName = moduleType.moduleName ? moduleType.moduleName + '.' + name : '';
                        const importedModuleType = types_1.ModuleType.create(moduleName, implicitImport.uri);
                        symbolType = applyLoaderActionsToModuleType(importedModuleType, implicitImport, importLookup);
                    }
                    const importedModuleSymbol = symbol_1.Symbol.createWithType(0 /* SymbolFlags.None */, symbolType);
                    moduleType.loaderFields.set(name, importedModuleSymbol);
                });
            }
            return moduleType;
        }
        // If the resolved declaration is still an alias, the alias
        // is pointing at a module, and we need to synthesize a
        // module type.
        if (resolvedDecl.type === 8 /* DeclarationType.Alias */) {
            // Build a module type that corresponds to the declaration and
            // its associated loader actions.
            const moduleType = types_1.ModuleType.create(resolvedDecl.moduleName, resolvedDecl.uri);
            if (resolvedDecl.symbolName && resolvedDecl.submoduleFallback) {
                return applyLoaderActionsToModuleType(moduleType, resolvedDecl.submoduleFallback, importLookup);
            }
            else {
                return applyLoaderActionsToModuleType(moduleType, resolvedDecl, importLookup);
            }
        }
        const declaredType = getTypeForDeclaration(resolvedDecl);
        if (declaredType.type) {
            return declaredType.type;
        }
        // If this is part of a "py.typed" package, don't fall back on type inference
        // unless it's marked Final, is a constant, or is a declared type alias.
        const fileInfo = AnalyzerNodeInfo.getFileInfo(resolvedDecl.node);
        let isUnambiguousType = !fileInfo.isInPyTypedPackage || fileInfo.isStubFile;
        // If this is a py.typed package, determine if this is a case where an unannotated
        // variable is considered "unambiguous" because all type checkers are almost
        // guaranteed to infer its type the same.
        if (!isUnambiguousType) {
            if (resolvedDecl.type === 1 /* DeclarationType.Variable */) {
                // Special-case variables within an enum class. These are effectively
                // constants, so we'll treat them as unambiguous.
                const enclosingClass = ParseTreeUtils.getEnclosingClass(resolvedDecl.node, /* stopAtFunction */ true);
                if (enclosingClass) {
                    const classTypeInfo = getTypeOfClass(enclosingClass);
                    if (classTypeInfo && types_1.ClassType.isEnumClass(classTypeInfo.classType)) {
                        isUnambiguousType = true;
                    }
                }
                // Special-case constants, which are treated as unambiguous.
                if (isFinalVariableDeclaration(resolvedDecl) || resolvedDecl.isConstant) {
                    isUnambiguousType = true;
                }
                // Special-case calls to certain built-in type functions.
                if (((_a = resolvedDecl.inferredTypeSource) === null || _a === void 0 ? void 0 : _a.nodeType) === 9 /* ParseNodeType.Call */) {
                    const baseTypeResult = getTypeOfExpression(resolvedDecl.inferredTypeSource.leftExpression, 2 /* EvalFlags.CallBaseDefaults */);
                    const callType = baseTypeResult.type;
                    const exemptBuiltins = [
                        'TypeVar',
                        'ParamSpec',
                        'TypeVarTuple',
                        'TypedDict',
                        'NamedTuple',
                        'NewType',
                    ];
                    if ((0, types_1.isInstantiableClass)(callType) && types_1.ClassType.isBuiltIn(callType, exemptBuiltins)) {
                        isUnambiguousType = true;
                    }
                    else if ((0, types_1.isFunction)(callType) &&
                        exemptBuiltins.some((name) => callType.details.builtInName === name)) {
                        isUnambiguousType = true;
                    }
                }
            }
        }
        // If the resolved declaration had no defined type, use the
        // inferred type for this node.
        if (resolvedDecl.type === 2 /* DeclarationType.Parameter */) {
            (0, debug_1.assert)(resolvedDecl.node.name !== undefined);
            return (_b = evaluateTypeForSubnode(resolvedDecl.node.name, () => {
                evaluateTypeOfParameter(resolvedDecl.node);
            })) === null || _b === void 0 ? void 0 : _b.type;
        }
        if (resolvedDecl.type === 1 /* DeclarationType.Variable */ && resolvedDecl.inferredTypeSource) {
            const isTypeAlias = isExplicitTypeAliasDeclaration(resolvedDecl) || isPossibleTypeAliasOrTypedDict(resolvedDecl);
            // If this is a type alias, evaluate types for the entire assignment
            // statement rather than just the RHS of the assignment.
            const typeSource = isTypeAlias && resolvedDecl.inferredTypeSource.parent
                ? resolvedDecl.inferredTypeSource.parent
                : resolvedDecl.inferredTypeSource;
            let inferredType = (_c = evaluateTypeForSubnode(resolvedDecl.node, () => {
                evaluateTypesForStatement(typeSource);
            })) === null || _c === void 0 ? void 0 : _c.type;
            if (inferredType && isTypeAlias && resolvedDecl.typeAliasName) {
                // If this was a speculative type alias, it becomes a real type alias only
                // in the event that its inferred type is instantiable or explicitly Any
                // (but not an ellipsis).
                if (isLegalImplicitTypeAliasType(inferredType)) {
                    inferredType = transformTypeForTypeAlias(inferredType, resolvedDecl.typeAliasName, resolvedDecl.node, 
                    /* isPep695Syntax */ false, 
                    /* isPep695TypeVarType */ false);
                    isUnambiguousType = true;
                }
            }
            // Determine whether we need to mark the annotation as ambiguous.
            if (inferredType && fileInfo.isInPyTypedPackage && !fileInfo.isStubFile) {
                if (!isUnambiguousType) {
                    // See if this particular inference can be considered "unambiguous".
                    // Any symbol that is assigned more than once is considered ambiguous.
                    if (isUnambiguousInference(symbol, decl, inferredType)) {
                        isUnambiguousType = true;
                    }
                }
                if (!isUnambiguousType) {
                    inferredType = types_1.TypeBase.cloneForAmbiguousType(inferredType);
                }
            }
            return inferredType;
        }
        return undefined;
    }
    // Applies some heuristics to determine whether it's likely that all Python
    // type checkers will infer the same type.
    function isUnambiguousInference(symbol, decl, inferredType) {
        var _a;
        const nonSlotsDecls = symbol.getDeclarations().filter((decl) => {
            return decl.type !== 1 /* DeclarationType.Variable */ || !decl.isInferenceAllowedInPyTyped;
        });
        // Any symbol with more than one assignment is considered ambiguous.
        if (nonSlotsDecls.length > 1) {
            return false;
        }
        if (decl.type !== 1 /* DeclarationType.Variable */) {
            return false;
        }
        // If there are no non-slots declarations, don't mark the inferred type as ambiguous.
        if (nonSlotsDecls.length === 0) {
            return true;
        }
        // TypeVar definitions don't require a declaration.
        if ((0, types_1.isTypeVar)(inferredType)) {
            return true;
        }
        let assignmentNode;
        const parentNode = decl.node.parent;
        if (parentNode) {
            // Is this a simple assignment (x = y) or an assignment of an instance variable (self.x = y)?
            if (parentNode.nodeType === 3 /* ParseNodeType.Assignment */) {
                assignmentNode = parentNode;
            }
            else if (parentNode.nodeType === 35 /* ParseNodeType.MemberAccess */ &&
                ((_a = parentNode.parent) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* ParseNodeType.Assignment */) {
                assignmentNode = parentNode.parent;
            }
        }
        if (!assignmentNode) {
            return false;
        }
        const assignedType = getTypeOfExpression(assignmentNode.rightExpression).type;
        // Assume that literal values will always result in the same inferred type.
        if ((0, types_1.isClassInstance)(assignedType) && (0, typeUtils_1.isLiteralType)(assignedType)) {
            return true;
        }
        // If the assignment is a simple name corresponding to an unambiguous
        // type, we'll assume the resulting variable will receive the same
        // unambiguous type.
        if (assignmentNode.rightExpression.nodeType === 38 /* ParseNodeType.Name */ && !types_1.TypeBase.isAmbiguous(assignedType)) {
            return true;
        }
        return false;
    }
    // If the specified declaration is an alias declaration that points to a symbol,
    // it resolves the alias and looks up the symbol, then returns the first declaration
    // associated with that symbol. It does this recursively if necessary. If a symbol
    // lookup fails, undefined is returned. If resolveLocalNames is true, the method
    // resolves aliases through local renames ("as" clauses found in import statements).
    function resolveAliasDeclaration(declaration, resolveLocalNames, options) {
        var _a, _b, _c;
        return (_c = (0, declarationUtils_1.resolveAliasDeclaration)(importLookup, declaration, {
            resolveLocalNames,
            allowExternallyHiddenAccess: (_a = options === null || options === void 0 ? void 0 : options.allowExternallyHiddenAccess) !== null && _a !== void 0 ? _a : false,
            skipFileNeededCheck: (_b = options === null || options === void 0 ? void 0 : options.skipFileNeededCheck) !== null && _b !== void 0 ? _b : false,
        })) === null || _c === void 0 ? void 0 : _c.declaration;
    }
    function resolveAliasDeclarationWithInfo(declaration, resolveLocalNames, options) {
        var _a, _b;
        return (0, declarationUtils_1.resolveAliasDeclaration)(importLookup, declaration, {
            resolveLocalNames,
            allowExternallyHiddenAccess: (_a = options === null || options === void 0 ? void 0 : options.allowExternallyHiddenAccess) !== null && _a !== void 0 ? _a : false,
            skipFileNeededCheck: (_b = options === null || options === void 0 ? void 0 : options.skipFileNeededCheck) !== null && _b !== void 0 ? _b : false,
        });
    }
    // Returns the type of the symbol. If the type is explicitly declared, that type
    // is returned. If not, the type is inferred from assignments to the symbol. All
    // assigned types are evaluated and combined into a union.
    function getEffectiveTypeOfSymbol(symbol) {
        return getEffectiveTypeOfSymbolForUsage(symbol).type;
    }
    // If a "usageNode" node is specified, only declarations that are outside
    // of the current execution scope or that are reachable (as determined by
    // code flow analysis) are considered. This helps in cases where there
    // are cyclical dependencies between symbols.
    function getEffectiveTypeOfSymbolForUsage(symbol, usageNode, useLastDecl = false) {
        let declaredTypeInfo;
        // If there's a declared type, it takes precedence over inferred types.
        if (symbol.hasTypedDeclarations()) {
            declaredTypeInfo = getDeclaredTypeOfSymbol(symbol, usageNode);
            const declaredType = declaredTypeInfo === null || declaredTypeInfo === void 0 ? void 0 : declaredTypeInfo.type;
            let isIncomplete = false;
            if (declaredType) {
                if ((0, types_1.isFunction)(declaredType) && types_1.FunctionType.isPartiallyEvaluated(declaredType)) {
                    isIncomplete = true;
                }
                else if ((0, types_1.isClass)(declaredType) && types_1.ClassType.isPartiallyEvaluated(declaredType)) {
                    isIncomplete = true;
                }
            }
            // If the "declared" type uses a "TypeAlias" type annotation, then
            // we need to use the inferred type path to evaluate its type.
            if (declaredType || !declaredTypeInfo.isTypeAlias) {
                const typedDecls = symbol.getTypedDeclarations();
                const result = {
                    type: declaredType !== null && declaredType !== void 0 ? declaredType : types_1.UnknownType.create(),
                    isIncomplete,
                    includesVariableDecl: typedDecls.some((decl) => decl.type === 1 /* DeclarationType.Variable */),
                    includesIllegalTypeAliasDecl: !typedDecls.every((decl) => isPossibleTypeAliasDeclaration(decl)),
                    includesSpeculativeResult: false,
                    isRecursiveDefinition: !declaredType,
                };
                return result;
            }
        }
        return inferTypeOfSymbolForUsage(symbol, usageNode, useLastDecl);
    }
    function inferTypeOfSymbolForUsage(symbol, usageNode, useLastDecl = false) {
        // Look in the inferred type cache to see if we've computed this already.
        let cacheEntries = effectiveTypeCache.get(symbol.id);
        const usageNodeId = usageNode ? usageNode.id : undefined;
        const effectiveTypeCacheKey = `${usageNodeId === undefined ? '.' : usageNodeId.toString()}${useLastDecl ? '*' : ''}`;
        const cacheEntry = cacheEntries === null || cacheEntries === void 0 ? void 0 : cacheEntries.get(effectiveTypeCacheKey);
        if (cacheEntry && !cacheEntry.isIncomplete) {
            return cacheEntry;
        }
        // Infer the type.
        const decls = symbol.getDeclarations();
        let declIndexToConsider;
        // Limit the number of declarations to explore.
        if (decls.length > maxDeclarationsToUseForInference) {
            const result = {
                type: types_1.UnknownType.create(),
                isIncomplete: false,
                includesVariableDecl: false,
                includesIllegalTypeAliasDecl: !decls.every((decl) => isPossibleTypeAliasDeclaration(decl)),
                includesSpeculativeResult: false,
                isRecursiveDefinition: false,
            };
            addToEffectiveTypeCache(result);
            return result;
        }
        // If the caller has requested that we use only the last decl, we
        // will use only the last one, but we'll ignore decls that are in
        // except clauses.
        if (useLastDecl) {
            decls.forEach((decl, index) => {
                if (!decl.isInExceptSuite) {
                    declIndexToConsider = index;
                }
            });
        }
        else {
            // Handle the case where there are multiple imports  one of them in
            // a try block and one or more in except blocks. In this case, we'll
            // use the one in the try block rather than the excepts.
            if (decls.length > 1 && decls.every((decl) => decl.type === 8 /* DeclarationType.Alias */)) {
                const nonExceptDecls = decls.filter((decl) => decl.type === 8 /* DeclarationType.Alias */ && !decl.isInExceptSuite);
                if (nonExceptDecls.length === 1) {
                    declIndexToConsider = decls.findIndex((decl) => decl === nonExceptDecls[0]);
                }
            }
        }
        // Determine which declarations to use for inference.
        const declsToConsider = [];
        let includesVariableDecl = false;
        let includesIllegalTypeAliasDecl = false;
        let sawExplicitTypeAlias = false;
        decls.forEach((decl, index) => {
            var _a, _b, _c;
            const resolvedDecl = (_a = resolveAliasDeclaration(decl, /* resolveLocalNames */ true, {
                allowExternallyHiddenAccess: AnalyzerNodeInfo.getFileInfo(decl.node).isStubFile,
            })) !== null && _a !== void 0 ? _a : decl;
            if (!isPossibleTypeAliasDeclaration(resolvedDecl) && !isExplicitTypeAliasDeclaration(resolvedDecl)) {
                includesIllegalTypeAliasDecl = true;
            }
            if (resolvedDecl.type === 1 /* DeclarationType.Variable */) {
                // Exempt typing.pyi, which uses variables to define some
                // special forms like Any.
                const fileInfo = AnalyzerNodeInfo.getFileInfo(resolvedDecl.node);
                if (!fileInfo.isTypingStubFile) {
                    includesVariableDecl = true;
                }
            }
            if (declIndexToConsider !== undefined && declIndexToConsider !== index) {
                return;
            }
            // If we have already seen an explicit type alias, do not consider
            // additional decls. This can happen if multiple TypeAlias declarations
            // are provided -- normally an error, but it can happen in stdlib stubs
            // if the user sets the pythonPlatform to "All".
            if (sawExplicitTypeAlias) {
                return;
            }
            // If the symbol is explicitly marked as a ClassVar, consider only the
            // declarations that assign to it from within the class body, not through
            // a member access expression.
            if ((0, symbolUtils_1.isEffectivelyClassVar)(symbol, /* isDataclass */ false) &&
                decl.type === 1 /* DeclarationType.Variable */ &&
                decl.isDefinedByMemberAccess) {
                return;
            }
            if (usageNode !== undefined) {
                if (decl.type !== 8 /* DeclarationType.Alias */) {
                    // Is the declaration in the same execution scope as the "usageNode" node?
                    // If so, we can skip it because code flow analysis will allow us
                    // to determine the type in this context.
                    const usageScope = ParseTreeUtils.getExecutionScopeNode(usageNode);
                    const declScope = ParseTreeUtils.getExecutionScopeNode(decl.node);
                    if (usageScope === declScope) {
                        return;
                    }
                }
            }
            const isExplicitTypeAlias = isExplicitTypeAliasDeclaration(resolvedDecl);
            const isTypeAlias = isExplicitTypeAlias || isPossibleTypeAliasOrTypedDict(resolvedDecl);
            if (isExplicitTypeAlias) {
                sawExplicitTypeAlias = true;
            }
            // If this is a type alias, evaluate it outside of the recursive symbol
            // resolution check so we can evaluate the full assignment statement.
            if (isTypeAlias &&
                resolvedDecl.type === 1 /* DeclarationType.Variable */ &&
                ((_c = (_b = resolvedDecl.inferredTypeSource) === null || _b === void 0 ? void 0 : _b.parent) === null || _c === void 0 ? void 0 : _c.nodeType) === 3 /* ParseNodeType.Assignment */) {
                evaluateTypesForAssignmentStatement(resolvedDecl.inferredTypeSource.parent);
            }
            declsToConsider.push(resolvedDecl);
        });
        const result = getTypeOfSymbolForDecls(symbol, declsToConsider, effectiveTypeCacheKey);
        result.includesVariableDecl = includesVariableDecl;
        result.includesIllegalTypeAliasDecl = includesIllegalTypeAliasDecl;
        // Add the result to the effective type cache if it doesn't include speculative results.
        if (!result.includesSpeculativeResult) {
            addToEffectiveTypeCache(result);
        }
        return result;
        function addToEffectiveTypeCache(result) {
            // Add the entry to the cache so we don't need to compute it next time.
            if (!cacheEntries) {
                cacheEntries = new Map();
                effectiveTypeCache.set(symbol.id, cacheEntries);
            }
            cacheEntries.set(effectiveTypeCacheKey, result);
        }
    }
    // Returns the type of a symbol based on a subset of its declarations.
    function getTypeOfSymbolForDecls(symbol, decls, typeCacheKey) {
        var _a, _b;
        const typesToCombine = [];
        let isIncomplete = false;
        let sawPendingEvaluation = false;
        let includesSpeculativeResult = false;
        decls.forEach((decl) => {
            if (pushSymbolResolution(symbol, decl)) {
                try {
                    let type = getInferredTypeOfDeclaration(symbol, decl);
                    if (!popSymbolResolution(symbol)) {
                        isIncomplete = true;
                    }
                    if (type) {
                        if (decl.type === 1 /* DeclarationType.Variable */) {
                            let isConstant = false;
                            if (decl.type === 1 /* DeclarationType.Variable */) {
                                if (decl.isConstant || isFinalVariableDeclaration(decl)) {
                                    isConstant = true;
                                }
                            }
                            // Treat enum values declared within an enum class as though they are const even
                            // though they may not be named as such.
                            if ((0, types_1.isClassInstance)(type) &&
                                types_1.ClassType.isEnumClass(type) &&
                                (0, enums_1.isDeclInEnumClass)(evaluatorInterface, decl)) {
                                isConstant = true;
                            }
                            // If the symbol is constant, we can retain the literal
                            // value. Otherwise, strip literal values to widen the type.
                            if (types_1.TypeBase.isInstance(type) && !isConstant && !isExplicitTypeAliasDeclaration(decl)) {
                                type = stripLiteralValue(type);
                            }
                        }
                        typesToCombine.push(type);
                        if (isSpeculativeModeInUse(decl.node)) {
                            includesSpeculativeResult = true;
                        }
                    }
                    else {
                        isIncomplete = true;
                    }
                }
                catch (e) {
                    // Clean up the stack before rethrowing.
                    popSymbolResolution(symbol);
                    throw e;
                }
            }
            else {
                if (decl.type === 6 /* DeclarationType.Class */) {
                    const classTypeInfo = getTypeOfClass(decl.node);
                    if (classTypeInfo === null || classTypeInfo === void 0 ? void 0 : classTypeInfo.decoratedType) {
                        typesToCombine.push(classTypeInfo.decoratedType);
                    }
                }
                isIncomplete = true;
                // Note that at least one decl could not be evaluated because
                // it was already in the process of being evaluated.
                sawPendingEvaluation = true;
            }
        });
        // How many times have we already attempted to evaluate this declaration already?
        const cacheEntries = effectiveTypeCache.get(symbol.id);
        const evaluationAttempts = ((_b = (_a = cacheEntries === null || cacheEntries === void 0 ? void 0 : cacheEntries.get(typeCacheKey)) === null || _a === void 0 ? void 0 : _a.evaluationAttempts) !== null && _b !== void 0 ? _b : 0) + 1;
        let type;
        if (typesToCombine.length > 0) {
            // Ignore the pending evaluation flag if we've already attempted the
            // type evaluation many times because this probably means there's a
            // cyclical dependency that cannot be broken.
            isIncomplete = sawPendingEvaluation && evaluationAttempts < maxEffectiveTypeEvaluationAttempts;
            type = (0, types_1.combineTypes)(typesToCombine);
        }
        else {
            type = types_1.UnboundType.create();
        }
        return { type, isIncomplete, includesSpeculativeResult, evaluationAttempts };
    }
    // If a declaration has an explicit type (e.g. a variable with an annotation),
    // this function evaluates the type and returns it. If the symbol has no
    // explicit declared type, its type will need to be inferred instead. In some
    // cases, non-type information (such as Final or ClassVar attributes) may be
    // provided, but type inference is still required. In such cases, the attributes
    // are returned as flags.
    function getDeclaredTypeOfSymbol(symbol, usageNode) {
        const synthesizedType = symbol.getSynthesizedType();
        if (synthesizedType) {
            return { type: synthesizedType };
        }
        let typedDecls = symbol.getTypedDeclarations();
        if (typedDecls.length === 0) {
            // If the symbol has no type declaration but is assigned many times,
            // treat it as though it has an explicit type annotation of "Unknown".
            // This will avoid a pathological performance condition for unannotated
            // code that reassigns the same variable hundreds of times. If the symbol
            // effectively has an "Any" annotation, it won't be narrowed.
            if (symbol.getDeclarations().length > maxDeclarationsToUseForInference) {
                return { type: types_1.UnknownType.create() };
            }
            // There was no declaration with a defined type.
            return { type: undefined };
        }
        // If there is more than one typed decl, filter out any that are not
        // reachable from the usage node (if specified). This can happen in
        // cases where a property symbol is redefined to add a setter, deleter,
        // etc.
        if (usageNode && typedDecls.length > 1) {
            const filteredTypedDecls = typedDecls.filter((decl) => {
                if (decl.type !== 8 /* DeclarationType.Alias */) {
                    // Is the declaration in the same execution scope as the "usageNode" node?
                    const usageScope = ParseTreeUtils.getExecutionScopeNode(usageNode);
                    const declScope = ParseTreeUtils.getExecutionScopeNode(decl.node);
                    if (usageScope === declScope) {
                        if (!isFlowPathBetweenNodes(decl.node, usageNode, /* allowSelf */ false)) {
                            return false;
                        }
                    }
                }
                return true;
            });
            if (filteredTypedDecls.length === 0) {
                return { type: types_1.UnboundType.create() };
            }
            typedDecls = filteredTypedDecls;
        }
        // Start with the last decl. If that's already being resolved,
        // use the next-to-last decl, etc. This can happen when resolving
        // property methods. Often the setter method is defined in reference to
        // the initial property, which defines the getter method with the same
        // symbol name.
        let declIndex = typedDecls.length - 1;
        while (declIndex >= 0) {
            const decl = typedDecls[declIndex];
            // If there's a partially-constructed type that is allowed
            // for recursive symbol resolution, return it as the resolved type.
            const partialType = getSymbolResolutionPartialType(symbol, decl);
            if (partialType) {
                return { type: partialType };
            }
            if (getIndexOfSymbolResolution(symbol, decl) < 0) {
                if (pushSymbolResolution(symbol, decl)) {
                    try {
                        const declaredTypeInfo = getTypeForDeclaration(decl);
                        // If there was recursion detected, don't use this declaration.
                        // The exception is it's a class declaration because getTypeOfClass
                        // handles recursion by populating a partially-created class type
                        // in the type cache. This exception is required to handle the
                        // circular dependency between the "type" and "object" classes in
                        // builtins.pyi (since "object" is a "type" and "type" is an "object").
                        if (popSymbolResolution(symbol) || decl.type === 6 /* DeclarationType.Class */) {
                            return declaredTypeInfo;
                        }
                    }
                    catch (e) {
                        // Clean up the stack before rethrowing.
                        popSymbolResolution(symbol);
                        throw e;
                    }
                }
            }
            declIndex--;
        }
        return { type: undefined };
    }
    function inferReturnTypeIfNecessary(type) {
        if ((0, types_1.isFunction)(type)) {
            getFunctionEffectiveReturnType(type);
        }
        else if ((0, types_1.isOverloadedFunction)(type)) {
            type.overloads.forEach((overload) => {
                getFunctionEffectiveReturnType(overload);
            });
        }
    }
    // Returns the return type of the function. If the type is explicitly provided in
    // a type annotation, that type is returned. If not, an attempt is made to infer
    // the return type. If a list of args is provided, the inference logic may take
    // into account argument types to infer the return type.
    function getFunctionEffectiveReturnType(type, callSiteInfo, inferTypeIfNeeded = true) {
        const specializedReturnType = types_1.FunctionType.getEffectiveReturnType(type, /* includeInferred */ false);
        if (specializedReturnType && !(0, types_1.isUnknown)(specializedReturnType)) {
            const liveTypeVarScopes = (callSiteInfo === null || callSiteInfo === void 0 ? void 0 : callSiteInfo.errorNode)
                ? ParseTreeUtils.getTypeVarScopesForNode(callSiteInfo === null || callSiteInfo === void 0 ? void 0 : callSiteInfo.errorNode)
                : [];
            return adjustCallableReturnType(type, specializedReturnType, liveTypeVarScopes);
        }
        if (inferTypeIfNeeded) {
            return getFunctionInferredReturnType(type, callSiteInfo);
        }
        return types_1.UnknownType.create();
    }
    function _getFunctionInferredReturnType(type, callSiteInfo) {
        var _a;
        let returnType;
        let isIncomplete = false;
        const analyzeUnannotatedFunctions = true;
        // Don't attempt to infer the return type for a stub file.
        if (types_1.FunctionType.isStubDefinition(type)) {
            return types_1.UnknownType.create();
        }
        // Don't infer the return type for an overloaded function (unless it's synthesized,
        // which is needed for proper operation of the __get__ method in properties).
        if (types_1.FunctionType.isOverloaded(type) && !types_1.FunctionType.isSynthesizedMethod(type)) {
            return types_1.UnknownType.create();
        }
        // If the return type has already been lazily evaluated,
        // don't bother computing it again.
        if (type.inferredReturnType) {
            returnType = type.inferredReturnType;
        }
        else {
            // Don't bother inferring the return type of __init__ because it's
            // always None.
            if (types_1.FunctionType.isInstanceMethod(type) && type.details.name === '__init__') {
                returnType = getNoneType();
            }
            else if (type.details.declaration) {
                const functionNode = type.details.declaration.node;
                const skipUnannotatedFunction = !AnalyzerNodeInfo.getFileInfo(functionNode).diagnosticRuleSet.analyzeUnannotatedFunctions &&
                    ParseTreeUtils.isUnannotatedFunction(functionNode);
                // Skip return type inference if we are in "skip unannotated function" mode.
                if (!skipUnannotatedFunction && !checkCodeFlowTooComplex(functionNode.suite)) {
                    const codeFlowComplexity = AnalyzerNodeInfo.getCodeFlowComplexity(functionNode);
                    // For very complex functions that have no annotated parameter types,
                    // don't attempt to infer the return type because it can be extremely
                    // expensive.
                    const parametersAreAnnotated = type.details.parameters.length <= 1 ||
                        type.details.parameters.some((param) => param.hasDeclaredType);
                    if (parametersAreAnnotated || codeFlowComplexity < maxReturnTypeInferenceCodeFlowComplexity) {
                        // Temporarily disable speculative mode while we
                        // lazily evaluate the return type.
                        let returnTypeResult;
                        disableSpeculativeMode(() => {
                            returnTypeResult = inferFunctionReturnType(functionNode, types_1.FunctionType.isAbstractMethod(type));
                        });
                        returnType = returnTypeResult === null || returnTypeResult === void 0 ? void 0 : returnTypeResult.type;
                        if (returnTypeResult === null || returnTypeResult === void 0 ? void 0 : returnTypeResult.isIncomplete) {
                            isIncomplete = true;
                        }
                    }
                }
            }
            if (!returnType) {
                returnType = types_1.UnknownType.create();
            }
            // Cache the type for next time.
            if (!isIncomplete) {
                type.inferredReturnType = returnType;
            }
        }
        // If the type is partially unknown and the function has one or more unannotated
        // params, try to analyze the function with the provided argument types and
        // attempt to do a better job at inference.
        if (!isIncomplete &&
            analyzeUnannotatedFunctions &&
            (0, typeUtils_1.isPartlyUnknown)(returnType) &&
            types_1.FunctionType.hasUnannotatedParams(type) &&
            !types_1.FunctionType.isStubDefinition(type) &&
            !types_1.FunctionType.isPyTypedDefinition(type) &&
            callSiteInfo) {
            let hasDecorators = false;
            let isAsync = false;
            const declNode = (_a = type.details.declaration) === null || _a === void 0 ? void 0 : _a.node;
            if (declNode) {
                if (declNode.decorators.length > 0) {
                    hasDecorators = true;
                }
                if (declNode.isAsync) {
                    isAsync = true;
                }
            }
            // We can't use this technique if decorators or async are used because they
            // would need to be applied to the inferred return type.
            if (!hasDecorators && !isAsync) {
                const contextualReturnType = getFunctionInferredReturnTypeUsingArguments(type, callSiteInfo);
                if (contextualReturnType) {
                    returnType = contextualReturnType;
                }
            }
        }
        return returnType;
    }
    function getFunctionInferredReturnTypeUsingArguments(type, callSiteInfo) {
        const args = callSiteInfo.args;
        let contextualReturnType;
        if (!type.details.declaration) {
            return undefined;
        }
        const functionNode = type.details.declaration.node;
        const codeFlowComplexity = AnalyzerNodeInfo.getCodeFlowComplexity(functionNode);
        if (codeFlowComplexity >= maxReturnCallSiteTypeInferenceCodeFlowComplexity) {
            return undefined;
        }
        // If an arg hasn't been matched to a specific named parameter,
        // it's an unpacked value that corresponds to multiple parameters.
        // That's an edge case that we don't handle here.
        if (args.some((arg) => !arg.paramName)) {
            return undefined;
        }
        // Detect recurrence. If a function invokes itself either directly
        // or indirectly, we won't attempt to infer contextual return
        // types any further.
        if (returnTypeInferenceContextStack.some((context) => context.functionNode === functionNode)) {
            return undefined;
        }
        const functionType = getTypeOfFunction(functionNode);
        if (!functionType) {
            return undefined;
        }
        // Very complex functions with many arguments can take a long time to analyze,
        // so we'll use a heuristic and avoiding this inference technique for any
        // call site that involves too many arguments.
        if (args.length > maxReturnTypeInferenceArgumentCount) {
            return undefined;
        }
        // Don't explore arbitrarily deep in the call graph.
        if (returnTypeInferenceContextStack.length >= maxReturnTypeInferenceStackSize) {
            return undefined;
        }
        const paramTypes = [];
        let isResultFromCache = false;
        // If the call is located in a loop, don't use literal argument types
        // for the same reason we don't do literal math in loops.
        const stripLiteralArgTypes = ParseTreeUtils.isWithinLoop(callSiteInfo.errorNode);
        // Suppress diagnostics because we don't want to generate errors.
        suppressDiagnostics(functionNode, () => {
            var _a, _b;
            // Allocate a new temporary type cache for the context of just
            // this function so we can analyze it separately without polluting
            // the main type cache.
            const prevTypeCache = returnTypeInferenceTypeCache;
            returnTypeInferenceContextStack.push({
                functionNode,
                codeFlowAnalyzer: codeFlowEngine.createCodeFlowAnalyzer(),
            });
            try {
                returnTypeInferenceTypeCache = new Map();
                let allArgTypesAreUnknown = true;
                functionNode.parameters.forEach((param, index) => {
                    if (param.name) {
                        let paramType;
                        const arg = args.find((arg) => param.name.value === arg.paramName);
                        if (arg && arg.argument.valueExpression) {
                            paramType = getTypeOfExpression(arg.argument.valueExpression).type;
                            if (!(0, types_1.isUnknown)(paramType)) {
                                allArgTypesAreUnknown = false;
                            }
                        }
                        else if (param.defaultValue) {
                            paramType = getTypeOfExpression(param.defaultValue).type;
                            if (!(0, types_1.isUnknown)(paramType)) {
                                allArgTypesAreUnknown = false;
                            }
                        }
                        else if (index === 0) {
                            // If this is an instance or class method, use the implied
                            // parameter type for the "self" or "cls" parameter.
                            if (types_1.FunctionType.isInstanceMethod(functionType.functionType) ||
                                types_1.FunctionType.isClassMethod(functionType.functionType)) {
                                if (functionType.functionType.details.parameters.length > 0) {
                                    if (functionNode.parameters[0].name) {
                                        paramType = functionType.functionType.details.parameters[0].type;
                                    }
                                }
                            }
                        }
                        if (!paramType) {
                            paramType = types_1.UnknownType.create();
                        }
                        if (stripLiteralArgTypes) {
                            paramType = stripLiteralValue(paramType);
                        }
                        paramTypes.push(paramType);
                        writeTypeCache(param.name, { type: paramType }, 0 /* EvalFlags.None */);
                    }
                });
                // Don't bother trying to determine the contextual return
                // type if none of the argument types are known.
                if (!allArgTypesAreUnknown) {
                    // See if the return type is already cached. If so, skip the
                    // inference step, which is potentially very expensive.
                    const cacheEntry = (_a = functionType.functionType.callSiteReturnTypeCache) === null || _a === void 0 ? void 0 : _a.find((entry) => {
                        return (entry.paramTypes.length === paramTypes.length &&
                            entry.paramTypes.every((t, i) => (0, types_1.isTypeSame)(t, paramTypes[i])));
                    });
                    if (cacheEntry) {
                        contextualReturnType = cacheEntry.returnType;
                        isResultFromCache = true;
                    }
                    else {
                        contextualReturnType = (_b = inferFunctionReturnType(functionNode, types_1.FunctionType.isAbstractMethod(type))) === null || _b === void 0 ? void 0 : _b.type;
                    }
                }
            }
            finally {
                returnTypeInferenceContextStack.pop();
                returnTypeInferenceTypeCache = prevTypeCache;
            }
        });
        if (contextualReturnType) {
            contextualReturnType = (0, types_1.removeUnbound)(contextualReturnType);
            if (!isResultFromCache) {
                // Cache the resulting type.
                if (!functionType.functionType.callSiteReturnTypeCache) {
                    functionType.functionType.callSiteReturnTypeCache = [];
                }
                if (functionType.functionType.callSiteReturnTypeCache.length >= maxCallSiteReturnTypeCacheSize) {
                    functionType.functionType.callSiteReturnTypeCache =
                        functionType.functionType.callSiteReturnTypeCache.slice(1);
                }
                functionType.functionType.callSiteReturnTypeCache.push({
                    paramTypes,
                    returnType: contextualReturnType,
                });
            }
            return contextualReturnType;
        }
        return undefined;
    }
    function getFunctionDeclaredReturnType(node) {
        const functionTypeInfo = getTypeOfFunction(node);
        if (!functionTypeInfo) {
            // We hit a recursive dependency.
            return types_1.AnyType.create();
        }
        // Ignore this check for abstract methods, which often
        // don't actually return any value.
        if (types_1.FunctionType.isAbstractMethod(functionTypeInfo.functionType)) {
            return types_1.AnyType.create();
        }
        if (types_1.FunctionType.isGenerator(functionTypeInfo.functionType)) {
            return (0, typeUtils_1.getDeclaredGeneratorReturnType)(functionTypeInfo.functionType);
        }
        return functionTypeInfo.functionType.details.declaredReturnType;
    }
    function getTypeOfMember(member) {
        if ((0, types_1.isInstantiableClass)(member.classType)) {
            return (0, typeUtils_1.partiallySpecializeType)(getEffectiveTypeOfSymbol(member.symbol), member.classType, 
            /* selfClass */ undefined, typeClass && (0, types_1.isInstantiableClass)(typeClass) ? typeClass : undefined);
        }
        return types_1.UnknownType.create();
    }
    function getTypeOfMemberInternal(errorNode, member, selfClass, flags) {
        if ((0, types_1.isAnyOrUnknown)(member.classType)) {
            return {
                type: member.classType,
                isIncomplete: false,
            };
        }
        if (!(0, types_1.isInstantiableClass)(member.classType)) {
            return undefined;
        }
        const typeResult = getEffectiveTypeOfSymbolForUsage(member.symbol);
        if (!typeResult) {
            return undefined;
        }
        // Report inappropriate use of variables in type expressions.
        if ((flags & 2048 /* MemberAccessFlags.TypeExpression */) !== 0 && errorNode) {
            typeResult.type = validateSymbolIsTypeExpression(errorNode, typeResult.type, !!typeResult.includesVariableDecl);
        }
        // If the type is a function or overloaded function, infer
        // and cache the return type if necessary. This needs to be done
        // prior to specializing.
        inferReturnTypeIfNecessary(typeResult.type);
        // Check for ambiguous accesses to attributes with generic types?
        if (errorNode &&
            selfClass &&
            (0, types_1.isClass)(selfClass) &&
            member.isInstanceMember &&
            (0, types_1.isClass)(member.unspecializedClassType) &&
            (flags & 1024 /* MemberAccessFlags.DisallowGenericInstanceVariableAccess */) !== 0 &&
            (0, typeUtils_1.requiresSpecialization)(typeResult.type, { ignoreSelf: true, ignoreImplicitTypeArgs: true })) {
            const specializedType = (0, typeUtils_1.partiallySpecializeType)(typeResult.type, member.unspecializedClassType, (0, typeUtils_1.selfSpecializeClass)(selfClass, { overrideTypeArgs: true }));
            if ((0, types_1.findSubtype)(specializedType, (subtype) => !(0, types_1.isFunction)(subtype) &&
                !(0, types_1.isOverloadedFunction)(subtype) &&
                (0, typeUtils_1.requiresSpecialization)(subtype, { ignoreSelf: true, ignoreImplicitTypeArgs: true }))) {
                addDiagnostic(diagnosticRules_1.DiagnosticRule.reportGeneralTypeIssues, localize_1.LocMessage.genericInstanceVariableAccess(), errorNode);
            }
        }
        return {
            type: (0, typeUtils_1.partiallySpecializeType)(typeResult.type, member.classType, selfClass),
            isIncomplete: !!typeResult.isIncomplete,
        };
    }
    function assignClass(destType, srcType, diag, destTypeVarContext, srcTypeVarContext, flags, recursionCount, reportErrorsUsingObjType) {
        // If the source or dest types are partially evaluated (i.e. they are in the
        // process of being constructed), assume they are assignable rather than risk
        // emitting false positives.
        if (types_1.ClassType.isHierarchyPartiallyEvaluated(destType) || types_1.ClassType.isHierarchyPartiallyEvaluated(srcType)) {
            return true;
        }
        // Handle typed dicts. They also use a form of structural typing for type
        // checking, as defined in PEP 589.
        if (types_1.ClassType.isTypedDictClass(srcType)) {
            if (types_1.ClassType.isTypedDictClass(destType) && !types_1.ClassType.isSameGenericClass(destType, srcType)) {
                if (!(0, typedDicts_1.assignTypedDictToTypedDict)(evaluatorInterface, destType, srcType, diag, destTypeVarContext, flags, recursionCount)) {
                    return false;
                }
                if (types_1.ClassType.isFinal(destType) !== types_1.ClassType.isFinal(srcType)) {
                    diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.typedDictFinalMismatch().format({
                        sourceType: printType((0, typeUtils_1.convertToInstance)(srcType)),
                        destType: printType((0, typeUtils_1.convertToInstance)(destType)),
                    }));
                    return false;
                }
                // If invariance is being enforced, the two TypedDicts must be assignable to each other.
                if ((flags & 1 /* AssignTypeFlags.EnforceInvariance */) !== 0) {
                    return (0, typedDicts_1.assignTypedDictToTypedDict)(evaluatorInterface, srcType, destType, 
                    /* diag */ undefined, 
                    /* typeVarContext */ undefined, flags, recursionCount);
                }
                return true;
            }
            // Handle some special cases where a TypedDict can act like
            // a Mapping[str, T] or a dict[str, T].
            if (types_1.ClassType.isBuiltIn(destType, 'Mapping')) {
                const mappingValueType = (0, typedDicts_1.getTypedDictMappingEquivalent)(evaluatorInterface, srcType);
                if (mappingValueType &&
                    mappingClass &&
                    (0, types_1.isInstantiableClass)(mappingClass) &&
                    strClass &&
                    (0, types_1.isInstantiableClass)(strClass)) {
                    srcType = types_1.ClassType.cloneForSpecialization(mappingClass, [types_1.ClassType.cloneAsInstance(strClass), mappingValueType], 
                    /* isTypeArgumentExplicit */ true);
                }
            }
            else if (types_1.ClassType.isBuiltIn(destType, ['dict', 'MutableMapping'])) {
                const dictValueType = (0, typedDicts_1.getTypedDictDictEquivalent)(evaluatorInterface, srcType, recursionCount);
                if (dictValueType &&
                    dictClass &&
                    (0, types_1.isInstantiableClass)(dictClass) &&
                    strClass &&
                    (0, types_1.isInstantiableClass)(strClass)) {
                    srcType = types_1.ClassType.cloneForSpecialization(dictClass, [types_1.ClassType.cloneAsInstance(strClass), dictValueType], 
                    /* isTypeArgumentExplicit */ true);
                }
            }
        }
        // Handle special-case type promotions.
        if (destType.includePromotions) {
            const promotionList = typePromotions.get(destType.details.fullName);
            if (promotionList &&
                promotionList.some((srcName) => srcType.details.mro.some((mroClass) => (0, types_1.isClass)(mroClass) && srcName === mroClass.details.fullName))) {
                if ((flags & 1 /* AssignTypeFlags.EnforceInvariance */) === 0) {
                    return true;
                }
            }
        }
        // Is it a structural type (i.e. a protocol)? If so, we need to
        // perform a member-by-member check.
        const inheritanceChain = [];
        const isDerivedFrom = types_1.ClassType.isDerivedFrom(srcType, destType, inheritanceChain);
        // Use the slow path for protocols if the dest doesn't explicitly
        // derive from the source. We also need to use this path if we're
        // testing to see if the metaclass matches the protocol.
        if (types_1.ClassType.isProtocolClass(destType) && !isDerivedFrom) {
            if (!(0, protocols_1.assignClassToProtocol)(evaluatorInterface, destType, types_1.ClassType.cloneAsInstance(srcType), diag === null || diag === void 0 ? void 0 : diag.createAddendum(), destTypeVarContext, srcTypeVarContext, flags, recursionCount)) {
                diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.protocolIncompatible().format({
                    sourceType: printType((0, typeUtils_1.convertToInstance)(srcType)),
                    destType: printType((0, typeUtils_1.convertToInstance)(destType)),
                }));
                return false;
            }
            return true;
        }
        if ((flags & 1 /* AssignTypeFlags.EnforceInvariance */) === 0 || types_1.ClassType.isSameGenericClass(srcType, destType)) {
            if (isDerivedFrom) {
                (0, debug_1.assert)(inheritanceChain.length > 0);
                if (assignClassWithTypeArgs(destType, srcType, inheritanceChain, diag === null || diag === void 0 ? void 0 : diag.createAddendum(), destTypeVarContext, srcTypeVarContext, flags, recursionCount)) {
                    return true;
                }
            }
        }
        // Everything is assignable to an object.
        if (types_1.ClassType.isBuiltIn(destType, 'object')) {
            if ((flags & 1 /* AssignTypeFlags.EnforceInvariance */) === 0) {
                return true;
            }
        }
        if (diag) {
            const destErrorType = reportErrorsUsingObjType ? types_1.ClassType.cloneAsInstance(destType) : destType;
            const srcErrorType = reportErrorsUsingObjType ? types_1.ClassType.cloneAsInstance(srcType) : srcType;
            let destErrorTypeText = printType(destErrorType);
            let srcErrorTypeText = printType(srcErrorType);
            // If the text is the same, use the fully-qualified name rather than the short name.
            if (destErrorTypeText === srcErrorTypeText && destType.details.fullName && srcType.details.fullName) {
                destErrorTypeText = destType.details.fullName;
                srcErrorTypeText = srcType.details.fullName;
            }
            diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.typeIncompatible().format({
                sourceType: srcErrorTypeText,
                destType: destErrorTypeText,
            }));
            // Tell the user about the disableBytesTypePromotions if that is involved.
            if (types_1.ClassType.isBuiltIn(destType, 'bytes')) {
                const promotions = typePromotions.get(destType.details.fullName);
                if (promotions && promotions.some((name) => name === srcType.details.fullName)) {
                    diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.bytesTypePromotions());
                }
            }
        }
        return false;
    }
    // This function is used to validate or infer the variance of type
    // parameters within a class. If ignoreBaseClassVariance is set to false,
    // the type parameters for the base class are honored. This is useful for
    // variance inference (PEP 695). For validation of protocol variance, we
    // want to ignore the variance for all base classes in the class hierarchy.
    function assignClassToSelf(destType, srcType, assumedVariance, ignoreBaseClassVariance = true, recursionCount = 0) {
        (0, debug_1.assert)(types_1.ClassType.isSameGenericClass(destType, srcType));
        (0, debug_1.assert)(destType.details.typeParameters.length > 0);
        const typeVarContext = new typeVarContext_1.TypeVarContext();
        let isAssignable = true;
        // Use a try/catch block here to make sure that we reset
        // the assignClassToSelfClass to undefined if an exception occurs.
        try {
            // Stash the current class type so any references to it are treated
            // as though all TypeParameters are invariant.
            assignClassToSelfStack.push({ class: destType, assumedVariance });
            types_1.ClassType.getSymbolTable(destType).forEach((symbol, name) => {
                if (!isAssignable || symbol.isIgnoredForProtocolMatch()) {
                    return;
                }
                // Constructor methods are exempt from variance calculations.
                if (name === '__new__' || name === '__init__') {
                    return;
                }
                const memberInfo = (0, typeUtils_1.lookUpClassMember)(srcType, name);
                (0, debug_1.assert)(memberInfo !== undefined);
                let destMemberType = getEffectiveTypeOfSymbol(symbol);
                const srcMemberType = getTypeOfMember(memberInfo);
                destMemberType = (0, typeUtils_1.partiallySpecializeType)(destMemberType, destType);
                // Properties require special processing.
                if ((0, types_1.isClassInstance)(destMemberType) &&
                    types_1.ClassType.isPropertyClass(destMemberType) &&
                    (0, types_1.isClassInstance)(srcMemberType) &&
                    types_1.ClassType.isPropertyClass(srcMemberType)) {
                    if (!(0, properties_1.assignProperty)(evaluatorInterface, types_1.ClassType.cloneAsInstantiable(destMemberType), types_1.ClassType.cloneAsInstantiable(srcMemberType), destType, srcType, 
                    /* diag */ undefined, typeVarContext, 
                    /* selfTypeVarContext */ undefined, recursionCount)) {
                        isAssignable = false;
                    }
                }
                else {
                    const primaryDecl = symbol.getDeclarations()[0];
                    let flags = 0 /* AssignTypeFlags.Default */;
                    if ((primaryDecl === null || primaryDecl === void 0 ? void 0 : primaryDecl.type) === 1 /* DeclarationType.Variable */ &&
                        !isFinalVariableDeclaration(primaryDecl) &&
                        !types_1.ClassType.isDataClassFrozen(destType)) {
                        // Class and instance variables that are mutable need to
                        // enforce invariance. We will exempt variables that are
                        // private or protected, since these are presumably
                        // not modifiable outside of the class.
                        if (!(0, symbolNameUtils_1.isPrivateOrProtectedName)(name)) {
                            flags |= 1 /* AssignTypeFlags.EnforceInvariance */;
                        }
                    }
                    if (!assignType(destMemberType, srcMemberType, 
                    /* diag */ undefined, typeVarContext, 
                    /* srcTypeVarContext */ undefined, flags | 65536 /* AssignTypeFlags.IgnoreSelfClsParamCompatibility */, recursionCount)) {
                        isAssignable = false;
                    }
                }
            });
            if (!isAssignable) {
                return false;
            }
            // Now handle generic base classes.
            destType.details.baseClasses.forEach((baseClass) => {
                if ((0, types_1.isInstantiableClass)(baseClass) &&
                    !types_1.ClassType.isBuiltIn(baseClass, 'object') &&
                    !types_1.ClassType.isBuiltIn(baseClass, 'Protocol') &&
                    !types_1.ClassType.isBuiltIn(baseClass, 'Generic') &&
                    baseClass.details.typeParameters.length > 0) {
                    const specializedDestBaseClass = (0, typeUtils_1.specializeForBaseClass)(destType, baseClass);
                    const specializedSrcBaseClass = (0, typeUtils_1.specializeForBaseClass)(srcType, baseClass);
                    if (!ignoreBaseClassVariance) {
                        specializedDestBaseClass.details.typeParameters.forEach((param, index) => {
                            if (!param.details.isParamSpec &&
                                !param.details.isVariadic &&
                                !param.details.isSynthesized &&
                                specializedSrcBaseClass.typeArguments &&
                                index < specializedSrcBaseClass.typeArguments.length &&
                                specializedDestBaseClass.typeArguments &&
                                index < specializedDestBaseClass.typeArguments.length) {
                                const paramVariance = param.details.declaredVariance;
                                if ((0, types_1.isTypeVar)(specializedSrcBaseClass.typeArguments[index])) {
                                    if (paramVariance === 2 /* Variance.Invariant */ ||
                                        paramVariance === 4 /* Variance.Contravariant */) {
                                        isAssignable = false;
                                    }
                                }
                                else if ((0, types_1.isTypeVar)(specializedDestBaseClass.typeArguments[index])) {
                                    if (paramVariance === 2 /* Variance.Invariant */ || paramVariance === 3 /* Variance.Covariant */) {
                                        isAssignable = false;
                                    }
                                }
                            }
                        });
                    }
                    if (isAssignable &&
                        !assignClassToSelf(specializedDestBaseClass, specializedSrcBaseClass, assumedVariance, ignoreBaseClassVariance, recursionCount)) {
                        isAssignable = false;
                    }
                }
            });
            return isAssignable;
        }
        finally {
            assignClassToSelfStack.pop();
        }
    }
    // Adjusts the source and/or dest type arguments list to attempt to match
    // the length of the src type arguments list if the dest or source contain
    // entries with indeterminate length or variadic entries. It returns true
    // if the source is potentially compatible with the dest type, false otherwise.
    function adjustTupleTypeArgs(destTypeArgs, srcTypeArgs, flags) {
        const destUnboundedOrVariadicIndex = destTypeArgs.findIndex((t) => t.isUnbounded || (0, types_1.isVariadicTypeVar)(t.type));
        const srcUnboundedIndex = srcTypeArgs.findIndex((t) => t.isUnbounded);
        const srcVariadicIndex = srcTypeArgs.findIndex((t) => (0, types_1.isVariadicTypeVar)(t.type));
        if (srcUnboundedIndex >= 0) {
            if ((0, types_1.isAnyOrUnknown)(srcTypeArgs[srcUnboundedIndex].type)) {
                // If the source contains an unbounded Any, expand it to match the dest length.
                const typeToReplicate = srcTypeArgs.length > 0 ? srcTypeArgs[srcUnboundedIndex].type : types_1.AnyType.create();
                while (srcTypeArgs.length < destTypeArgs.length) {
                    srcTypeArgs.splice(srcUnboundedIndex, 0, { type: typeToReplicate, isUnbounded: true });
                }
                if (srcTypeArgs.length > destTypeArgs.length) {
                    srcTypeArgs.splice(srcUnboundedIndex, 1);
                }
            }
            else if (destUnboundedOrVariadicIndex < 0) {
                // If the source contains an unbounded type but the dest does not, it's incompatible.
                return false;
            }
        }
        // If the dest contains an unbounded Any, expand it to match the source length.
        if (destUnboundedOrVariadicIndex >= 0 &&
            destTypeArgs[destUnboundedOrVariadicIndex].isUnbounded &&
            (0, types_1.isAnyOrUnknown)(destTypeArgs[destUnboundedOrVariadicIndex].type)) {
            while (destTypeArgs.length < srcTypeArgs.length) {
                destTypeArgs.splice(destUnboundedOrVariadicIndex, 0, destTypeArgs[destUnboundedOrVariadicIndex]);
            }
        }
        // Remove any optional parameters from the end of the two lists until the lengths match.
        while (srcTypeArgs.length > destTypeArgs.length && srcTypeArgs[srcTypeArgs.length - 1].isOptional) {
            srcTypeArgs.splice(srcTypeArgs.length - 1, 1);
        }
        while (destTypeArgs.length > srcTypeArgs.length && destTypeArgs[destTypeArgs.length - 1].isOptional) {
            destTypeArgs.splice(destTypeArgs.length - 1, 1);
        }
        const srcArgsToCapture = srcTypeArgs.length - destTypeArgs.length + 1;
        let skipAdjustSrc = false;
        // If we're doing reverse type mappings and the source contains a variadic
        // TypeVar, we need to adjust the dest so the reverse type mapping assignment
        // can be performed.
        if ((flags & 2 /* AssignTypeFlags.ReverseTypeVarMatching */) !== 0) {
            const destArgsToCapture = destTypeArgs.length - srcTypeArgs.length + 1;
            if (srcVariadicIndex >= 0 && destArgsToCapture >= 0) {
                // If the only removed arg from the dest type args is itself a variadic,
                // don't bother adjusting it.
                const skipAdjustment = destArgsToCapture === 1 && (0, types_1.isVariadicTypeVar)(destTypeArgs[srcVariadicIndex].type);
                if (!skipAdjustment && tupleClass && (0, types_1.isInstantiableClass)(tupleClass)) {
                    const removedArgs = destTypeArgs.splice(srcVariadicIndex, destArgsToCapture);
                    // Package up the remaining type arguments into a tuple object.
                    const variadicTuple = makeTupleObject(removedArgs.map((typeArg) => {
                        return {
                            type: typeArg.type,
                            isUnbounded: typeArg.isUnbounded,
                            isOptional: typeArg.isOptional,
                        };
                    }), 
                    /* isUnpackedTuple */ true);
                    destTypeArgs.splice(srcVariadicIndex, 0, {
                        type: variadicTuple,
                        isUnbounded: false,
                    });
                }
                skipAdjustSrc = true;
            }
        }
        else {
            if (destUnboundedOrVariadicIndex >= 0 && srcArgsToCapture >= 0) {
                // If the dest contains a variadic element, determine which source
                // args map to this element and package them up into an unpacked tuple.
                if ((0, types_1.isVariadicTypeVar)(destTypeArgs[destUnboundedOrVariadicIndex].type)) {
                    if (tupleClass && (0, types_1.isInstantiableClass)(tupleClass)) {
                        const removedArgs = srcTypeArgs.splice(destUnboundedOrVariadicIndex, srcArgsToCapture);
                        let variadicTuple;
                        // If we're left with a single unpacked variadic type var, there's no
                        // need to wrap it in a nested tuple.
                        if (removedArgs.length === 1 && (0, types_1.isUnpackedVariadicTypeVar)(removedArgs[0].type)) {
                            variadicTuple = removedArgs[0].type;
                        }
                        else {
                            // Package up the remaining type arguments into a tuple object.
                            variadicTuple = makeTupleObject(removedArgs.map((typeArg) => {
                                return {
                                    type: typeArg.type,
                                    isUnbounded: typeArg.isUnbounded,
                                    isOptional: typeArg.isOptional,
                                };
                            }), 
                            /* isUnpackedTuple */ true);
                        }
                        srcTypeArgs.splice(destUnboundedOrVariadicIndex, 0, {
                            type: variadicTuple,
                            isUnbounded: false,
                        });
                    }
                    skipAdjustSrc = true;
                }
            }
        }
        if (!skipAdjustSrc && destUnboundedOrVariadicIndex >= 0 && srcArgsToCapture >= 0) {
            // If possible, package up the source entries that correspond to
            // the dest unbounded tuple. This isn't possible if the source contains
            // an unbounded tuple outside of this range.
            if (srcUnboundedIndex < 0 ||
                (srcUnboundedIndex >= destUnboundedOrVariadicIndex &&
                    srcUnboundedIndex < destUnboundedOrVariadicIndex + srcArgsToCapture)) {
                const removedArgTypes = srcTypeArgs.splice(destUnboundedOrVariadicIndex, srcArgsToCapture).map((t) => {
                    if ((0, types_1.isTypeVar)(t.type) && (0, types_1.isUnpackedVariadicTypeVar)(t.type) && !t.type.isVariadicInUnion) {
                        return types_1.TypeVarType.cloneForUnpacked(t.type, /* isInUnion */ true);
                    }
                    return t.type;
                });
                srcTypeArgs.splice(destUnboundedOrVariadicIndex, 0, {
                    type: removedArgTypes.length > 0 ? (0, types_1.combineTypes)(removedArgTypes) : types_1.AnyType.create(),
                    isUnbounded: false,
                });
            }
        }
        return destTypeArgs.length === srcTypeArgs.length;
    }
    function assignTupleTypeArguments(destType, srcType, diag, destTypeVarContext, srcTypeVarContext, flags, recursionCount) {
        var _a, _b;
        const destTypeArgs = [...((_a = destType.tupleTypeArguments) !== null && _a !== void 0 ? _a : [])];
        const srcTypeArgs = [...((_b = srcType.tupleTypeArguments) !== null && _b !== void 0 ? _b : [])];
        if (adjustTupleTypeArgs(destTypeArgs, srcTypeArgs, flags)) {
            for (let argIndex = 0; argIndex < srcTypeArgs.length; argIndex++) {
                const entryDiag = diag === null || diag === void 0 ? void 0 : diag.createAddendum();
                if (!assignType(destTypeArgs[argIndex].type, srcTypeArgs[argIndex].type, entryDiag === null || entryDiag === void 0 ? void 0 : entryDiag.createAddendum(), destTypeVarContext, srcTypeVarContext, flags, recursionCount)) {
                    if (entryDiag) {
                        entryDiag.addMessage(localize_1.LocAddendum.tupleEntryTypeMismatch().format({
                            entry: argIndex + 1,
                        }));
                    }
                    return false;
                }
            }
        }
        else {
            const isDestIndeterminate = destTypeArgs.some((t) => t.isUnbounded || (0, types_1.isVariadicTypeVar)(t.type));
            if (srcTypeArgs.some((t) => t.isUnbounded || (0, types_1.isVariadicTypeVar)(t.type))) {
                if (isDestIndeterminate) {
                    diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.tupleSizeIndeterminateSrcDest().format({
                        expected: destTypeArgs.length - 1,
                    }));
                }
                else {
                    diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.tupleSizeIndeterminateSrc().format({
                        expected: destTypeArgs.length,
                    }));
                }
            }
            else {
                if (isDestIndeterminate) {
                    diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.tupleSizeMismatchIndeterminateDest().format({
                        expected: destTypeArgs.length - 1,
                        received: srcTypeArgs.length,
                    }));
                }
                else {
                    diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.tupleSizeMismatch().format({
                        expected: destTypeArgs.length,
                        received: srcTypeArgs.length,
                    }));
                }
            }
            return false;
        }
        return true;
    }
    // Determines whether the specified type can be assigned to the
    // specified inheritance chain, taking into account its type arguments.
    function assignClassWithTypeArgs(destType, srcType, inheritanceChain, diag, destTypeVarContext, srcTypeVarContext, flags, recursionCount) {
        let curSrcType = srcType;
        let prevSrcType;
        inferTypeParameterVarianceForClass(destType);
        // If we're enforcing invariance, literal types must match.
        if ((flags & 1 /* AssignTypeFlags.EnforceInvariance */) !== 0) {
            const srcIsLiteral = srcType.literalValue !== undefined;
            const destIsLiteral = destType.literalValue !== undefined;
            if (srcIsLiteral !== destIsLiteral) {
                return false;
            }
        }
        else {
            // If the dest is an 'object', it's assignable.
            if (types_1.ClassType.isBuiltIn(destType, 'object')) {
                return true;
            }
        }
        for (let ancestorIndex = inheritanceChain.length - 1; ancestorIndex >= 0; ancestorIndex--) {
            const ancestorType = inheritanceChain[ancestorIndex];
            // If we've hit an "unknown", all bets are off, and we need to assume
            // that the type is assignable. If the destType is marked "@final",
            // we should be able to assume that it's not assignable, but we can't do
            // this in the general case because it breaks assumptions with the
            // NotImplemented symbol exported by typeshed's builtins.pyi. Instead,
            // we'll special-case only None.
            if ((0, types_1.isUnknown)(ancestorType)) {
                return !(0, typeUtils_1.isNoneTypeClass)(destType);
            }
            // If this isn't the first time through the loop, specialize
            // for the next ancestor in the chain.
            if (ancestorIndex < inheritanceChain.length - 1) {
                // If the curSrcType is a NamedTuple and the ancestorType is a tuple,
                // we need to handle this as a special case because the NamedTuple may
                // include typeParams from its parent class.
                let effectiveCurSrcType = curSrcType;
                if (types_1.ClassType.isBuiltIn(curSrcType, 'NamedTuple') &&
                    types_1.ClassType.isBuiltIn(ancestorType, 'tuple') &&
                    prevSrcType) {
                    effectiveCurSrcType = prevSrcType;
                }
                curSrcType = (0, typeUtils_1.specializeForBaseClass)(effectiveCurSrcType, ancestorType);
            }
            // If there are no type parameters on this class, we're done.
            const ancestorTypeParams = types_1.ClassType.getTypeParameters(ancestorType);
            if (ancestorTypeParams.length === 0) {
                continue;
            }
            // If the dest type isn't specialized, there are no type args to validate.
            if (!ancestorType.typeArguments) {
                return true;
            }
            prevSrcType = curSrcType;
        }
        // If we're enforcing invariance, literal types must match as well.
        if ((flags & 1 /* AssignTypeFlags.EnforceInvariance */) !== 0) {
            const srcIsLiteral = srcType.literalValue !== undefined;
            const destIsLiteral = destType.literalValue !== undefined;
            if (srcIsLiteral !== destIsLiteral) {
                return false;
            }
        }
        // Handle tuple, which supports a variable number of type arguments.
        if (destType.tupleTypeArguments && curSrcType.tupleTypeArguments) {
            return assignTupleTypeArguments(destType, curSrcType, diag, destTypeVarContext, srcTypeVarContext, flags, recursionCount);
        }
        if (destType.typeArguments) {
            // If the dest type is specialized, make sure the specialized source
            // type arguments are assignable to the dest type arguments.
            return assignTypeArguments(destType, curSrcType, 
            // Don't emit a diag addendum if we're in an invariant context. It's
            // sufficient to simply indicate that the types are not the same
            // in this case. Adding more information is unnecessary and confusing.
            (flags & 1 /* AssignTypeFlags.EnforceInvariance */) === 0 ? diag : undefined, destTypeVarContext, srcTypeVarContext, flags, recursionCount);
        }
        if (destTypeVarContext && curSrcType.typeArguments && !destTypeVarContext.isLocked()) {
            // Populate the typeVar map with type arguments of the source.
            const srcTypeArgs = curSrcType.typeArguments;
            for (let i = 0; i < destType.details.typeParameters.length; i++) {
                const typeArgType = i < srcTypeArgs.length ? srcTypeArgs[i] : types_1.UnknownType.create();
                const typeParam = destType.details.typeParameters[i];
                const variance = types_1.TypeVarType.getVariance(typeParam);
                (0, constraintSolver_1.updateTypeVarType)(evaluatorInterface, destTypeVarContext, typeParam, variance !== 4 /* Variance.Contravariant */ ? typeArgType : undefined, variance !== 3 /* Variance.Covariant */ ? typeArgType : undefined, 
                /* tupleTypes */ curSrcType.tupleTypeArguments, 
                /* forceRetainLiterals */ true);
            }
        }
        return true;
    }
    function getGetterTypeFromProperty(propertyClass, inferTypeIfNeeded) {
        if (!types_1.ClassType.isPropertyClass(propertyClass)) {
            return undefined;
        }
        if (propertyClass.fgetInfo) {
            return getFunctionEffectiveReturnType(propertyClass.fgetInfo.methodType, 
            /* args */ undefined, inferTypeIfNeeded);
        }
        return undefined;
    }
    function assignTypeArguments(destType, srcType, diag, destTypeVarContext, srcTypeVarContext, flags, recursionCount) {
        var _a, _b, _c;
        (0, debug_1.assert)(types_1.ClassType.isSameGenericClass(destType, srcType));
        inferTypeParameterVarianceForClass(destType);
        const destTypeParams = types_1.ClassType.getTypeParameters(destType);
        let destTypeArgs;
        let srcTypeArgs;
        // Are we performing protocol variance validation for this class? If so,
        // treat all of the type parameters as invariant even if they are declared
        // otherwise.
        const assignClassToSelfInfo = assignClassToSelfStack.find((info) => types_1.ClassType.isSameGenericClass(info.class, destType));
        const assumedVariance = assignClassToSelfInfo === null || assignClassToSelfInfo === void 0 ? void 0 : assignClassToSelfInfo.assumedVariance;
        // If either source or dest type arguments are missing, they are
        // treated as "Any", so they are assumed to be assignable.
        if (!destType.typeArguments || !srcType.typeArguments) {
            return true;
        }
        if (types_1.ClassType.isTupleClass(destType)) {
            destTypeArgs = (_b = (_a = destType.tupleTypeArguments) === null || _a === void 0 ? void 0 : _a.map((t) => t.type)) !== null && _b !== void 0 ? _b : [];
            srcTypeArgs = (_c = srcType.tupleTypeArguments) === null || _c === void 0 ? void 0 : _c.map((t) => t.type);
        }
        else {
            destTypeArgs = destType.typeArguments;
            srcTypeArgs = srcType.typeArguments;
        }
        let isCompatible = true;
        srcTypeArgs === null || srcTypeArgs === void 0 ? void 0 : srcTypeArgs.forEach((srcTypeArg, srcArgIndex) => {
            // In most cases, the number of type args should match the number
            // of type arguments, but there are a few special cases where this
            // isn't true (e.g. assigning a Tuple[X, Y, Z] to a tuple[W]).
            const destArgIndex = srcArgIndex >= destTypeArgs.length ? destTypeArgs.length - 1 : srcArgIndex;
            const destTypeArg = destArgIndex >= 0 ? destTypeArgs[destArgIndex] : types_1.UnknownType.create();
            const destTypeParam = destArgIndex < destTypeParams.length ? destTypeParams[destArgIndex] : undefined;
            const assignmentDiag = new diagnostic_1.DiagnosticAddendum();
            const variance = assumedVariance !== null && assumedVariance !== void 0 ? assumedVariance : (destTypeParam ? types_1.TypeVarType.getVariance(destTypeParam) : 3 /* Variance.Covariant */);
            let effectiveFlags;
            let errorSource;
            let includeDiagAddendum = true;
            if (variance === 3 /* Variance.Covariant */) {
                effectiveFlags = flags | 256 /* AssignTypeFlags.RetainLiteralsForTypeVar */;
                errorSource = localize_1.LocAddendum.typeVarIsCovariant;
            }
            else if (variance === 4 /* Variance.Contravariant */) {
                effectiveFlags =
                    (flags ^ 2 /* AssignTypeFlags.ReverseTypeVarMatching */) | 256 /* AssignTypeFlags.RetainLiteralsForTypeVar */;
                errorSource = localize_1.LocAddendum.typeVarIsContravariant;
            }
            else {
                effectiveFlags = flags | 1 /* AssignTypeFlags.EnforceInvariance */ | 256 /* AssignTypeFlags.RetainLiteralsForTypeVar */;
                errorSource = localize_1.LocAddendum.typeVarIsInvariant;
                // Omit the diagnostic addendum for the invariant case because it's obvious
                // why two types are not the same.
                includeDiagAddendum = false;
            }
            if (!assignType(variance === 4 /* Variance.Contravariant */ ? srcTypeArg : destTypeArg, variance === 4 /* Variance.Contravariant */ ? destTypeArg : srcTypeArg, assignmentDiag, variance === 4 /* Variance.Contravariant */ ? srcTypeVarContext : destTypeVarContext, variance === 4 /* Variance.Contravariant */ ? destTypeVarContext : srcTypeVarContext, effectiveFlags, recursionCount)) {
                // Don't report errors with type variables in "pseudo-random"
                // classes since these type variables are not real.
                if (!types_1.ClassType.isPseudoGenericClass(destType)) {
                    if (diag) {
                        if (destTypeParam) {
                            const childDiag = diag.createAddendum();
                            childDiag.addMessage(errorSource().format({
                                name: types_1.TypeVarType.getReadableName(destTypeParam),
                                ...printSrcDestTypes(srcTypeArg, destTypeArg),
                            }));
                            if (includeDiagAddendum) {
                                childDiag.addAddendum(assignmentDiag);
                            }
                            if (isCompatible && types_1.ClassType.isSameGenericClass(destType, srcType)) {
                                // Add additional notes to help the user if this is a common type mismatch.
                                if (types_1.ClassType.isBuiltIn(destType, 'dict') && srcArgIndex === 1) {
                                    childDiag.addMessage(localize_1.LocAddendum.invariantSuggestionDict());
                                }
                                else if (types_1.ClassType.isBuiltIn(destType, 'list')) {
                                    childDiag.addMessage(localize_1.LocAddendum.invariantSuggestionList());
                                }
                                else if (types_1.ClassType.isBuiltIn(destType, 'set')) {
                                    childDiag.addMessage(localize_1.LocAddendum.invariantSuggestionSet());
                                }
                            }
                        }
                        else {
                            diag.addAddendum(assignmentDiag);
                        }
                    }
                    isCompatible = false;
                }
            }
        });
        return isCompatible;
    }
    // Determines if the source type can be assigned to the dest type.
    // If typeVarContext is provided, type variables within the destType are
    // matched against existing type variables in the map. If a type variable
    // in the dest type is not in the type map already, it is assigned a type
    // and added to the map.
    function assignType(destType, srcType, diag, destTypeVarContext, srcTypeVarContext, flags = 0 /* AssignTypeFlags.Default */, recursionCount = 0) {
        var _a, _b, _c;
        // Handle the case where the dest and src types are the same object.
        // We can normally shortcut this and say that they are compatible,
        // but if the type includes TypeVars, we need to go through
        // the rest of the logic.
        if (destType === srcType && !(0, typeUtils_1.requiresSpecialization)(destType)) {
            return true;
        }
        // If the source type is a special form, use the literal special form
        // class rather than the symbolic form.
        if (srcType.specialForm) {
            let isSpecialFormExempt = false;
            // A few special forms that are normally not compatible with type[T]
            // are compatible specifically in the context of isinstance and issubclass.
            if ((flags & 32768 /* AssignTypeFlags.AllowIsinstanceSpecialForms */) !== 0) {
                if (types_1.ClassType.isBuiltIn(srcType.specialForm, ['Callable', 'UnionType', 'Generic'])) {
                    isSpecialFormExempt = true;
                }
            }
            if (!isSpecialFormExempt) {
                srcType = srcType.specialForm;
            }
        }
        if (recursionCount > types_1.maxTypeRecursionCount) {
            return true;
        }
        recursionCount++;
        // If the source and dest refer to the recursive type aliases, handle
        // the case specially to avoid recursing down both type aliases.
        if ((0, types_1.isTypeVar)(destType) &&
            destType.details.recursiveTypeAliasScopeId &&
            (0, types_1.isTypeVar)(srcType) &&
            srcType.details.recursiveTypeAliasScopeId) {
            // Do the source and dest refer to the same recursive type alias?
            if (((_a = destType.typeAliasInfo) === null || _a === void 0 ? void 0 : _a.typeArguments) &&
                ((_b = srcType.typeAliasInfo) === null || _b === void 0 ? void 0 : _b.typeArguments) &&
                destType.details.recursiveTypeAliasScopeId === srcType.details.recursiveTypeAliasScopeId) {
                let isAssignable = true;
                const srcTypeArgs = srcType.typeAliasInfo.typeArguments;
                destType.typeAliasInfo.typeArguments.forEach((destTypeArg, index) => {
                    const srcTypeArg = index < srcTypeArgs.length ? srcTypeArgs[index] : types_1.UnknownType.create();
                    if (!assignType(destTypeArg, srcTypeArg, diag, destTypeVarContext, srcTypeVarContext, flags, recursionCount)) {
                        isAssignable = false;
                    }
                });
                return isAssignable;
            }
            else {
                // Have we already recursed once?
                if ((flags & 4 /* AssignTypeFlags.SkipRecursiveTypeCheck */) !== 0) {
                    return true;
                }
                // Note that we are comparing two recursive types and do
                // not recursive more than once.
                flags |= 4 /* AssignTypeFlags.SkipRecursiveTypeCheck */;
            }
        }
        // Transform recursive type aliases if necessary.
        const transformedDestType = (0, typeUtils_1.transformPossibleRecursiveTypeAlias)(destType);
        const transformedSrcType = (0, typeUtils_1.transformPossibleRecursiveTypeAlias)(srcType);
        // Did either the source or dest include recursive type aliases?
        // If so, we could be dealing with different recursive type aliases
        // or a recursive type alias and a recursive protocol definition.
        if ((transformedDestType !== destType && (0, types_1.isUnion)(transformedDestType)) ||
            (transformedSrcType !== srcType && (0, types_1.isUnion)(transformedSrcType))) {
            // Use a smaller recursive limit in this case to prevent runaway recursion.
            if (recursionCount > maxRecursiveTypeAliasRecursionCount) {
                // Add a special case for when the source is a str, which is itself
                // a recursive type (since it derives from Sequence[str]).
                if ((0, types_1.isClassInstance)(srcType) && types_1.ClassType.isBuiltIn(srcType, 'str') && (0, types_1.isUnion)(transformedDestType)) {
                    return transformedDestType.subtypes.some((subtype) => (0, types_1.isClassInstance)(subtype) && types_1.ClassType.isBuiltIn(subtype, ['object', 'str']));
                }
                return true;
            }
        }
        destType = transformedDestType;
        srcType = transformedSrcType;
        // If the source or dest is unbound, allow the assignment. The
        // error will be reported elsewhere.
        if ((0, types_1.isUnbound)(destType) || (0, types_1.isUnbound)(srcType)) {
            return true;
        }
        // If we're in "overload overlap" mode, convert top-level type variables
        // to their concrete forms in the source.
        if ((flags & 16 /* AssignTypeFlags.OverloadOverlapCheck */) !== 0) {
            srcType = makeTopLevelTypeVarsConcrete(srcType);
        }
        // Strip flags we don't want to propagate to other calls.
        const originalFlags = flags;
        flags &= ~128 /* AssignTypeFlags.AllowBoolTypeGuard */;
        // Before performing any other checks, see if the dest type is a
        // TypeVar that we are attempting to match.
        if ((0, types_1.isTypeVar)(destType)) {
            if ((0, typeUtils_1.isTypeVarSame)(destType, srcType)) {
                if (destType.scopeId && (destTypeVarContext === null || destTypeVarContext === void 0 ? void 0 : destTypeVarContext.hasSolveForScope(destType.scopeId))) {
                    // If the dest TypeVar has no current value bound to it, bind itself.
                    if (!destTypeVarContext.getPrimarySignature().getTypeVar(destType)) {
                        return (0, constraintSolver_1.assignTypeToTypeVar)(evaluatorInterface, destType, srcType, diag, destTypeVarContext, flags, recursionCount);
                    }
                }
                return true;
            }
            // If the dest is a constrained or bound type variable and all of the
            // types in the source are conditioned on that same type variable
            // and have compatible types, we'll consider it assignable.
            if (assignConditionalTypeToTypeVar(destType, srcType, recursionCount)) {
                return true;
            }
            // If the source is a conditional type associated with a bound TypeVar
            // and the bound TypeVar matches the condition, the types are compatible.
            const destTypeVar = destType;
            if (types_1.TypeBase.isInstantiable(destType) === types_1.TypeBase.isInstantiable(srcType) &&
                srcType.condition &&
                srcType.condition.some((cond) => {
                    return (cond.typeVar.details.constraints.length === 0 &&
                        cond.typeVar.nameWithScope === destTypeVar.nameWithScope);
                })) {
                return true;
            }
            if ((0, types_1.isUnion)(srcType)) {
                const srcWithoutAny = (0, types_1.removeFromUnion)(srcType, (type) => (0, types_1.isAnyOrUnknown)(type));
                if ((0, types_1.isTypeSame)(destType, srcWithoutAny)) {
                    return true;
                }
            }
            // Handle the special case where both types are Self types. We'll allow
            // them to be treated as equivalent to handle certain common idioms.
            if ((0, types_1.isTypeVar)(srcType) &&
                srcType.details.isSynthesizedSelf &&
                srcType.details.boundType &&
                destType.details.isSynthesizedSelf &&
                destType.details.boundType &&
                types_1.TypeBase.isInstance(srcType) === types_1.TypeBase.isInstance(destType)) {
                if ((flags & 2 /* AssignTypeFlags.ReverseTypeVarMatching */) === 0 && destTypeVarContext) {
                    (0, constraintSolver_1.assignTypeToTypeVar)(evaluatorInterface, destType, srcType, diag, destTypeVarContext, originalFlags, recursionCount);
                }
                return true;
            }
            // If the dest is a variadic type variable, and the source is a tuple
            // with a single entry that is the same variadic type variable, it's a match.
            if ((0, types_1.isVariadicTypeVar)(destType) &&
                (0, types_1.isClassInstance)(srcType) &&
                (0, typeUtils_1.isTupleClass)(srcType) &&
                srcType.tupleTypeArguments &&
                srcType.tupleTypeArguments.length === 1) {
                if ((0, types_1.isTypeSame)(destType, srcType.tupleTypeArguments[0].type, {}, recursionCount)) {
                    return true;
                }
            }
            if ((flags & 2 /* AssignTypeFlags.ReverseTypeVarMatching */) === 0 || !(0, types_1.isTypeVar)(srcType)) {
                const targetTypeVarContext = (flags & 2 /* AssignTypeFlags.ReverseTypeVarMatching */) === 0 ? destTypeVarContext : srcTypeVarContext;
                if (!(0, constraintSolver_1.assignTypeToTypeVar)(evaluatorInterface, destType, srcType, diag, targetTypeVarContext !== null && targetTypeVarContext !== void 0 ? targetTypeVarContext : new typeVarContext_1.TypeVarContext(), originalFlags, recursionCount)) {
                    return false;
                }
                if ((0, types_1.isAnyOrUnknown)(srcType) && (flags & 16 /* AssignTypeFlags.OverloadOverlapCheck */) !== 0) {
                    return false;
                }
                return true;
            }
        }
        if ((0, types_1.isTypeVar)(srcType)) {
            if ((flags & 2 /* AssignTypeFlags.ReverseTypeVarMatching */) !== 0) {
                // The caller has requested that we solve for source type variables
                // rather than dest. If the type variable is not in the scope of the
                // provided TypeVarContext, simply verify that the concrete types are
                // compatible.
                if ((flags & 1024 /* AssignTypeFlags.IgnoreTypeVarScope */) === 0 &&
                    (!srcTypeVarContext || !srcTypeVarContext.hasSolveForScope((0, typeUtils_1.getTypeVarScopeId)(srcType)))) {
                    return assignType(makeTopLevelTypeVarsConcrete(destType), makeTopLevelTypeVarsConcrete(srcType), diag, 
                    /* destTypeVarContext */ undefined, 
                    /* srcTypeVarContext */ undefined, originalFlags, recursionCount);
                }
                else {
                    if ((0, constraintSolver_1.assignTypeToTypeVar)(evaluatorInterface, srcType, destType, diag, srcTypeVarContext !== null && srcTypeVarContext !== void 0 ? srcTypeVarContext : new typeVarContext_1.TypeVarContext(), originalFlags, recursionCount)) {
                        return true;
                    }
                    // If the dest type is a union, only one of the subtypes needs to match.
                    let isAssignable = false;
                    if ((0, types_1.isUnion)(destType)) {
                        (0, typeUtils_1.doForEachSubtype)(destType, (destSubtype) => {
                            if ((0, constraintSolver_1.assignTypeToTypeVar)(evaluatorInterface, srcType, destSubtype, diag, srcTypeVarContext !== null && srcTypeVarContext !== void 0 ? srcTypeVarContext : new typeVarContext_1.TypeVarContext(), originalFlags, recursionCount)) {
                                isAssignable = true;
                            }
                        });
                    }
                    return isAssignable;
                }
            }
            if ((flags & 1 /* AssignTypeFlags.EnforceInvariance */) !== 0) {
                if ((0, types_1.isAnyOrUnknown)(destType)) {
                    return true;
                }
                // If the source is a ParamSpec and the dest is a "...", this is
                // effectively like an "Any" signature, so we'll treat it as though
                // it's Any.
                if ((0, types_1.isParamSpec)(srcType) &&
                    (0, types_1.isFunction)(destType) &&
                    types_1.FunctionType.isGradualCallableForm(destType) &&
                    destType.details.parameters.length <= 2) {
                    return true;
                }
                // If the source is an unpacked TypeVarTuple and the dest is a
                // *tuple[Any, ...], we'll treat it as compatible.
                if ((0, types_1.isUnpackedVariadicTypeVar)(srcType) &&
                    (0, types_1.isClassInstance)(destType) &&
                    (0, types_1.isUnpackedClass)(destType) &&
                    destType.tupleTypeArguments &&
                    destType.tupleTypeArguments.length === 1 &&
                    destType.tupleTypeArguments[0].isUnbounded &&
                    (0, types_1.isAnyOrUnknown)(destType.tupleTypeArguments[0].type)) {
                    return true;
                }
                if (!(0, types_1.isUnion)(destType)) {
                    diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.typeAssignmentMismatch().format(printSrcDestTypes(srcType, destType)));
                    return false;
                }
            }
        }
        if ((0, types_1.isAnyOrUnknown)(destType)) {
            return true;
        }
        if ((0, types_1.isAnyOrUnknown)(srcType) && !srcType.specialForm) {
            const targetTypeVarContext = (flags & 2 /* AssignTypeFlags.ReverseTypeVarMatching */) === 0 ? destTypeVarContext : srcTypeVarContext;
            if (targetTypeVarContext) {
                // If it's an ellipsis type, convert it to a regular "Any"
                // type. These are functionally equivalent, but "Any" looks
                // better in the text representation.
                const typeVarSubstitution = (0, typeUtils_1.isEllipsisType)(srcType) ? types_1.AnyType.create() : srcType;
                (0, typeUtils_1.setTypeArgumentsRecursive)(destType, typeVarSubstitution, targetTypeVarContext, recursionCount);
            }
            if ((flags & 16 /* AssignTypeFlags.OverloadOverlapCheck */) === 0) {
                return true;
            }
        }
        if ((0, types_1.isNever)(srcType)) {
            if ((flags & 1 /* AssignTypeFlags.EnforceInvariance */) !== 0) {
                if ((0, types_1.isNever)(destType)) {
                    return true;
                }
                diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.typeAssignmentMismatch().format(printSrcDestTypes(srcType, destType)));
                return false;
            }
            const targetTypeVarContext = (flags & 2 /* AssignTypeFlags.ReverseTypeVarMatching */) === 0 ? destTypeVarContext : srcTypeVarContext;
            if (targetTypeVarContext) {
                (0, typeUtils_1.setTypeArgumentsRecursive)(destType, types_1.UnknownType.create(), targetTypeVarContext, recursionCount);
            }
            return true;
        }
        if ((0, types_1.isUnion)(destType)) {
            // If both the source and dest are unions, use assignFromUnionType which has
            // special-case logic to handle this case.
            if ((0, types_1.isUnion)(srcType)) {
                return assignFromUnionType(destType, srcType, 
                /* diag */ undefined, destTypeVarContext, srcTypeVarContext, originalFlags, recursionCount);
            }
            const clonedDestTypeVarContext = destTypeVarContext === null || destTypeVarContext === void 0 ? void 0 : destTypeVarContext.clone();
            const clonedSrcTypeVarContext = srcTypeVarContext === null || srcTypeVarContext === void 0 ? void 0 : srcTypeVarContext.clone();
            if (assignToUnionType(destType, srcType, 
            /* diag */ undefined, clonedDestTypeVarContext, clonedSrcTypeVarContext, originalFlags, recursionCount)) {
                if (destTypeVarContext && clonedDestTypeVarContext) {
                    destTypeVarContext.copyFromClone(clonedDestTypeVarContext);
                }
                if (srcTypeVarContext && clonedSrcTypeVarContext) {
                    srcTypeVarContext.copyFromClone(clonedSrcTypeVarContext);
                }
                return true;
            }
        }
        const expandedSrcType = makeTopLevelTypeVarsConcrete(srcType);
        if ((0, types_1.isUnion)(expandedSrcType)) {
            return assignFromUnionType(destType, expandedSrcType, diag, destTypeVarContext, srcTypeVarContext, originalFlags, recursionCount);
        }
        if ((0, types_1.isUnion)(destType)) {
            return assignToUnionType(destType, srcType, diag, destTypeVarContext, srcTypeVarContext, originalFlags, recursionCount);
        }
        if ((0, typeUtils_1.isNoneInstance)(destType)) {
            if ((0, typeUtils_1.isNoneInstance)(srcType)) {
                return true;
            }
            if ((0, types_1.isClassInstance)(srcType) && types_1.ClassType.isBuiltIn(srcType, 'NoneType')) {
                return true;
            }
        }
        if ((0, typeUtils_1.isNoneTypeClass)(destType)) {
            if ((0, typeUtils_1.isNoneTypeClass)(srcType)) {
                return true;
            }
            if ((0, types_1.isInstantiableClass)(srcType) && types_1.ClassType.isBuiltIn(srcType, 'NoneType')) {
                return true;
            }
        }
        // Is the src a specialized "type" object?
        if ((0, types_1.isClassInstance)(expandedSrcType) && types_1.ClassType.isBuiltIn(expandedSrcType, 'type')) {
            const srcTypeArgs = expandedSrcType.typeArguments;
            let typeTypeArg;
            if (srcTypeArgs && srcTypeArgs.length >= 1) {
                typeTypeArg = srcTypeArgs[0];
            }
            else {
                typeTypeArg = types_1.UnknownType.create();
            }
            if ((0, types_1.isAnyOrUnknown)(typeTypeArg)) {
                if ((0, typeUtils_1.isEffectivelyInstantiable)(destType)) {
                    return true;
                }
            }
            else if ((0, types_1.isClassInstance)(typeTypeArg) || (0, types_1.isTypeVar)(typeTypeArg)) {
                if (assignType(destType, (0, typeUtils_1.convertToInstantiable)(typeTypeArg), diag === null || diag === void 0 ? void 0 : diag.createAddendum(), destTypeVarContext, srcTypeVarContext, flags, recursionCount)) {
                    return true;
                }
                diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.typeAssignmentMismatch().format(printSrcDestTypes(srcType, destType)));
                return false;
            }
        }
        if ((0, types_1.isInstantiableClass)(destType)) {
            if ((0, types_1.isInstantiableClass)(expandedSrcType)) {
                // PEP 544 says that if the dest type is a type[Proto] class,
                // the source must be a "concrete" (non-protocol) class.
                if (types_1.ClassType.isProtocolClass(destType) &&
                    (flags & 16384 /* AssignTypeFlags.IgnoreProtocolAssignmentCheck */) === 0) {
                    if (types_1.ClassType.isProtocolClass(expandedSrcType) &&
                        (0, types_1.isInstantiableClass)(srcType) &&
                        !srcType.includeSubclasses) {
                        diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.protocolSourceIsNotConcrete().format({
                            sourceType: printType((0, typeUtils_1.convertToInstance)(srcType)),
                            destType: printType(destType),
                        }));
                        return false;
                    }
                }
                if (types_1.ClassType.isBuiltIn(destType, 'type') && ((_c = srcType.instantiableNestingLevel) !== null && _c !== void 0 ? _c : 0) > 0) {
                    return true;
                }
                if (isSpecialFormClass(expandedSrcType, flags)) {
                    if (destType.specialForm) {
                        return assignType(destType.specialForm, expandedSrcType, diag, destTypeVarContext, srcTypeVarContext, flags, recursionCount);
                    }
                }
                else if (assignClass(destType, expandedSrcType, diag, destTypeVarContext, srcTypeVarContext, flags, recursionCount, 
                /* reportErrorsUsingObjType */ false)) {
                    return true;
                }
                diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.typeAssignmentMismatch().format(printSrcDestTypes(srcType, destType)));
                return false;
            }
            else if ((0, types_1.isClassInstance)(expandedSrcType) && (0, typeUtils_1.isMetaclassInstance)(expandedSrcType)) {
                // If the source is a metaclass instance, verify that it's compatible with
                // the metaclass of the instantiable dest type.
                const destMetaclass = destType.details.effectiveMetaclass;
                if (destMetaclass && (0, types_1.isInstantiableClass)(destMetaclass)) {
                    if (assignClass(types_1.ClassType.cloneAsInstance(destMetaclass), expandedSrcType, diag, destTypeVarContext, srcTypeVarContext, flags, recursionCount, 
                    /* reportErrorsUsingObjType */ false)) {
                        return true;
                    }
                    diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.typeAssignmentMismatch().format(printSrcDestTypes(srcType, destType)));
                    return false;
                }
            }
        }
        if ((0, types_1.isClassInstance)(destType)) {
            if (types_1.ClassType.isBuiltIn(destType, 'type')) {
                if ((0, types_1.isInstantiableClass)(srcType) && isSpecialFormClass(srcType, flags)) {
                    return false;
                }
                if ((0, types_1.isAnyOrUnknown)(srcType) && (flags & 16 /* AssignTypeFlags.OverloadOverlapCheck */) !== 0) {
                    return false;
                }
                const destTypeArgs = destType.typeArguments;
                if (destTypeArgs && destTypeArgs.length >= 1) {
                    if (types_1.TypeBase.isInstance(destTypeArgs[0]) && types_1.TypeBase.isInstantiable(srcType)) {
                        return assignType(destTypeArgs[0], (0, typeUtils_1.convertToInstance)(srcType), diag, destTypeVarContext, srcTypeVarContext, flags, recursionCount);
                    }
                }
                // Is the dest a "type" object? Assume that all instantiable
                // types are assignable to "type".
                if (types_1.TypeBase.isInstantiable(srcType)) {
                    const isLiteral = (0, types_1.isClass)(srcType) && srcType.literalValue !== undefined;
                    return !isLiteral;
                }
            }
            else if (types_1.ClassType.isBuiltIn(destType, ['TypeGuard', 'TypeIs'])) {
                // Allow the source to be a "bool".
                if ((originalFlags & 128 /* AssignTypeFlags.AllowBoolTypeGuard */) !== 0) {
                    if ((0, types_1.isClassInstance)(srcType) && types_1.ClassType.isBuiltIn(srcType, 'bool')) {
                        return true;
                    }
                }
            }
            let concreteSrcType = makeTopLevelTypeVarsConcrete(srcType);
            if ((0, types_1.isClass)(concreteSrcType) && types_1.TypeBase.isInstance(concreteSrcType)) {
                if (destType.literalValue !== undefined) {
                    const srcLiteral = concreteSrcType.literalValue;
                    if (srcLiteral === undefined || !types_1.ClassType.isLiteralValueSame(concreteSrcType, destType)) {
                        diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.literalAssignmentMismatch().format({
                            sourceType: printType(srcType),
                            destType: printType(destType),
                        }));
                        return false;
                    }
                }
                // Handle LiteralString special form.
                if (types_1.ClassType.isBuiltIn(destType, 'LiteralString')) {
                    if (types_1.ClassType.isBuiltIn(concreteSrcType, 'str') && concreteSrcType.literalValue !== undefined) {
                        return (flags & 1 /* AssignTypeFlags.EnforceInvariance */) === 0;
                    }
                    else if (types_1.ClassType.isBuiltIn(concreteSrcType, 'LiteralString')) {
                        return true;
                    }
                }
                else if (types_1.ClassType.isBuiltIn(concreteSrcType, 'LiteralString') &&
                    strClass &&
                    (0, types_1.isInstantiableClass)(strClass) &&
                    (flags & 1 /* AssignTypeFlags.EnforceInvariance */) === 0) {
                    concreteSrcType = types_1.ClassType.cloneAsInstance(strClass);
                }
                if (!assignClass(types_1.ClassType.cloneAsInstantiable(destType), types_1.ClassType.cloneAsInstantiable(concreteSrcType), diag, destTypeVarContext, srcTypeVarContext, flags, recursionCount, 
                /* reportErrorsUsingObjType */ true)) {
                    return false;
                }
                return true;
            }
            else if ((0, types_1.isFunction)(concreteSrcType) || (0, types_1.isOverloadedFunction)(concreteSrcType)) {
                // Is the destination a callback protocol (defined in PEP 544)?
                const destCallbackType = getCallbackProtocolType(destType, recursionCount);
                if (destCallbackType) {
                    return assignType(destCallbackType, concreteSrcType, diag, destTypeVarContext, srcTypeVarContext, flags, recursionCount);
                }
                // All functions are considered instances of "builtins.function".
                if (functionClass) {
                    return assignType(destType, (0, typeUtils_1.convertToInstance)(functionClass), diag, destTypeVarContext, srcTypeVarContext, flags, recursionCount);
                }
            }
            else if ((0, types_1.isModule)(concreteSrcType)) {
                // Is the destination the built-in "ModuleType"?
                if (types_1.ClassType.isBuiltIn(destType, 'ModuleType')) {
                    return true;
                }
                if (types_1.ClassType.isProtocolClass(destType)) {
                    return (0, protocols_1.assignModuleToProtocol)(evaluatorInterface, types_1.ClassType.cloneAsInstantiable(destType), concreteSrcType, diag, destTypeVarContext, flags, recursionCount);
                }
            }
            else if ((0, types_1.isInstantiableClass)(concreteSrcType)) {
                // See if the destType is an instantiation of a Protocol
                // class that is effectively a function.
                const callbackType = getCallbackProtocolType(destType, recursionCount);
                if (callbackType) {
                    return assignType(callbackType, concreteSrcType, diag, destTypeVarContext, srcTypeVarContext, flags, recursionCount);
                }
                // If the destType is an instantiation of a Protocol,
                // see if the class type itself satisfies the protocol.
                if (types_1.ClassType.isProtocolClass(destType)) {
                    return (0, protocols_1.assignClassToProtocol)(evaluatorInterface, types_1.ClassType.cloneAsInstantiable(destType), concreteSrcType, diag, destTypeVarContext, srcTypeVarContext, flags, recursionCount);
                }
                // Determine if the metaclass can be assigned to the object.
                const metaclass = concreteSrcType.details.effectiveMetaclass;
                if (metaclass) {
                    if ((0, types_1.isAnyOrUnknown)(metaclass)) {
                        return true;
                    }
                    else {
                        return assignClass(types_1.ClassType.cloneAsInstantiable(destType), metaclass, diag, destTypeVarContext, srcTypeVarContext, flags, recursionCount, 
                        /* reportErrorsUsingObjType */ false);
                    }
                }
            }
            else if ((0, types_1.isAnyOrUnknown)(concreteSrcType) && !concreteSrcType.specialForm) {
                return (flags & 16 /* AssignTypeFlags.OverloadOverlapCheck */) === 0;
            }
            else if ((0, types_1.isUnion)(concreteSrcType)) {
                return assignType(destType, concreteSrcType, diag, destTypeVarContext, srcTypeVarContext, flags, recursionCount);
            }
        }
        if ((0, types_1.isFunction)(destType)) {
            let concreteSrcType = makeTopLevelTypeVarsConcrete(srcType);
            if ((0, types_1.isClassInstance)(concreteSrcType)) {
                const boundMethod = getBoundMagicMethod(concreteSrcType, '__call__', 
                /* selfType */ undefined, 
                /* diag */ undefined, recursionCount);
                if (boundMethod) {
                    concreteSrcType = boundMethod;
                }
            }
            // If it's a class, use the constructor for type compatibility checking.
            if ((0, types_1.isInstantiableClass)(concreteSrcType) && concreteSrcType.literalValue === undefined) {
                const constructor = (0, constructors_1.createFunctionFromConstructor)(evaluatorInterface, concreteSrcType, (0, types_1.isTypeVar)(srcType) ? (0, typeUtils_1.convertToInstance)(srcType) : undefined, recursionCount);
                if (constructor) {
                    concreteSrcType = constructor;
                    // The constructor conversion may result in a union of the
                    // __init__ and __new__ callables.
                    if ((0, types_1.isUnion)(concreteSrcType)) {
                        return assignType(destType, concreteSrcType, diag, destTypeVarContext, srcTypeVarContext, flags, recursionCount);
                    }
                }
            }
            if ((0, types_1.isAnyOrUnknown)(concreteSrcType)) {
                return (flags & 16 /* AssignTypeFlags.OverloadOverlapCheck */) === 0;
            }
            if ((0, types_1.isOverloadedFunction)(concreteSrcType)) {
                // Find all of the overloaded functions that match the parameters.
                const overloads = types_1.OverloadedFunctionType.getOverloads(concreteSrcType);
                const filteredOverloads = [];
                const destTypeVarSignatures = [];
                const srcTypeVarSignatures = [];
                overloads.forEach((overload) => {
                    var _a;
                    const overloadScopeId = (_a = (0, typeUtils_1.getTypeVarScopeId)(overload)) !== null && _a !== void 0 ? _a : '';
                    const destTypeVarContextClone = destTypeVarContext === null || destTypeVarContext === void 0 ? void 0 : destTypeVarContext.cloneWithSignatureSource(overloadScopeId);
                    const srcTypeVarContextClone = srcTypeVarContext === null || srcTypeVarContext === void 0 ? void 0 : srcTypeVarContext.cloneWithSignatureSource(overloadScopeId);
                    if (assignType(destType, overload, 
                    /* diag */ undefined, destTypeVarContextClone, srcTypeVarContextClone, flags, recursionCount)) {
                        filteredOverloads.push(overload);
                        if (destTypeVarContextClone) {
                            (0, collectionUtils_1.appendArray)(destTypeVarSignatures, destTypeVarContextClone.getSignatureContexts());
                        }
                        if (srcTypeVarContextClone) {
                            (0, collectionUtils_1.appendArray)(srcTypeVarSignatures, srcTypeVarContextClone.getSignatureContexts());
                        }
                    }
                });
                if (filteredOverloads.length === 0) {
                    diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.noOverloadAssignable().format({ type: printType(destType) }));
                    return false;
                }
                if (destTypeVarContext) {
                    destTypeVarContext.copySignatureContexts(destTypeVarSignatures);
                }
                if (srcTypeVarContext) {
                    srcTypeVarContext.copySignatureContexts(srcTypeVarSignatures);
                }
                return true;
            }
            if ((0, types_1.isFunction)(concreteSrcType)) {
                if (assignFunction(destType, concreteSrcType, diag === null || diag === void 0 ? void 0 : diag.createAddendum(), destTypeVarContext !== null && destTypeVarContext !== void 0 ? destTypeVarContext : new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeIds)(destType)), srcTypeVarContext !== null && srcTypeVarContext !== void 0 ? srcTypeVarContext : new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeIds)(concreteSrcType)), flags, recursionCount)) {
                    return true;
                }
            }
        }
        if ((0, types_1.isOverloadedFunction)(destType)) {
            const overloadDiag = diag === null || diag === void 0 ? void 0 : diag.createAddendum();
            // All overloads in the dest must be assignable.
            const destOverloads = types_1.OverloadedFunctionType.getOverloads(destType);
            // If the source is also an overload with the same number of overloads,
            // there's a good chance that there's a one-to-one mapping. Try this
            // first before using an n^2 algorithm.
            if ((0, types_1.isOverloadedFunction)(srcType)) {
                const srcOverloads = types_1.OverloadedFunctionType.getOverloads(srcType);
                if (destOverloads.length === srcOverloads.length) {
                    if (destOverloads.every((destOverload, index) => {
                        const srcOverload = srcOverloads[index];
                        return assignType(destOverload, srcOverload, 
                        /* diag */ undefined, destTypeVarContext !== null && destTypeVarContext !== void 0 ? destTypeVarContext : new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(destOverload)), srcTypeVarContext, flags, recursionCount);
                    })) {
                        return true;
                    }
                }
            }
            const isAssignable = destOverloads.every((destOverload) => {
                if (destTypeVarContext) {
                    destTypeVarContext.addSolveForScope((0, typeUtils_1.getTypeVarScopeId)(destOverload));
                }
                const result = assignType(destOverload, srcType, overloadDiag === null || overloadDiag === void 0 ? void 0 : overloadDiag.createAddendum(), destTypeVarContext !== null && destTypeVarContext !== void 0 ? destTypeVarContext : new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(destOverload)), srcTypeVarContext, flags, recursionCount);
                return result;
            });
            if (!isAssignable) {
                if (overloadDiag) {
                    overloadDiag.addMessage(localize_1.LocAddendum.overloadNotAssignable().format({
                        name: destType.overloads[0].details.name,
                    }));
                }
                return false;
            }
            return true;
        }
        if ((0, types_1.isClass)(destType) && types_1.ClassType.isBuiltIn(destType, 'object')) {
            if (((0, types_1.isInstantiableClass)(destType) && types_1.TypeBase.isInstantiable(srcType)) || (0, types_1.isClassInstance)(destType)) {
                if ((flags & 1 /* AssignTypeFlags.EnforceInvariance */) === 0) {
                    // All types (including None, Module, OverloadedFunction) derive from object.
                    return true;
                }
            }
        }
        // Are we trying to assign None to a protocol?
        if ((0, typeUtils_1.isNoneInstance)(srcType) && (0, types_1.isClassInstance)(destType) && types_1.ClassType.isProtocolClass(destType)) {
            if (noneTypeClass && (0, types_1.isInstantiableClass)(noneTypeClass)) {
                return (0, protocols_1.assignClassToProtocol)(evaluatorInterface, types_1.ClassType.cloneAsInstantiable(destType), types_1.ClassType.cloneAsInstance(noneTypeClass), diag, destTypeVarContext, srcTypeVarContext, flags, recursionCount);
            }
        }
        if ((0, typeUtils_1.isNoneInstance)(destType)) {
            diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.assignToNone());
            return false;
        }
        diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.typeAssignmentMismatch().format(printSrcDestTypes(srcType, destType)));
        return false;
    }
    function assignFromUnionType(destType, srcType, diag, destTypeVarContext, srcTypeVarContext, flags, recursionCount) {
        // Start by checking for an exact match. This is needed to handle unions
        // that contain recursive type aliases.
        if ((0, types_1.isTypeSame)(srcType, destType, {}, recursionCount)) {
            return true;
        }
        // Sort the subtypes so we have a deterministic order for unions.
        let sortedSrcTypes = (0, typeUtils_1.sortTypes)(srcType.subtypes);
        let matchedSomeSubtypes = false;
        // Handle the case where the source and dest are both unions. Try
        // to eliminate as many exact type matches between the src and dest.
        if ((0, types_1.isUnion)(destType)) {
            // Handle the special case where the dest is a union of Any and
            // a type variable. This occurs, for example, with the return type of
            // the getattr function.
            const nonAnySubtypes = destType.subtypes.filter((t) => !(0, types_1.isAnyOrUnknown)(t));
            if (nonAnySubtypes.length === 1 && (0, types_1.isTypeVar)(nonAnySubtypes[0])) {
                assignType(nonAnySubtypes[0], srcType, 
                /* diag */ undefined, destTypeVarContext, srcTypeVarContext, flags, recursionCount);
                // This always succeeds because the destination contains Any.
                return true;
            }
            const remainingDestSubtypes = [];
            let remainingSrcSubtypes = sortedSrcTypes;
            let canUseFastPath = true;
            // First attempt to match all of the non-generic types in the dest
            // to non-generic types in the source.
            (0, typeUtils_1.sortTypes)(destType.subtypes).forEach((destSubtype) => {
                if ((0, typeUtils_1.requiresSpecialization)(destSubtype)) {
                    remainingDestSubtypes.push(destSubtype);
                }
                else {
                    const srcTypeIndex = remainingSrcSubtypes.findIndex((srcSubtype) => (0, types_1.isTypeSame)(srcSubtype, destSubtype, {}, recursionCount));
                    if (srcTypeIndex >= 0) {
                        remainingSrcSubtypes.splice(srcTypeIndex, 1);
                        matchedSomeSubtypes = true;
                    }
                    else {
                        remainingDestSubtypes.push(destSubtype);
                    }
                }
            });
            // For all remaining source subtypes, attempt to find a dest subtype
            // whose primary type matches.
            remainingSrcSubtypes.forEach((srcSubtype) => {
                const destTypeIndex = remainingDestSubtypes.findIndex((destSubtype) => {
                    if ((0, types_1.isTypeSame)(destSubtype, srcSubtype)) {
                        return true;
                    }
                    if ((0, types_1.isClass)(srcSubtype) &&
                        (0, types_1.isClass)(destSubtype) &&
                        types_1.TypeBase.isInstance(srcSubtype) === types_1.TypeBase.isInstance(destSubtype)) {
                        if (types_1.ClassType.isSameGenericClass(srcSubtype, destSubtype)) {
                            return true;
                        }
                        // Are they equivalent TypedDicts?
                        if (types_1.ClassType.isTypedDictClass(srcSubtype) && types_1.ClassType.isTypedDictClass(destSubtype)) {
                            if (assignType(srcSubtype, destSubtype, 
                            /* diag */ undefined, 
                            /* destTypeVarContext */ undefined, 
                            /* srcTypeVarContext */ undefined, flags, recursionCount)) {
                                return true;
                            }
                        }
                    }
                    if ((0, types_1.isFunction)(srcSubtype) || (0, types_1.isOverloadedFunction)(srcSubtype)) {
                        if ((0, types_1.isFunction)(destSubtype) || (0, types_1.isOverloadedFunction)(destSubtype)) {
                            return true;
                        }
                    }
                    return false;
                });
                if (destTypeIndex >= 0) {
                    if (assignType(remainingDestSubtypes[destTypeIndex], srcSubtype, 
                    /* diag */ undefined, destTypeVarContext, srcTypeVarContext, flags, recursionCount)) {
                        // Note that we have matched at least one subtype indicating
                        // there is at least some overlap.
                        matchedSomeSubtypes = true;
                    }
                    else {
                        canUseFastPath = false;
                    }
                    remainingDestSubtypes.splice(destTypeIndex, 1);
                    remainingSrcSubtypes = remainingSrcSubtypes.filter((t) => t !== srcSubtype);
                }
            });
            // If there is are remaining dest subtypes and they're all type variables,
            // attempt to assign the remaining source subtypes to them.
            if (canUseFastPath && (remainingDestSubtypes.length !== 0 || remainingSrcSubtypes.length !== 0)) {
                if ((flags & 1 /* AssignTypeFlags.EnforceInvariance */) !== 0) {
                    // If we have no src subtypes remaining but not all dest types have been subsumed
                    // by other dest types, then the types are not compatible if we're enforcing invariance.
                    if (remainingSrcSubtypes.length === 0) {
                        return remainingDestSubtypes.every((destSubtype) => isTypeSubsumedByOtherType(destSubtype, destType, 
                        /* allowAnyToSubsume */ true, recursionCount));
                    }
                }
                const isReversed = (flags & 2 /* AssignTypeFlags.ReverseTypeVarMatching */) !== 0;
                const effectiveDestSubtypes = isReversed ? remainingSrcSubtypes : remainingDestSubtypes;
                if (effectiveDestSubtypes.length === 0 || effectiveDestSubtypes.some((t) => !(0, types_1.isTypeVar)(t))) {
                    canUseFastPath = false;
                    // We can avoid checking the source subtypes that have already been checked.
                    sortedSrcTypes = remainingSrcSubtypes;
                }
                else if (remainingDestSubtypes.length === remainingSrcSubtypes.length) {
                    // If the number of remaining source subtypes is the same as the number
                    // of dest TypeVars, try to assign each source subtype to its own dest TypeVar.
                    const reorderedDestSubtypes = [...remainingDestSubtypes];
                    for (let srcIndex = 0; srcIndex < remainingSrcSubtypes.length; srcIndex++) {
                        let foundMatchForSrc = false;
                        for (let destIndex = 0; destIndex < reorderedDestSubtypes.length; destIndex++) {
                            if (assignType(reorderedDestSubtypes[destIndex], remainingSrcSubtypes[srcIndex], diag === null || diag === void 0 ? void 0 : diag.createAddendum(), destTypeVarContext, srcTypeVarContext, flags, recursionCount)) {
                                foundMatchForSrc = true;
                                // Move the matched dest TypeVar to the end of the list so the other
                                // dest TypeVars have a better chance of being assigned to.
                                reorderedDestSubtypes.push(...reorderedDestSubtypes.splice(destIndex, 1));
                                break;
                            }
                        }
                        if (!foundMatchForSrc) {
                            canUseFastPath = false;
                            break;
                        }
                    }
                    // We can avoid checking the source subtypes that have already been checked.
                    sortedSrcTypes = remainingSrcSubtypes;
                }
                else if (remainingSrcSubtypes.length === 0) {
                    if ((flags & 2048 /* AssignTypeFlags.PopulatingExpectedType */) !== 0) {
                        // If we're populating an expected type, try not to leave
                        // any TypeVars unsolved. Assign the full type to the remaining
                        // dest TypeVars.
                        remainingDestSubtypes.forEach((destSubtype) => {
                            assignType(destSubtype, srcType, 
                            /* diag */ undefined, destTypeVarContext, srcTypeVarContext, flags, recursionCount);
                        });
                    }
                    // If we've assigned all of the source subtypes but one or more dest
                    // TypeVars have gone unmatched, treat this as success.
                }
                else {
                    // Try to assign a union of the remaining source types to
                    // the first destination TypeVar.
                    if (!assignType(isReversed ? (0, types_1.combineTypes)(remainingDestSubtypes) : remainingDestSubtypes[0], isReversed ? remainingSrcSubtypes[0] : (0, types_1.combineTypes)(remainingSrcSubtypes), diag === null || diag === void 0 ? void 0 : diag.createAddendum(), destTypeVarContext, srcTypeVarContext, flags, recursionCount)) {
                        canUseFastPath = false;
                    }
                }
            }
            if (canUseFastPath) {
                return true;
            }
            // If we're looking for type overlaps and at least one type was matched,
            // consider it as assignable.
            if ((flags & 32 /* AssignTypeFlags.PartialOverloadOverlapCheck */) !== 0 && matchedSomeSubtypes) {
                return true;
            }
        }
        let isIncompatible = false;
        sortedSrcTypes.forEach((subtype) => {
            if (isIncompatible) {
                return;
            }
            if (!assignType(destType, subtype, 
            /* diag */ undefined, destTypeVarContext, srcTypeVarContext, flags, recursionCount)) {
                // Determine if the current subtype is subsumed by another subtype
                // in the same union. If so, we can ignore this.
                const isSubtypeSubsumed = isTypeSubsumedByOtherType(subtype, srcType, 
                /* allowAnyToSubsume */ false, recursionCount);
                // Try again with a concrete version of the subtype.
                if (!isSubtypeSubsumed &&
                    !assignType(destType, subtype, diag === null || diag === void 0 ? void 0 : diag.createAddendum(), destTypeVarContext, srcTypeVarContext, flags, recursionCount)) {
                    isIncompatible = true;
                }
            }
            else {
                matchedSomeSubtypes = true;
            }
        }, /* sortSubtypes */ true);
        if (isIncompatible) {
            // If we're looking for type overlaps and at least one type was matched,
            // consider it as assignable.
            if ((flags & 32 /* AssignTypeFlags.PartialOverloadOverlapCheck */) !== 0 && matchedSomeSubtypes) {
                return true;
            }
            diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.typeAssignmentMismatch().format(printSrcDestTypes(srcType, destType)));
            return false;
        }
        return true;
    }
    function isSpecialFormClass(classType, flags) {
        if ((flags & 32768 /* AssignTypeFlags.AllowIsinstanceSpecialForms */) !== 0) {
            return false;
        }
        return types_1.ClassType.isSpecialFormClass(classType);
    }
    // Determines whether a type is "subsumed by" (i.e. is a proper subtype of) another type.
    function isTypeSubsumedByOtherType(type, otherType, allowAnyToSubsume, recursionCount = 0) {
        const concreteType = makeTopLevelTypeVarsConcrete(type);
        const otherSubtypes = (0, types_1.isUnion)(otherType) ? otherType.subtypes : [otherType];
        for (const otherSubtype of otherSubtypes) {
            if ((0, types_1.isTypeSame)(otherSubtype, type)) {
                continue;
            }
            if ((0, types_1.isAnyOrUnknown)(otherSubtype)) {
                if (allowAnyToSubsume) {
                    return true;
                }
            }
            else if (isProperSubtype(otherSubtype, concreteType, recursionCount)) {
                return true;
            }
        }
        return false;
    }
    // Determines whether the srcType is a subtype of destType but the converse
    // is not true. It's important that we check both directions to avoid
    // matches for types like `tuple[Any]` and `tuple[int]` from being considered
    // proper subtypes of each other.
    function isProperSubtype(destType, srcType, recursionCount) {
        // If the destType has a condition, don't consider the srcType a proper subtype.
        if (destType.condition) {
            return false;
        }
        // Shortcut the check if either type is Any or Unknown.
        if ((0, types_1.isAnyOrUnknown)(destType) || (0, types_1.isAnyOrUnknown)(srcType)) {
            return true;
        }
        // Shortcut the check if either type is a class whose hierarchy contains an unknown type.
        if ((0, types_1.isClass)(destType) && destType.details.mro.some((mro) => (0, types_1.isAnyOrUnknown)(mro))) {
            return true;
        }
        if ((0, types_1.isClass)(srcType) && srcType.details.mro.some((mro) => (0, types_1.isAnyOrUnknown)(mro))) {
            return true;
        }
        return (assignType(destType, srcType, 
        /* diag */ undefined, 
        /* destTypeVarContext */ undefined, 
        /* srcTypeVarContext */ undefined, 0 /* AssignTypeFlags.Default */, recursionCount) &&
            !assignType(srcType, destType, 
            /* diag */ undefined, 
            /* destTypeVarContext */ undefined, 
            /* srcTypeVarContext */ undefined, 0 /* AssignTypeFlags.Default */, recursionCount));
    }
    function assignToUnionType(destType, srcType, diag, destTypeVarContext, srcTypeVarContext, flags, recursionCount) {
        // If we need to enforce invariance, the source needs to be compatible
        // with all subtypes in the dest, unless those subtypes are subclasses
        // of other subtypes.
        if (flags & 1 /* AssignTypeFlags.EnforceInvariance */) {
            let isIncompatible = false;
            (0, typeUtils_1.doForEachSubtype)(destType, (subtype, index) => {
                if (!isIncompatible &&
                    !assignType(subtype, srcType, diag === null || diag === void 0 ? void 0 : diag.createAddendum(), destTypeVarContext, srcTypeVarContext, flags, recursionCount)) {
                    // Determine whether this subtype is assignable to
                    // another subtype elsewhere in the union. If so, we can ignore
                    // the incompatibility.
                    let skipSubtype = false;
                    if (!(0, types_1.isAnyOrUnknown)(subtype)) {
                        (0, typeUtils_1.doForEachSubtype)(destType, (otherSubtype, otherIndex) => {
                            if (index !== otherIndex && !skipSubtype) {
                                if (assignType(otherSubtype, subtype, 
                                /* diag */ undefined, 
                                /* destTypeVarContext */ undefined, 
                                /* srcTypeVarContext */ undefined, 0 /* AssignTypeFlags.Default */, recursionCount)) {
                                    skipSubtype = true;
                                }
                            }
                        });
                    }
                    if (!skipSubtype) {
                        isIncompatible = true;
                    }
                }
            });
            if (isIncompatible) {
                diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.typeAssignmentMismatch().format(printSrcDestTypes(srcType, destType)));
                return false;
            }
            return true;
        }
        // For union destinations, we just need to match one of the types.
        const diagAddendum = diag ? new diagnostic_1.DiagnosticAddendum() : undefined;
        let foundMatch = false;
        // Does the union contain any type variables that need to be solved?
        // If so, we need to use a slower path.
        if (!(0, typeUtils_1.requiresSpecialization)(destType)) {
            for (const subtype of destType.subtypes) {
                if (assignType(subtype, srcType, diagAddendum === null || diagAddendum === void 0 ? void 0 : diagAddendum.createAddendum(), destTypeVarContext, srcTypeVarContext, flags, recursionCount)) {
                    foundMatch = true;
                    break;
                }
            }
        }
        else {
            // Run through all subtypes in the union. Don't stop at the first
            // match we find because we may need to match TypeVars in other
            // subtypes. We special-case "None" so we can handle Optional[T]
            // without matching the None to the type var.
            if ((0, typeUtils_1.isNoneInstance)(srcType) && (0, typeUtils_1.isOptionalType)(destType)) {
                foundMatch = true;
            }
            else {
                let bestDestTypeVarContext;
                let bestSrcTypeVarContext;
                let bestTypeVarContextScore;
                // If the srcType is a literal, try to use the fast-path lookup
                // in case the destType is a union with hundreds of literals.
                if ((0, types_1.isClassInstance)(srcType) &&
                    (0, typeUtils_1.isLiteralType)(srcType) &&
                    types_1.UnionType.containsType(destType, srcType, /* exclusionSet */ undefined, recursionCount)) {
                    return true;
                }
                (0, typeUtils_1.doForEachSubtype)(destType, (subtype) => {
                    // Make a temporary clone of the typeVarContext. We don't want to modify
                    // the original typeVarContext until we find the "optimal" typeVar mapping.
                    const destTypeVarContextClone = destTypeVarContext === null || destTypeVarContext === void 0 ? void 0 : destTypeVarContext.clone();
                    const srcTypeVarContextClone = srcTypeVarContext === null || srcTypeVarContext === void 0 ? void 0 : srcTypeVarContext.clone();
                    if (assignType(subtype, srcType, diagAddendum === null || diagAddendum === void 0 ? void 0 : diagAddendum.createAddendum(), destTypeVarContextClone, srcTypeVarContextClone, flags, recursionCount)) {
                        foundMatch = true;
                        if (destTypeVarContextClone) {
                            // Ask the typeVarContext to compute a "score" for the current
                            // contents of the table.
                            let typeVarContextScore = destTypeVarContextClone.getScore();
                            // If the type matches exactly, prefer it over other types.
                            if ((0, types_1.isTypeSame)(subtype, stripLiteralValue(srcType))) {
                                typeVarContextScore = Number.POSITIVE_INFINITY;
                            }
                            if (bestTypeVarContextScore === undefined ||
                                bestTypeVarContextScore <= typeVarContextScore) {
                                // We found a typeVar mapping with a higher score than before.
                                bestTypeVarContextScore = typeVarContextScore;
                                bestDestTypeVarContext = destTypeVarContextClone;
                                bestSrcTypeVarContext = srcTypeVarContextClone;
                            }
                        }
                    }
                });
                // If we found a winning type var mapping, copy it back to typeVarContext.
                if (destTypeVarContext && bestDestTypeVarContext) {
                    destTypeVarContext.copyFromClone(bestDestTypeVarContext);
                }
                if (srcTypeVarContext && bestSrcTypeVarContext) {
                    srcTypeVarContext.copyFromClone(bestSrcTypeVarContext);
                }
            }
        }
        // If the source is a constrained TypeVar, see if we can assign all of the
        // constraints to the union.
        if (!foundMatch) {
            if ((0, types_1.isTypeVar)(srcType) && srcType.details.constraints.length > 0) {
                foundMatch = assignType(destType, makeTopLevelTypeVarsConcrete(srcType), diagAddendum === null || diagAddendum === void 0 ? void 0 : diagAddendum.createAddendum(), destTypeVarContext, srcTypeVarContext, flags, recursionCount);
            }
        }
        if (!foundMatch) {
            if (diag && diagAddendum) {
                diag.addMessage(localize_1.LocAddendum.typeAssignmentMismatch().format(printSrcDestTypes(srcType, destType)));
                diag.addAddendum(diagAddendum);
            }
            return false;
        }
        return true;
    }
    function assignConditionalTypeToTypeVar(destType, srcType, recursionCount) {
        // The srcType is assignable only if all of its subtypes are assignable.
        return !(0, types_1.findSubtype)(srcType, (srcSubtype) => {
            var _a;
            if ((0, types_1.isTypeSame)(destType, srcSubtype, { ignorePseudoGeneric: true }, recursionCount)) {
                return false;
            }
            if ((0, typeUtils_1.isIncompleteUnknown)(srcSubtype)) {
                return false;
            }
            const destTypeVarName = types_1.TypeVarType.getNameWithScope(destType);
            // Determine which conditions on this type apply to this type variable.
            // There might be more than one of them.
            const applicableConditions = ((_a = (0, typeUtils_1.getTypeCondition)(srcSubtype)) !== null && _a !== void 0 ? _a : []).filter((constraint) => constraint.typeVar.nameWithScope === destTypeVarName);
            // If there are no applicable conditions, it's not assignable.
            if (applicableConditions.length === 0) {
                return true;
            }
            return !applicableConditions.some((condition) => {
                if (condition.typeVar.nameWithScope === types_1.TypeVarType.getNameWithScope(destType)) {
                    if (destType.details.boundType) {
                        (0, debug_1.assert)(condition.constraintIndex === 0, 'Expected constraint for bound TypeVar to have index of 0');
                        return assignType(destType.details.boundType, srcSubtype, 
                        /* diag */ undefined, 
                        /* destTypeVarContext */ undefined, 
                        /* srcTypeVarContext */ undefined, 0 /* AssignTypeFlags.Default */, recursionCount);
                    }
                    if (destType.details.constraints.length > 0) {
                        (0, debug_1.assert)(condition.constraintIndex < destType.details.constraints.length, 'Constraint for constrained TypeVar is out of bounds');
                        return assignType(destType.details.constraints[condition.constraintIndex], srcSubtype, 
                        /* diag */ undefined, 
                        /* destTypeVarContext */ undefined, 
                        /* srcTypeVarContext */ undefined, 0 /* AssignTypeFlags.Default */, recursionCount);
                    }
                    // This is a non-bound and non-constrained type variable with a matching condition.
                    return true;
                }
                return false;
            });
        });
    }
    // If the class is a protocol and it has a `__call__` method but no other methods
    // or attributes that would be incompatible with a function, this method returns
    // the signature of the call implied by the `__call__` method. Otherwise it returns
    // undefined.
    function getCallbackProtocolType(objType, recursionCount = 0) {
        if (!(0, types_1.isClassInstance)(objType) || !types_1.ClassType.isProtocolClass(objType)) {
            return undefined;
        }
        // Make sure that the protocol class doesn't define any fields that
        // a normal function wouldn't be compatible with.
        for (const mroClass of objType.details.mro) {
            if ((0, types_1.isClass)(mroClass) && types_1.ClassType.isProtocolClass(mroClass)) {
                for (const field of types_1.ClassType.getSymbolTable(mroClass)) {
                    if (field[0] !== '__call__' && !field[1].isIgnoredForProtocolMatch()) {
                        let fieldIsPartOfFunction = false;
                        if (functionClass && (0, types_1.isClass)(functionClass)) {
                            if (types_1.ClassType.getSymbolTable(functionClass).has(field[0])) {
                                fieldIsPartOfFunction = true;
                            }
                        }
                        if (!fieldIsPartOfFunction) {
                            return undefined;
                        }
                    }
                }
            }
        }
        return getBoundMagicMethod(objType, '__call__', /* selfType */ undefined, /* diag */ undefined, recursionCount);
    }
    function assignFunctionParameter(destType, srcType, paramIndex, diag, destTypeVarContext, srcTypeVarContext, flags, recursionCount) {
        // Handle the special case where the dest type is a synthesized
        // "self" for a protocol class.
        if ((0, types_1.isTypeVar)(destType) &&
            destType.details.isSynthesized &&
            destType.details.boundType &&
            (0, types_1.isClassInstance)(destType.details.boundType) &&
            types_1.ClassType.isProtocolClass(destType.details.boundType)) {
            return true;
        }
        if ((0, types_1.isVariadicTypeVar)(destType) && !(0, types_1.isUnpacked)(srcType)) {
            return false;
        }
        let specializedSrcType = srcType;
        let specializedDestType = destType;
        let doSpecializationStep = false;
        if ((flags & 2 /* AssignTypeFlags.ReverseTypeVarMatching */) === 0) {
            specializedDestType = (0, typeUtils_1.applySolvedTypeVars)(destType, destTypeVarContext, { useNarrowBoundOnly: true });
            doSpecializationStep = (0, typeUtils_1.requiresSpecialization)(specializedDestType);
        }
        else {
            specializedSrcType = (0, typeUtils_1.applySolvedTypeVars)(srcType, srcTypeVarContext, { useNarrowBoundOnly: true });
            doSpecializationStep = (0, typeUtils_1.requiresSpecialization)(specializedSrcType);
        }
        // Is an additional specialization step required?
        if (doSpecializationStep) {
            assignType(specializedSrcType, specializedDestType, 
            /* diag */ undefined, srcTypeVarContext, destTypeVarContext, (flags ^ 2 /* AssignTypeFlags.ReverseTypeVarMatching */) | 256 /* AssignTypeFlags.RetainLiteralsForTypeVar */, recursionCount);
            if ((flags & 2 /* AssignTypeFlags.ReverseTypeVarMatching */) === 0) {
                specializedDestType = (0, typeUtils_1.applySolvedTypeVars)(destType, destTypeVarContext);
            }
            else {
                specializedSrcType = (0, typeUtils_1.applySolvedTypeVars)(srcType, srcTypeVarContext);
            }
        }
        if (!assignType(specializedSrcType, specializedDestType, diag === null || diag === void 0 ? void 0 : diag.createAddendum(), srcTypeVarContext, destTypeVarContext, flags, recursionCount)) {
            if (diag && paramIndex !== undefined) {
                diag.addMessage(localize_1.LocAddendum.paramAssignment().format({
                    index: paramIndex + 1,
                    sourceType: printType(destType),
                    destType: printType(srcType),
                }));
            }
            return false;
        }
        return true;
    }
    // Determines whether we need to pack some of the source positionals
    // into a tuple that matches a variadic *args parameter in the destination.
    function adjustSourceParamDetailsForDestVariadic(srcDetails, destDetails) {
        var _a;
        // If there is no *args parameter in the dest, we have nothing to do.
        if (destDetails.argsIndex === undefined) {
            return;
        }
        // If the *args parameter isn't an unpacked TypeVarTuple or tuple,
        // we have nothing to do.
        if (!(0, types_1.isUnpacked)(destDetails.params[destDetails.argsIndex].type)) {
            return;
        }
        // If the source doesn't have enough positional parameters, we have nothing to do.
        if (srcDetails.params.length < destDetails.argsIndex) {
            return;
        }
        let srcLastToPackIndex = srcDetails.params.findIndex((p, i) => {
            (0, debug_1.assert)(destDetails.argsIndex !== undefined);
            return i >= destDetails.argsIndex && p.kind === parameterUtils_1.ParameterKind.Keyword;
        });
        if (srcLastToPackIndex < 0) {
            srcLastToPackIndex = srcDetails.params.length;
        }
        // If both the source and dest have an *args parameter but the dest's is
        // in a later position, then we can't assign the source's *args to the dest.
        // Don't make any adjustment in this case.
        if (srcDetails.argsIndex !== undefined && destDetails.argsIndex > srcDetails.argsIndex) {
            return;
        }
        const destFirstNonPositional = (_a = destDetails.firstKeywordOnlyIndex) !== null && _a !== void 0 ? _a : destDetails.params.length;
        const suffixLength = destFirstNonPositional - destDetails.argsIndex - 1;
        const srcPositionalsToPack = srcDetails.params.slice(destDetails.argsIndex, srcLastToPackIndex - suffixLength);
        const srcTupleTypes = [];
        srcPositionalsToPack.forEach((entry) => {
            if (entry.param.category === 1 /* ParameterCategory.ArgsList */) {
                if ((0, types_1.isUnpackedVariadicTypeVar)(entry.type)) {
                    srcTupleTypes.push({ type: entry.type, isUnbounded: false });
                }
                else if ((0, types_1.isUnpackedClass)(entry.type) && entry.type.tupleTypeArguments) {
                    (0, collectionUtils_1.appendArray)(srcTupleTypes, entry.type.tupleTypeArguments);
                }
                else {
                    srcTupleTypes.push({ type: entry.type, isUnbounded: true });
                }
            }
            else {
                srcTupleTypes.push({ type: entry.type, isUnbounded: false, isOptional: entry.param.hasDefault });
            }
        });
        if (srcTupleTypes.length !== 1 || !(0, types_1.isVariadicTypeVar)(srcTupleTypes[0].type)) {
            const srcPositionalsType = makeTupleObject(srcTupleTypes, /* isUnpackedTuple */ true);
            // Snip out the portion of the source positionals that map to the variadic
            // dest parameter and replace it with a single parameter that is typed as a
            // tuple containing the individual types of the replaced parameters.
            srcDetails.params = [
                ...srcDetails.params.slice(0, destDetails.argsIndex),
                {
                    param: {
                        category: 1 /* ParameterCategory.ArgsList */,
                        name: '_arg_combined',
                        isNameSynthesized: true,
                        hasDeclaredType: true,
                        type: srcPositionalsType,
                    },
                    type: srcPositionalsType,
                    index: -1,
                    kind: parameterUtils_1.ParameterKind.Positional,
                },
                ...srcDetails.params.slice(destDetails.argsIndex + srcPositionalsToPack.length, srcDetails.params.length),
            ];
            const argsIndex = srcDetails.params.findIndex((param) => param.param.category === 1 /* ParameterCategory.ArgsList */);
            srcDetails.argsIndex = argsIndex >= 0 ? argsIndex : undefined;
            const kwargsIndex = srcDetails.params.findIndex((param) => param.param.category === 2 /* ParameterCategory.KwargsDict */);
            srcDetails.kwargsIndex = kwargsIndex >= 0 ? kwargsIndex : undefined;
            const firstKeywordOnlyIndex = srcDetails.params.findIndex((param) => param.kind === parameterUtils_1.ParameterKind.Keyword);
            srcDetails.firstKeywordOnlyIndex = firstKeywordOnlyIndex >= 0 ? firstKeywordOnlyIndex : undefined;
            srcDetails.positionOnlyParamCount = Math.max(0, srcDetails.params.findIndex((p) => p.kind !== parameterUtils_1.ParameterKind.Positional ||
                p.param.category !== 0 /* ParameterCategory.Simple */ ||
                p.param.hasDefault));
        }
    }
    function assignFunction(destType, srcType, diag, destTypeVarContext, srcTypeVarContext, flags, recursionCount) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        let canAssign = true;
        const checkReturnType = (flags & 64 /* AssignTypeFlags.SkipFunctionReturnTypeCheck */) === 0;
        const reverseMatching = (flags & 2 /* AssignTypeFlags.ReverseTypeVarMatching */) !== 0;
        flags &= ~64 /* AssignTypeFlags.SkipFunctionReturnTypeCheck */;
        const destParamSpec = types_1.FunctionType.getParamSpecFromArgsKwargs(destType);
        if (destParamSpec) {
            destType = types_1.FunctionType.cloneRemoveParamSpecArgsKwargs(destType);
        }
        const srcParamSpec = types_1.FunctionType.getParamSpecFromArgsKwargs(srcType);
        if (srcParamSpec) {
            srcType = types_1.FunctionType.cloneRemoveParamSpecArgsKwargs(srcType);
        }
        const destParamDetails = (0, parameterUtils_1.getParameterListDetails)(destType);
        const srcParamDetails = (0, parameterUtils_1.getParameterListDetails)(srcType);
        adjustSourceParamDetailsForDestVariadic(reverseMatching ? destParamDetails : srcParamDetails, reverseMatching ? srcParamDetails : destParamDetails);
        const targetIncludesParamSpec = reverseMatching ? !!srcParamSpec : !!destParamSpec;
        const destPositionalCount = (_a = destParamDetails.firstKeywordOnlyIndex) !== null && _a !== void 0 ? _a : destParamDetails.params.length;
        const srcPositionalCount = (_b = srcParamDetails.firstKeywordOnlyIndex) !== null && _b !== void 0 ? _b : srcParamDetails.params.length;
        const positionalsToMatch = Math.min(destPositionalCount, srcPositionalCount);
        // Match positional parameters.
        for (let paramIndex = 0; paramIndex < positionalsToMatch; paramIndex++) {
            if (paramIndex === 0 &&
                destType.details.methodClass &&
                (flags & 65536 /* AssignTypeFlags.IgnoreSelfClsParamCompatibility */) !== 0) {
                if (types_1.FunctionType.isInstanceMethod(destType) || types_1.FunctionType.isClassMethod(destType)) {
                    continue;
                }
            }
            // Skip over the *args parameter since it's handled separately below.
            if (paramIndex === destParamDetails.argsIndex) {
                continue;
            }
            const destParam = destParamDetails.params[paramIndex];
            const srcParam = srcParamDetails.params[paramIndex];
            // Find the original index of this source param. If we synthesized it above (for
            // a variadic parameter), it may not be found.
            const srcParamType = srcParam.type;
            const destParamType = destParam.type;
            const destParamName = (_c = destParam.param.name) !== null && _c !== void 0 ? _c : '';
            const srcParamName = (_d = srcParam.param.name) !== null && _d !== void 0 ? _d : '';
            if (destParamName) {
                const isDestPositionalOnly = destParam.kind === parameterUtils_1.ParameterKind.Positional;
                if (!isDestPositionalOnly &&
                    destParam.param.category !== 1 /* ParameterCategory.ArgsList */ &&
                    srcParam.param.category !== 1 /* ParameterCategory.ArgsList */) {
                    if (srcParam.kind === parameterUtils_1.ParameterKind.Positional) {
                        diag === null || diag === void 0 ? void 0 : diag.createAddendum().addMessage(localize_1.LocAddendum.functionParamPositionOnly().format({
                            name: destParamName,
                        }));
                        canAssign = false;
                    }
                    else if (destParamName !== srcParamName) {
                        diag === null || diag === void 0 ? void 0 : diag.createAddendum().addMessage(localize_1.LocAddendum.functionParamName().format({
                            srcName: srcParamName,
                            destName: destParamName,
                        }));
                        canAssign = false;
                    }
                }
            }
            if (!!destParam.param.hasDefault &&
                !srcParam.param.hasDefault &&
                paramIndex !== srcParamDetails.argsIndex) {
                diag === null || diag === void 0 ? void 0 : diag.createAddendum().addMessage(localize_1.LocAddendum.functionParamDefaultMissing().format({
                    name: srcParamName,
                }));
                canAssign = false;
            }
            // Handle the special case of an overloaded __init__ method whose self
            // parameter is annotated.
            if (paramIndex === 0 &&
                srcType.details.name === '__init__' &&
                types_1.FunctionType.isInstanceMethod(srcType) &&
                destType.details.name === '__init__' &&
                types_1.FunctionType.isInstanceMethod(destType) &&
                types_1.FunctionType.isOverloaded(destType) &&
                destParam.param.hasDeclaredType) {
                continue;
            }
            if ((0, types_1.isUnpacked)(srcParamType)) {
                canAssign = false;
            }
            else if (!assignFunctionParameter(destParamType, srcParamType, paramIndex, diag === null || diag === void 0 ? void 0 : diag.createAddendum(), destTypeVarContext, srcTypeVarContext, flags, recursionCount)) {
                // Handle the special case where the source parameter is a synthesized
                // TypeVar for "self" or "cls".
                if ((flags & 512 /* AssignTypeFlags.SkipSelfClsTypeCheck */) === 0 ||
                    !(0, types_1.isTypeVar)(srcParamType) ||
                    !srcParamType.details.isSynthesized) {
                    canAssign = false;
                }
            }
            else if (destParam.kind !== parameterUtils_1.ParameterKind.Positional &&
                srcParam.kind === parameterUtils_1.ParameterKind.Positional &&
                srcParamDetails.kwargsIndex === undefined &&
                !srcParamDetails.params.some((p) => p.kind === parameterUtils_1.ParameterKind.Keyword &&
                    p.param.category === 0 /* ParameterCategory.Simple */ &&
                    p.param.name === destParam.param.name)) {
                diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.namedParamMissingInSource().format({
                    name: (_e = destParam.param.name) !== null && _e !== void 0 ? _e : '',
                }));
                canAssign = false;
            }
        }
        if (!types_1.FunctionType.isGradualCallableForm(destType) &&
            destParamDetails.firstPositionOrKeywordIndex < srcParamDetails.positionOnlyParamCount &&
            !targetIncludesParamSpec) {
            diag === null || diag === void 0 ? void 0 : diag.createAddendum().addMessage(localize_1.LocAddendum.argsPositionOnly().format({
                expected: srcParamDetails.positionOnlyParamCount,
                received: destParamDetails.firstPositionOrKeywordIndex,
            }));
            canAssign = false;
        }
        if (destPositionalCount < srcPositionalCount && !targetIncludesParamSpec) {
            for (let i = destPositionalCount; i < srcPositionalCount; i++) {
                // If the dest has an *args parameter, make sure it can accept the remaining
                // positional arguments in the source.
                if (destParamDetails.argsIndex !== undefined) {
                    const destArgsType = destParamDetails.params[destParamDetails.argsIndex].type;
                    const srcParamType = srcParamDetails.params[i].type;
                    if (!assignFunctionParameter(destArgsType, srcParamType, i, diag === null || diag === void 0 ? void 0 : diag.createAddendum(), destTypeVarContext, srcTypeVarContext, flags, recursionCount)) {
                        canAssign = false;
                    }
                    continue;
                }
                // If The source parameter has a default value, it is OK for the
                // corresponding dest parameter to be missing.
                const srcParam = srcParamDetails.params[i];
                if (srcParam.param.hasDefault) {
                    // Assign default arg value in case it is needed for
                    // populating TypeVar constraints.
                    const paramInfo = srcParamDetails.params[i];
                    const defaultArgType = (_f = paramInfo.defaultArgType) !== null && _f !== void 0 ? _f : paramInfo.param.defaultType;
                    if (defaultArgType &&
                        !assignType(paramInfo.type, defaultArgType, diag === null || diag === void 0 ? void 0 : diag.createAddendum(), srcTypeVarContext, 
                        /* destTypeVarContext */ undefined, flags, recursionCount)) {
                        canAssign = false;
                    }
                    continue;
                }
                // If the source parameter is also addressable by keyword, it is OK
                // that there is no matching positional parameter in the dest.
                if (srcParam.kind === parameterUtils_1.ParameterKind.Standard) {
                    continue;
                }
                // If the source parameter is a variadic, it is OK that there is no
                // matching positional parameter in the dest.
                if (srcParam.param.category === 1 /* ParameterCategory.ArgsList */) {
                    continue;
                }
                const nonDefaultSrcParamCount = srcParamDetails.params.filter((p) => !!p.param.name && !p.param.hasDefault && p.param.category === 0 /* ParameterCategory.Simple */).length;
                diag === null || diag === void 0 ? void 0 : diag.createAddendum().addMessage(localize_1.LocAddendum.functionTooFewParams().format({
                    expected: nonDefaultSrcParamCount,
                    received: destPositionalCount,
                }));
                canAssign = false;
                break;
            }
        }
        else if (srcPositionalCount < destPositionalCount) {
            if (srcParamDetails.argsIndex !== undefined) {
                // Make sure the remaining dest parameters can be assigned to the source
                // *args parameter type.
                const srcArgsType = srcParamDetails.params[srcParamDetails.argsIndex].type;
                for (let paramIndex = srcPositionalCount; paramIndex < destPositionalCount; paramIndex++) {
                    if (paramIndex === srcParamDetails.argsIndex) {
                        continue;
                    }
                    const destParamType = destParamDetails.params[paramIndex].type;
                    if ((0, types_1.isVariadicTypeVar)(destParamType) && !(0, types_1.isVariadicTypeVar)(srcArgsType)) {
                        diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.typeVarTupleRequiresKnownLength());
                        canAssign = false;
                    }
                    else {
                        if (!assignFunctionParameter(destParamType, srcArgsType, paramIndex, diag === null || diag === void 0 ? void 0 : diag.createAddendum(), destTypeVarContext, srcTypeVarContext, flags, recursionCount)) {
                            canAssign = false;
                        }
                        if (destParamDetails.params[paramIndex].kind !== parameterUtils_1.ParameterKind.Positional &&
                            srcParamDetails.kwargsIndex === undefined) {
                            diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.namedParamMissingInSource().format({
                                name: (_g = destParamDetails.params[paramIndex].param.name) !== null && _g !== void 0 ? _g : '',
                            }));
                            canAssign = false;
                        }
                    }
                }
            }
            else if (!srcParamDetails.paramSpec) {
                // If the dest contains a *args, remove it from the positional count
                // because it's OK for zero source args to match it.
                let adjDestPositionalCount = destPositionalCount;
                if (destParamDetails.argsIndex !== undefined && destParamDetails.argsIndex < destPositionalCount) {
                    adjDestPositionalCount--;
                }
                if (srcPositionalCount < adjDestPositionalCount) {
                    diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.functionTooManyParams().format({
                        expected: srcPositionalCount,
                        received: destPositionalCount,
                    }));
                    canAssign = false;
                }
            }
        }
        // If both src and dest have an "*args" parameter, make sure
        // their types are compatible.
        if (srcParamDetails.argsIndex !== undefined &&
            destParamDetails.argsIndex !== undefined &&
            !types_1.FunctionType.isGradualCallableForm(destType)) {
            let destArgsType = destParamDetails.params[destParamDetails.argsIndex].type;
            let srcArgsType = srcParamDetails.params[srcParamDetails.argsIndex].type;
            if (!(0, types_1.isUnpacked)(destArgsType)) {
                destArgsType = makeTupleObject([{ type: destArgsType, isUnbounded: true }], /* isUnpackedTuple */ true);
            }
            if (!(0, types_1.isUnpacked)(srcArgsType)) {
                srcArgsType = makeTupleObject([{ type: srcArgsType, isUnbounded: true }], /* isUnpackedTuple */ true);
            }
            if (!assignFunctionParameter(destArgsType, srcArgsType, destParamDetails.params[destParamDetails.argsIndex].index, diag === null || diag === void 0 ? void 0 : diag.createAddendum(), destTypeVarContext, srcTypeVarContext, flags, recursionCount)) {
                canAssign = false;
            }
        }
        // If the dest has an "*args" but the source doesn't, report the incompatibility.
        // The converse situation is OK.
        if (!types_1.FunctionType.isGradualCallableForm(destType) &&
            srcParamDetails.argsIndex === undefined &&
            srcParamSpec === undefined &&
            destParamDetails.argsIndex !== undefined &&
            !destParamDetails.hasUnpackedVariadicTypeVar) {
            diag === null || diag === void 0 ? void 0 : diag.createAddendum().addMessage(localize_1.LocAddendum.argsParamMissing().format({
                paramName: (_h = destParamDetails.params[destParamDetails.argsIndex].param.name) !== null && _h !== void 0 ? _h : '',
            }));
            canAssign = false;
        }
        // Handle matching of named (keyword) parameters.
        if (!targetIncludesParamSpec) {
            // Build a dictionary of named parameters in the dest.
            const destParamMap = new Map();
            if (destParamDetails.firstKeywordOnlyIndex !== undefined) {
                destParamDetails.params.forEach((param, index) => {
                    if (index >= destParamDetails.firstKeywordOnlyIndex) {
                        if (param.param.name && param.param.category === 0 /* ParameterCategory.Simple */) {
                            destParamMap.set(param.param.name, param);
                        }
                    }
                });
            }
            // If the dest has fewer positional arguments than the source, the remaining
            // positional arguments in the source can be treated as named arguments.
            let srcStartOfNamed = srcParamDetails.firstKeywordOnlyIndex !== undefined
                ? srcParamDetails.firstKeywordOnlyIndex
                : srcParamDetails.params.length;
            if (destPositionalCount < srcPositionalCount && destParamDetails.argsIndex === undefined) {
                srcStartOfNamed = destPositionalCount;
            }
            if (srcStartOfNamed >= 0) {
                srcParamDetails.params.forEach((srcParamInfo, index) => {
                    var _a;
                    if (index >= srcStartOfNamed) {
                        if (srcParamInfo.param.name &&
                            srcParamInfo.param.category === 0 /* ParameterCategory.Simple */ &&
                            srcParamInfo.kind !== parameterUtils_1.ParameterKind.Positional) {
                            const destParamInfo = destParamMap.get(srcParamInfo.param.name);
                            const paramDiag = diag === null || diag === void 0 ? void 0 : diag.createAddendum();
                            const srcParamType = srcParamInfo.type;
                            if (!destParamInfo) {
                                if (destParamDetails.kwargsIndex === undefined && !srcParamInfo.param.hasDefault) {
                                    if (paramDiag) {
                                        paramDiag.addMessage(localize_1.LocAddendum.namedParamMissingInDest().format({
                                            name: srcParamInfo.param.name,
                                        }));
                                    }
                                    canAssign = false;
                                }
                                else if (destParamDetails.kwargsIndex !== undefined) {
                                    // Make sure we can assign the type to the Kwargs.
                                    if (!assignFunctionParameter(destParamDetails.params[destParamDetails.kwargsIndex].type, srcParamType, destParamDetails.params[destParamDetails.kwargsIndex].index, diag === null || diag === void 0 ? void 0 : diag.createAddendum(), destTypeVarContext, srcTypeVarContext, flags, recursionCount)) {
                                        canAssign = false;
                                    }
                                }
                                else if (srcParamInfo.param.hasDefault) {
                                    // Assign default arg values in case they are needed for
                                    // populating TypeVar constraints.
                                    const defaultArgType = (_a = srcParamInfo.defaultArgType) !== null && _a !== void 0 ? _a : srcParamInfo.param.defaultType;
                                    if (defaultArgType &&
                                        !assignType(srcParamInfo.type, defaultArgType, diag === null || diag === void 0 ? void 0 : diag.createAddendum(), srcTypeVarContext, 
                                        /* destTypeVarContext */ undefined, flags, recursionCount)) {
                                        canAssign = false;
                                    }
                                }
                            }
                            else {
                                const destParamType = destParamInfo.type;
                                const specializedDestParamType = destTypeVarContext
                                    ? (0, typeUtils_1.applySolvedTypeVars)(destParamType, destTypeVarContext)
                                    : destParamType;
                                if (!assignFunctionParameter(destParamInfo.type, srcParamType, 
                                /* paramIndex */ undefined, paramDiag === null || paramDiag === void 0 ? void 0 : paramDiag.createAddendum(), destTypeVarContext, srcTypeVarContext, flags, recursionCount)) {
                                    if (paramDiag) {
                                        paramDiag.addMessage(localize_1.LocAddendum.namedParamTypeMismatch().format({
                                            name: srcParamInfo.param.name,
                                            sourceType: printType(specializedDestParamType),
                                            destType: printType(srcParamType),
                                        }));
                                    }
                                    canAssign = false;
                                }
                                if (!!destParamInfo.param.hasDefault && !srcParamInfo.param.hasDefault) {
                                    diag === null || diag === void 0 ? void 0 : diag.createAddendum().addMessage(localize_1.LocAddendum.functionParamDefaultMissing().format({
                                        name: srcParamInfo.param.name,
                                    }));
                                    canAssign = false;
                                }
                                destParamMap.delete(srcParamInfo.param.name);
                            }
                        }
                    }
                });
            }
            // See if there are any unmatched named parameters.
            destParamMap.forEach((destParamInfo, paramName) => {
                if (srcParamDetails.kwargsIndex !== undefined && destParamInfo.param.name) {
                    // Make sure the src kwargs type is compatible.
                    if (!assignFunctionParameter(destParamInfo.param.type, srcParamDetails.params[srcParamDetails.kwargsIndex].type, destParamInfo.index, diag === null || diag === void 0 ? void 0 : diag.createAddendum(), destTypeVarContext, srcTypeVarContext, flags, recursionCount)) {
                        canAssign = false;
                    }
                    destParamMap.delete(paramName);
                }
                else {
                    diag === null || diag === void 0 ? void 0 : diag.createAddendum().addMessage(localize_1.LocAddendum.namedParamMissingInSource().format({ name: paramName }));
                    canAssign = false;
                }
            });
            // If both src and dest have a "**kwargs" parameter, make sure their types are compatible.
            if (srcParamDetails.kwargsIndex !== undefined && destParamDetails.kwargsIndex !== undefined) {
                if (!assignFunctionParameter(destParamDetails.params[destParamDetails.kwargsIndex].type, srcParamDetails.params[srcParamDetails.kwargsIndex].type, destParamDetails.params[destParamDetails.kwargsIndex].index, diag === null || diag === void 0 ? void 0 : diag.createAddendum(), destTypeVarContext, srcTypeVarContext, flags, recursionCount)) {
                    canAssign = false;
                }
            }
            // If the dest has a "**kwargs" but the source doesn't, report the incompatibility.
            // The converse situation is OK.
            if (!types_1.FunctionType.isGradualCallableForm(destType) &&
                srcParamDetails.kwargsIndex === undefined &&
                srcParamSpec === undefined &&
                destParamDetails.kwargsIndex !== undefined) {
                diag === null || diag === void 0 ? void 0 : diag.createAddendum().addMessage(localize_1.LocAddendum.kwargsParamMissing().format({
                    paramName: destParamDetails.params[destParamDetails.kwargsIndex].param.name,
                }));
                canAssign = false;
            }
        }
        // If the source and the dest are using the same ParamSpec, any additional
        // concatenated parameters must match.
        if (targetIncludesParamSpec && (srcParamSpec === null || srcParamSpec === void 0 ? void 0 : srcParamSpec.nameWithScope) === (destParamSpec === null || destParamSpec === void 0 ? void 0 : destParamSpec.nameWithScope)) {
            if (srcParamDetails.params.length !== destParamDetails.params.length) {
                canAssign = false;
            }
        }
        const effectiveSrcTypeVarContext = reverseMatching ? destTypeVarContext : srcTypeVarContext;
        // If the target function was generic and we solved some of the type variables
        // in that generic type, assign them back to the destination typeVar.
        const typeVarSignatureContext = effectiveSrcTypeVarContext.getPrimarySignature();
        typeVarSignatureContext.getTypeVars().forEach((typeVarEntry) => {
            assignType(typeVarEntry.typeVar, typeVarSignatureContext.getTypeVarType(typeVarEntry.typeVar), 
            /* diag */ undefined, destTypeVarContext, srcTypeVarContext, 0 /* AssignTypeFlags.Default */, recursionCount);
        });
        // Are we assigning to a function with a ParamSpec?
        if (targetIncludesParamSpec) {
            const effectiveSrcType = reverseMatching ? destType : srcType;
            const effectiveDestType = reverseMatching ? srcType : destType;
            const effectiveSrcParamSpec = reverseMatching ? destParamSpec : srcParamSpec;
            const effectiveDestParamSpec = reverseMatching ? srcParamSpec : destParamSpec;
            if (effectiveDestParamSpec) {
                const requiredMatchParamCount = effectiveDestType.details.parameters.filter((p) => {
                    if (!p.name) {
                        return false;
                    }
                    if (p.category === 0 /* ParameterCategory.Simple */ && (0, types_1.isParamSpec)(p.type)) {
                        return false;
                    }
                    return true;
                }).length;
                let matchedParamCount = 0;
                const remainingParams = [];
                // If there are parameters in the source that are not matched
                // to parameters in the dest, assume these are concatenated on
                // to the ParamSpec.
                effectiveSrcType.details.parameters.forEach((p, index) => {
                    if (matchedParamCount < requiredMatchParamCount) {
                        if (p.name) {
                            matchedParamCount++;
                        }
                    }
                    else if ((0, types_1.isPositionOnlySeparator)(p) && remainingParams.length === 0) {
                        // Don't bother pushing a position-only separator if it
                        // is the first remaining param.
                    }
                    else {
                        remainingParams.push({
                            category: p.category,
                            name: p.name,
                            isNameSynthesized: p.isNameSynthesized,
                            hasDefault: p.hasDefault,
                            hasDeclaredType: p.hasDeclaredType,
                            defaultValueExpression: p.defaultValueExpression,
                            type: types_1.FunctionType.getEffectiveParameterType(effectiveSrcType, index),
                        });
                    }
                });
                // If there are remaining parameters and the source and dest do not contain
                // the same ParamSpec, synthesize a function for the remaining parameters.
                if (remainingParams.length > 0 ||
                    !effectiveSrcParamSpec ||
                    !(0, types_1.isTypeSame)(effectiveSrcParamSpec, effectiveDestParamSpec, { ignoreTypeFlags: true })) {
                    const remainingFunction = types_1.FunctionType.createInstance('', '', '', effectiveSrcType.details.flags | 64 /* FunctionTypeFlags.SynthesizedMethod */, effectiveSrcType.details.docString);
                    remainingFunction.details.deprecatedMessage = effectiveSrcType.details.deprecatedMessage;
                    remainingFunction.details.typeVarScopeId = effectiveSrcType.details.typeVarScopeId;
                    remainingFunction.details.constructorTypeVarScopeId =
                        effectiveSrcType.details.constructorTypeVarScopeId;
                    remainingFunction.details.methodClass = effectiveSrcType.details.methodClass;
                    remainingParams.forEach((param) => {
                        types_1.FunctionType.addParameter(remainingFunction, param);
                    });
                    if (effectiveSrcParamSpec) {
                        types_1.FunctionType.addParamSpecVariadics(remainingFunction, (0, typeUtils_1.convertToInstance)(effectiveSrcParamSpec));
                    }
                    types_1.FunctionType.addHigherOrderTypeVarScopeIds(remainingFunction, effectiveSrcType.details.higherOrderTypeVarScopeIds);
                    if (!assignType(effectiveDestParamSpec, remainingFunction, 
                    /* diag */ undefined, destTypeVarContext, srcTypeVarContext, flags)) {
                        // If we couldn't assign the function to the ParamSpec, see if we can
                        // assign only the ParamSpec. This is possible if there were no
                        // remaining parameters.
                        if (remainingParams.length > 0 ||
                            !effectiveSrcParamSpec ||
                            !assignType((0, typeUtils_1.convertToInstance)(effectiveDestParamSpec), (0, typeUtils_1.convertToInstance)(effectiveSrcParamSpec), 
                            /* diag */ undefined, destTypeVarContext, srcTypeVarContext, flags)) {
                            canAssign = false;
                        }
                    }
                }
            }
        }
        // Match the return parameter.
        if (checkReturnType) {
            const destReturnType = getFunctionEffectiveReturnType(destType);
            if (!(0, types_1.isAnyOrUnknown)(destReturnType)) {
                const srcReturnType = (0, typeUtils_1.applySolvedTypeVars)(getFunctionEffectiveReturnType(srcType), srcTypeVarContext);
                const returnDiag = diag === null || diag === void 0 ? void 0 : diag.createAddendum();
                let isReturnTypeCompatible = false;
                let effectiveFlags = flags;
                // If the source has a declared return type that includes a literal
                // in its annotation, assume that we will want the constraint
                // solver to retain literals.
                if (srcType.details.declaredReturnType &&
                    (0, typeUtils_1.containsLiteralType)(srcType.details.declaredReturnType, /* includeTypeArgs */ true)) {
                    effectiveFlags |= 256 /* AssignTypeFlags.RetainLiteralsForTypeVar */;
                }
                if (assignType(destReturnType, srcReturnType, returnDiag === null || returnDiag === void 0 ? void 0 : returnDiag.createAddendum(), destTypeVarContext, srcTypeVarContext, effectiveFlags, recursionCount)) {
                    isReturnTypeCompatible = true;
                }
                else {
                    // Handle the special case where the return type is a TypeGuard[T]
                    // or TypeIs[T]. This should also act as a bool, since that's its
                    // type at runtime.
                    if ((0, types_1.isClassInstance)(srcReturnType) &&
                        types_1.ClassType.isBuiltIn(srcReturnType, ['TypeGuard', 'TypeIs']) &&
                        boolClass &&
                        (0, types_1.isInstantiableClass)(boolClass)) {
                        if (assignType(destReturnType, types_1.ClassType.cloneAsInstance(boolClass), returnDiag === null || returnDiag === void 0 ? void 0 : returnDiag.createAddendum(), destTypeVarContext, srcTypeVarContext, flags, recursionCount)) {
                            isReturnTypeCompatible = true;
                        }
                    }
                }
                if (!isReturnTypeCompatible) {
                    if (returnDiag) {
                        returnDiag.addMessage(localize_1.LocAddendum.functionReturnTypeMismatch().format({
                            sourceType: printType(srcReturnType),
                            destType: printType(destReturnType),
                        }));
                    }
                    canAssign = false;
                }
            }
        }
        // Apply any solved source TypeVars to the dest TypeVar solutions. This
        // allows for higher-order functions to accept generic callbacks.
        (0, typeUtils_1.applySourceContextTypeVars)(destTypeVarContext, srcTypeVarContext);
        return canAssign;
    }
    // If the declaredType contains type arguments that are "Any" and
    // the corresponding type argument in the assignedType is not "Any",
    // replace that type argument in the assigned type. This function assumes
    // that the caller has already verified that the assignedType is assignable
    // to the declaredType.
    function replaceTypeArgsWithAny(node, declaredType, assignedType, recursionCount = 0) {
        if (recursionCount > types_1.maxTypeRecursionCount) {
            return undefined;
        }
        recursionCount++;
        if (assignedType.details.typeParameters.length > 0 &&
            assignedType.typeArguments &&
            assignedType.typeArguments.length <= assignedType.details.typeParameters.length &&
            !assignedType.tupleTypeArguments) {
            const typeVarContext = new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(assignedType));
            (0, constraintSolver_1.addConstraintsForExpectedType)(evaluatorInterface, types_1.ClassType.cloneForSpecialization(assignedType, 
            /* typeArguments */ undefined, 
            /* isTypeArgumentExplicit */ false), declaredType, typeVarContext, ParseTreeUtils.getTypeVarScopesForNode(node), node.start);
            let replacedTypeArg = false;
            const newTypeArgs = assignedType.typeArguments.map((typeArg, index) => {
                const typeParam = assignedType.details.typeParameters[index];
                const expectedTypeArgType = typeVarContext.getPrimarySignature().getTypeVarType(typeParam);
                if (expectedTypeArgType) {
                    if ((0, types_1.isAnyOrUnknown)(expectedTypeArgType) || (0, types_1.isAnyOrUnknown)(typeArg)) {
                        replacedTypeArg = true;
                        return expectedTypeArgType;
                    }
                    if ((0, types_1.isClassInstance)(expectedTypeArgType) && (0, types_1.isClassInstance)(typeArg)) {
                        // Recursively replace Any in the type argument.
                        const recursiveReplacement = replaceTypeArgsWithAny(node, expectedTypeArgType, typeArg, recursionCount);
                        if (recursiveReplacement) {
                            replacedTypeArg = true;
                            return recursiveReplacement;
                        }
                    }
                    else if ((0, typeUtils_1.containsAnyRecursive)(expectedTypeArgType)) {
                        // If the expected type arg contains an Any, we can replace it with
                        // a version that doesn't contain Any if the replacement doesn't violate
                        // the variance of the type parameter.
                        const variance = types_1.TypeVarType.getVariance(typeParam);
                        const isSubtype = assignType(expectedTypeArgType, typeArg);
                        const isSupertype = assignType(typeArg, expectedTypeArgType);
                        if ((variance === 4 /* Variance.Contravariant */ || isSubtype) &&
                            (variance === 3 /* Variance.Covariant */ || isSupertype)) {
                            replacedTypeArg = true;
                            return expectedTypeArgType;
                        }
                    }
                }
                return typeArg;
            });
            if (replacedTypeArg) {
                return types_1.ClassType.cloneForSpecialization(assignedType, newTypeArgs, /* isTypeArgumentExplicit */ true);
            }
        }
        // If the declared and assigned types are the same generic type but the assigned type
        // contains one or more unknowns, use the declared type instead.
        if (types_1.ClassType.isSameGenericClass(declaredType, assignedType)) {
            if ((0, typeUtils_1.containsAnyRecursive)(assignedType) && !(0, typeUtils_1.containsAnyRecursive)(declaredType)) {
                return declaredType;
            }
        }
        return undefined;
    }
    // When a value is assigned to a variable with a declared type,
    // we may be able to narrow the type based on the assignment.
    function narrowTypeBasedOnAssignment(node, declaredType, assignedTypeResult) {
        // TODO: The rules for narrowing types on assignment are not defined in
        // the typing spec. Pyright's current logic is currently not even internally
        // consistent and probably not sound from a type theory perspective. It
        // should be completely reworked once there has been a public discussion
        // about the correct behavior.
        // If the result is incomplete, do not attempt to narrow the type.
        if (assignedTypeResult.isIncomplete) {
            return assignedTypeResult;
        }
        const narrowedType = (0, typeUtils_1.mapSubtypes)(assignedTypeResult.type, (assignedSubtype) => {
            // Handle the special case where the assigned type is a literal type.
            // Some types include very large unions of literal types, and we don't
            // want to use an n^2 loop to compare them.
            if ((0, types_1.isClass)(assignedSubtype) && (0, typeUtils_1.isLiteralType)(assignedSubtype)) {
                if ((0, types_1.isUnion)(declaredType) && types_1.UnionType.containsType(declaredType, assignedSubtype)) {
                    return assignedSubtype;
                }
            }
            const narrowedSubtype = (0, typeUtils_1.mapSubtypes)(declaredType, (declaredSubtype) => {
                // We can't narrow "Any".
                if ((0, types_1.isAnyOrUnknown)(declaredSubtype)) {
                    return declaredSubtype;
                }
                if (assignType(declaredSubtype, assignedSubtype)) {
                    // If the assigned subtype is Any, stick with the declared type.
                    if ((0, types_1.isAny)(assignedSubtype)) {
                        return declaredSubtype;
                    }
                    if ((0, types_1.isClass)(declaredSubtype) &&
                        (0, types_1.isClass)(assignedSubtype) &&
                        types_1.TypeBase.isInstance(declaredSubtype) === types_1.TypeBase.isInstance(assignedSubtype)) {
                        const result = replaceTypeArgsWithAny(node, declaredSubtype, assignedSubtype);
                        if (result) {
                            assignedSubtype = result;
                        }
                        return assignedSubtype;
                    }
                    if (!(0, types_1.isTypeVar)(declaredSubtype) && (0, types_1.isTypeVar)(assignedSubtype)) {
                        // If the source is an unsolved TypeVar but the declared type is concrete,
                        // use the concrete type.
                        return declaredSubtype;
                    }
                    // If the declared type doesn't contain any `Any` but the assigned
                    // type does, stick with the declared type. We don't include unknowns
                    // in the assigned subtype check here so unknowns are preserved so
                    // reportUnknownVariableType assignment diagnostics are reported.
                    // TODO - this is an inconsistency because Any and Unknown should
                    // always be treated the same for purposes of type narrowing. This
                    // should be revisited once the narrowing-on-assignment behavior
                    // is properly specified in the typing spec.
                    if ((0, typeUtils_1.containsAnyRecursive)(assignedSubtype, /* includeUnknown */ false) &&
                        !(0, typeUtils_1.containsAnyRecursive)(declaredSubtype)) {
                        return declaredSubtype;
                    }
                    return assignedSubtype;
                }
                return undefined;
            });
            // If we couldn't assign the assigned subtype any of the declared
            // subtypes, the types are incompatible. Return the unnarrowed form.
            if ((0, types_1.isNever)(narrowedSubtype)) {
                return assignedSubtype;
            }
            return narrowedSubtype;
        });
        // If the result of narrowing is an Unknown that is incomplete, propagate the
        // incomplete type for the benefit of code flow analysis.
        // If the result of narrowing is a complete Unknown, combine the Unknown type
        // with the declared type. In strict mode, this will retain the "unknown type"
        // diagnostics while still providing reasonable completion suggestions.
        if ((0, typeUtils_1.isIncompleteUnknown)(narrowedType)) {
            return { type: narrowedType };
        }
        else if ((0, types_1.isUnknown)(narrowedType)) {
            return { type: (0, types_1.combineTypes)([narrowedType, declaredType]) };
        }
        return { type: narrowedType };
    }
    function validateOverrideMethod(baseMethod, overrideMethod, baseClass, diag, enforceParamNames = true) {
        // If we're overriding a non-method with a method, report it as an error.
        // This occurs when a non-property overrides a property.
        if (!(0, types_1.isFunction)(baseMethod) && !(0, types_1.isOverloadedFunction)(baseMethod)) {
            diag.addMessage(localize_1.LocAddendum.overrideType().format({ type: printType(baseMethod) }));
            return false;
        }
        if ((0, types_1.isFunction)(baseMethod)) {
            // Handle the easy case - a simple function overriding another simple function.
            if ((0, types_1.isFunction)(overrideMethod)) {
                return validateOverrideMethodInternal(baseMethod, overrideMethod, diag, enforceParamNames);
            }
            // For an overload overriding a base method, at least one overload
            // or the implementation must be compatible with the base method.
            if (overrideMethod.overloads.some((overrideOverload) => {
                return validateOverrideMethodInternal(baseMethod, overrideOverload, 
                /* diag */ undefined, enforceParamNames);
            })) {
                return true;
            }
            diag.addMessage(localize_1.LocAddendum.overrideNoOverloadMatches());
            return false;
        }
        // For a non-overloaded method overriding an overloaded method, the
        // override must match all of the overloads.
        if ((0, types_1.isFunction)(overrideMethod)) {
            return types_1.OverloadedFunctionType.getOverloads(baseMethod).every((overload) => {
                // If the override isn't applicable for this base class, skip the check.
                if (baseClass && !isOverrideMethodApplicable(overload, baseClass)) {
                    return true;
                }
                return validateOverrideMethodInternal(overload, overrideMethod, diag === null || diag === void 0 ? void 0 : diag.createAddendum(), enforceParamNames);
            });
        }
        // For an overloaded method overriding an overloaded method, the overrides
        // must all match and be in the correct order. It is OK if the base method
        // has additional overloads that are not present in the override.
        let previousMatchIndex = -1;
        const baseOverloads = types_1.OverloadedFunctionType.getOverloads(baseMethod);
        for (const overrideOverload of types_1.OverloadedFunctionType.getOverloads(overrideMethod)) {
            let possibleMatchIndex;
            let matchIndex = baseOverloads.findIndex((baseOverload, index) => {
                // If the override isn't applicable for this base class, skip the check.
                if (baseClass && !isOverrideMethodApplicable(baseOverload, baseClass)) {
                    return false;
                }
                const isCompatible = validateOverrideMethodInternal(baseOverload, overrideOverload, 
                /* diag */ undefined, enforceParamNames, 
                /* exemptSelfClsParam */ false);
                // If the override is compatible but the match is one that is below the previous
                // matched index, keep looking for additional matches. Record the fact that
                // we found at least one match.
                if (isCompatible && index <= previousMatchIndex && possibleMatchIndex === undefined) {
                    possibleMatchIndex = index;
                    return false;
                }
                return isCompatible;
            });
            if (matchIndex < 0 && possibleMatchIndex !== undefined) {
                matchIndex = possibleMatchIndex;
            }
            if (matchIndex < 0) {
                break;
            }
            if (matchIndex < previousMatchIndex) {
                diag.addMessage(localize_1.LocAddendum.overrideOverloadOrder());
                return false;
            }
            previousMatchIndex = matchIndex;
        }
        if (previousMatchIndex < baseOverloads.length - 1) {
            const unmatchedOverloads = baseOverloads.slice(previousMatchIndex + 1);
            // See if all of the remaining overrides are nonapplicable.
            if (!baseClass ||
                unmatchedOverloads.some((overload) => {
                    return isOverrideMethodApplicable(overload, baseClass);
                })) {
                // We didn't find matches for all of the base overloads.
                diag.addMessage(localize_1.LocAddendum.overrideOverloadNoMatch());
                return false;
            }
        }
        return true;
    }
    // Determines whether a child class override is applicable to a parent
    // class method signature. This is important in cases where the parent
    // class defines an overload where some of the overload signatures supply
    // explicit type annotations for the "self" or "cls" parameter and some
    // of these do not apply to the child class.
    function isOverrideMethodApplicable(baseMethod, childClass) {
        if (!types_1.FunctionType.isInstanceMethod(baseMethod) &&
            !types_1.FunctionType.isClassMethod(baseMethod) &&
            !types_1.FunctionType.isConstructorMethod(baseMethod)) {
            return true;
        }
        const baseParamDetails = (0, parameterUtils_1.getParameterListDetails)(baseMethod);
        if (baseParamDetails.params.length === 0) {
            return true;
        }
        const baseParamType = baseParamDetails.params[0].param;
        if (baseParamType.category !== 0 /* ParameterCategory.Simple */ || !baseParamType.hasDeclaredType) {
            return true;
        }
        // If this is a self or cls parameter, determine whether the override
        // class can be assigned to the base parameter type. If not, then this
        // override doesn't apply. This is important for overloads where the
        // base class contains some overload signatures that are not applicable
        // to the child class.
        const childSelfOrClsType = types_1.FunctionType.isInstanceMethod(baseMethod)
            ? types_1.ClassType.cloneAsInstance(childClass)
            : childClass;
        return assignType(baseParamType.type, childSelfOrClsType, 
        /* diag */ undefined, 
        /* destTypeVarContext */ undefined, 
        /* srcTypeVarContext */ undefined, 8 /* AssignTypeFlags.SkipSolveTypeVars */);
    }
    // Determines whether the override method is compatible with the overridden method.
    // This is used both for parent/child overrides and implicit overrides for peer
    // classes in a multi-inheritance case. If enforceParamNames is true, the parameter
    // names of non-positional-only parameters are enforced. If exemptSelfClsParam
    // is true, the "self" and "cls" parameters are exempted from type checks.
    // This is normally the case except with overloaded method overrides where the
    // "self" or "cls" parameter type must be honored to differentiate between overloads.
    function validateOverrideMethodInternal(baseMethod, overrideMethod, diag, enforceParamNames, exemptSelfClsParam = true) {
        var _a, _b;
        const baseParamDetails = (0, parameterUtils_1.getParameterListDetails)(baseMethod);
        const overrideParamDetails = (0, parameterUtils_1.getParameterListDetails)(overrideMethod);
        let canOverride = true;
        if (!types_1.FunctionType.isGradualCallableForm(baseMethod) && !types_1.FunctionType.isGradualCallableForm(overrideMethod)) {
            // Verify that we're not overriding a static, class or instance method with
            // an incompatible type.
            if (types_1.FunctionType.isStaticMethod(baseMethod)) {
                if (!types_1.FunctionType.isStaticMethod(overrideMethod)) {
                    diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.overrideNotStaticMethod());
                    canOverride = false;
                }
            }
            else if (types_1.FunctionType.isClassMethod(baseMethod)) {
                if (!types_1.FunctionType.isClassMethod(overrideMethod)) {
                    diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.overrideNotClassMethod());
                    canOverride = false;
                }
            }
            else if (types_1.FunctionType.isInstanceMethod(baseMethod)) {
                if (!types_1.FunctionType.isInstanceMethod(overrideMethod)) {
                    diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.overrideNotInstanceMethod());
                    canOverride = false;
                }
            }
            // Verify that the positional param count matches exactly or that the override
            // adds only params that preserve the original signature.
            let foundParamCountMismatch = false;
            if (overrideParamDetails.positionParamCount < baseParamDetails.positionParamCount) {
                if (overrideParamDetails.argsIndex === undefined) {
                    foundParamCountMismatch = true;
                }
                else {
                    const overrideArgsType = overrideParamDetails.params[overrideParamDetails.argsIndex].type;
                    for (let i = overrideParamDetails.positionParamCount; i < baseParamDetails.positionParamCount; i++) {
                        if (!assignType(overrideArgsType, baseParamDetails.params[i].type, diag === null || diag === void 0 ? void 0 : diag.createAddendum(), new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(overrideMethod)), new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(baseMethod)), 8 /* AssignTypeFlags.SkipSolveTypeVars */)) {
                            localize_1.LocAddendum.overrideParamType().format({
                                index: i + 1,
                                baseType: printType(baseParamDetails.params[i].type),
                                overrideType: printType(overrideArgsType),
                            });
                            canOverride = false;
                        }
                    }
                }
            }
            else if (overrideParamDetails.positionParamCount > baseParamDetails.positionParamCount) {
                // Verify that all of the override parameters that extend the
                // signature are either *args, **kwargs or parameters with
                // default values.
                for (let i = baseParamDetails.positionParamCount; i < overrideParamDetails.positionParamCount; i++) {
                    const overrideParam = overrideParamDetails.params[i].param;
                    if (overrideParam.category === 0 /* ParameterCategory.Simple */ &&
                        overrideParam.name &&
                        !overrideParam.hasDefault) {
                        foundParamCountMismatch = true;
                    }
                }
            }
            if (foundParamCountMismatch) {
                diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.overridePositionalParamCount().format({
                    baseCount: baseParamDetails.params.length,
                    overrideCount: overrideParamDetails.params.length,
                }));
                canOverride = false;
            }
            const positionalParamCount = Math.min(baseParamDetails.positionParamCount, overrideParamDetails.positionParamCount);
            for (let i = 0; i < positionalParamCount; i++) {
                // If the first parameter is a "self" or "cls" parameter, skip the
                // test because these are allowed to violate the Liskov substitution
                // principle.
                if (i === 0 && exemptSelfClsParam) {
                    if (types_1.FunctionType.isInstanceMethod(overrideMethod) ||
                        types_1.FunctionType.isClassMethod(overrideMethod) ||
                        types_1.FunctionType.isConstructorMethod(overrideMethod)) {
                        continue;
                    }
                }
                const baseParam = baseParamDetails.params[i].param;
                const overrideParam = overrideParamDetails.params[i].param;
                if (i >= baseParamDetails.positionOnlyParamCount &&
                    !(0, symbolNameUtils_1.isPrivateOrProtectedName)(baseParam.name || '') &&
                    baseParamDetails.params[i].kind !== parameterUtils_1.ParameterKind.Positional &&
                    baseParam.category === 0 /* ParameterCategory.Simple */ &&
                    enforceParamNames &&
                    baseParam.name !== overrideParam.name) {
                    if (overrideParam.category === 0 /* ParameterCategory.Simple */) {
                        if (!baseParam.isNameSynthesized) {
                            if (overrideParamDetails.params[i].kind === parameterUtils_1.ParameterKind.Positional) {
                                diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.overrideParamNamePositionOnly().format({
                                    index: i + 1,
                                    baseName: baseParam.name || '*',
                                }));
                            }
                            else {
                                diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.overrideParamName().format({
                                    index: i + 1,
                                    baseName: baseParam.name || '*',
                                    overrideName: overrideParam.name || '*',
                                }));
                            }
                            canOverride = false;
                        }
                    }
                }
                else if (i < overrideParamDetails.positionOnlyParamCount &&
                    i >= baseParamDetails.positionOnlyParamCount) {
                    if (!baseParam.isNameSynthesized && baseParamDetails.params[i].kind !== parameterUtils_1.ParameterKind.Positional) {
                        diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.overrideParamNamePositionOnly().format({
                            index: i + 1,
                            baseName: baseParam.name || '*',
                        }));
                        canOverride = false;
                    }
                }
                else {
                    const baseParamType = baseParamDetails.params[i].type;
                    const overrideParamType = overrideParamDetails.params[i].type;
                    const baseIsSynthesizedTypeVar = (0, types_1.isTypeVar)(baseParamType) && baseParamType.details.isSynthesized;
                    const overrideIsSynthesizedTypeVar = (0, types_1.isTypeVar)(overrideParamType) && overrideParamType.details.isSynthesized;
                    if (!exemptSelfClsParam || (!baseIsSynthesizedTypeVar && !overrideIsSynthesizedTypeVar)) {
                        if (baseParam.category !== overrideParam.category ||
                            !assignType(overrideParamType, baseParamType, diag === null || diag === void 0 ? void 0 : diag.createAddendum(), new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(overrideMethod)), new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(baseMethod)), 8 /* AssignTypeFlags.SkipSolveTypeVars */)) {
                            diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.overrideParamType().format({
                                index: i + 1,
                                baseType: printType(baseParamType),
                                overrideType: printType(overrideParamType),
                            }));
                            canOverride = false;
                        }
                    }
                    if (baseParamDetails.params[i].param.hasDefault &&
                        !overrideParamDetails.params[i].param.hasDefault) {
                        diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.overrideParamNoDefault().format({
                            index: i + 1,
                        }));
                        canOverride = false;
                    }
                }
            }
            // Check for positional (named) parameters in the base method that
            // do not exist in the override.
            if (enforceParamNames && overrideParamDetails.kwargsIndex === undefined) {
                for (let i = positionalParamCount; i < baseParamDetails.positionParamCount; i++) {
                    const baseParam = baseParamDetails.params[i];
                    if (baseParam.kind === parameterUtils_1.ParameterKind.Standard &&
                        baseParam.param.category === 0 /* ParameterCategory.Simple */) {
                        diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.overrideParamNamePositionOnly().format({
                            index: i + 1,
                            baseName: baseParam.param.name || '*',
                        }));
                        canOverride = false;
                    }
                }
            }
            // Check for a *args match.
            if (baseParamDetails.argsIndex !== undefined) {
                if (overrideParamDetails.argsIndex === undefined) {
                    diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.overrideParamNameMissing().format({
                        name: (_a = baseParamDetails.params[baseParamDetails.argsIndex].param.name) !== null && _a !== void 0 ? _a : '?',
                    }));
                    canOverride = false;
                }
                else {
                    const overrideParamType = overrideParamDetails.params[overrideParamDetails.argsIndex].type;
                    const baseParamType = baseParamDetails.params[baseParamDetails.argsIndex].type;
                    if (!assignType(overrideParamType, baseParamType, diag === null || diag === void 0 ? void 0 : diag.createAddendum(), new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(overrideMethod)), 
                    /* srcTypeVarContext */ undefined, 8 /* AssignTypeFlags.SkipSolveTypeVars */)) {
                        diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.overrideParamKeywordType().format({
                            name: (_b = overrideParamDetails.params[overrideParamDetails.argsIndex].param.name) !== null && _b !== void 0 ? _b : '?',
                            baseType: printType(baseParamType),
                            overrideType: printType(overrideParamType),
                        }));
                        canOverride = false;
                    }
                }
            }
            // Now check any keyword-only parameters.
            const baseKwOnlyParams = baseParamDetails.params.filter((paramInfo) => paramInfo.kind === parameterUtils_1.ParameterKind.Keyword && paramInfo.param.category === 0 /* ParameterCategory.Simple */);
            const overrideKwOnlyParams = overrideParamDetails.params.filter((paramInfo) => paramInfo.kind === parameterUtils_1.ParameterKind.Keyword && paramInfo.param.category === 0 /* ParameterCategory.Simple */);
            baseKwOnlyParams.forEach((paramInfo) => {
                var _a, _b, _c;
                const overrideParamInfo = overrideKwOnlyParams.find((pi) => paramInfo.param.name === pi.param.name);
                if (!overrideParamInfo && overrideParamDetails.kwargsIndex === undefined) {
                    diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.overrideParamNameMissing().format({
                        name: (_a = paramInfo.param.name) !== null && _a !== void 0 ? _a : '?',
                    }));
                    canOverride = false;
                }
                else {
                    let targetParamType = overrideParamInfo === null || overrideParamInfo === void 0 ? void 0 : overrideParamInfo.type;
                    if (!targetParamType) {
                        targetParamType = overrideParamDetails.params[overrideParamDetails.kwargsIndex].type;
                    }
                    if (!assignType(targetParamType, paramInfo.type, diag === null || diag === void 0 ? void 0 : diag.createAddendum(), new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(overrideMethod)), new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(baseMethod)), 8 /* AssignTypeFlags.SkipSolveTypeVars */)) {
                        diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.overrideParamKeywordType().format({
                            name: (_b = paramInfo.param.name) !== null && _b !== void 0 ? _b : '?',
                            baseType: printType(paramInfo.type),
                            overrideType: printType(targetParamType),
                        }));
                        canOverride = false;
                    }
                    if (overrideParamInfo) {
                        if (paramInfo.param.hasDefault && !overrideParamInfo.param.hasDefault) {
                            diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.overrideParamKeywordNoDefault().format({
                                name: (_c = overrideParamInfo.param.name) !== null && _c !== void 0 ? _c : '?',
                            }));
                            canOverride = false;
                        }
                    }
                }
            });
            // Verify that any keyword-only parameters added by the overload are compatible
            // with the **kwargs in the base.
            overrideKwOnlyParams.forEach((paramInfo) => {
                var _a;
                const baseParamInfo = baseKwOnlyParams.find((pi) => paramInfo.param.name === pi.param.name);
                if (!baseParamInfo) {
                    if (baseParamDetails.kwargsIndex === undefined) {
                        if (!paramInfo.param.hasDefault) {
                            diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.overrideParamNameExtra().format({
                                name: (_a = paramInfo.param.name) !== null && _a !== void 0 ? _a : '?',
                            }));
                            canOverride = false;
                        }
                    }
                }
            });
            // Verify that if the base method has a **kwargs parameter, the override does too.
            if (baseParamDetails.kwargsIndex !== undefined && overrideParamDetails.kwargsIndex === undefined) {
                diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.kwargsParamMissing().format({
                    paramName: baseParamDetails.params[baseParamDetails.kwargsIndex].param.name,
                }));
                canOverride = false;
            }
        }
        // Verify that one or the other method doesn't contain a ParamSpec.
        if (baseParamDetails.paramSpec && !overrideParamDetails.paramSpec) {
            // If the override uses an `*args: Any, **kwargs: Any` signature, we
            // will allow this as an acceptable overload for a `*args: P.args, **kwargs: P.kwargs`.
            const overrideHasArgsKwargs = overrideParamDetails.argsIndex !== undefined &&
                (0, types_1.isAnyOrUnknown)(overrideParamDetails.params[overrideParamDetails.argsIndex].type) &&
                overrideParamDetails.kwargsIndex !== undefined &&
                (0, types_1.isAnyOrUnknown)(overrideParamDetails.params[overrideParamDetails.kwargsIndex].type);
            if (!overrideHasArgsKwargs) {
                diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.paramSpecMissingInOverride());
                canOverride = false;
            }
        }
        // Now check the return type.
        const baseReturnType = getFunctionEffectiveReturnType(baseMethod);
        const overrideReturnType = getFunctionEffectiveReturnType(overrideMethod);
        if (!assignType(baseReturnType, overrideReturnType, diag === null || diag === void 0 ? void 0 : diag.createAddendum(), new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(baseMethod)), new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(overrideMethod)), 8 /* AssignTypeFlags.SkipSolveTypeVars */)) {
            diag === null || diag === void 0 ? void 0 : diag.addMessage(localize_1.LocAddendum.overrideReturnType().format({
                baseType: printType(baseReturnType),
                overrideType: printType(overrideReturnType),
            }));
            canOverride = false;
        }
        return canOverride;
    }
    // Validates that the specified source type matches the constraints
    // of the type variable. If successful, it returns the constraint
    // type that applies. If unsuccessful, it returns undefined.
    function applyTypeArgToTypeVar(destType, srcType, diag) {
        if ((0, types_1.isAnyOrUnknown)(srcType)) {
            return srcType;
        }
        let effectiveSrcType = (0, typeUtils_1.transformPossibleRecursiveTypeAlias)(srcType);
        if ((0, types_1.isTypeVar)(srcType)) {
            if ((0, types_1.isTypeSame)(srcType, destType)) {
                return srcType;
            }
            effectiveSrcType = makeTopLevelTypeVarsConcrete(srcType);
        }
        // If this is a partially-evaluated class, don't perform any further
        // checks. Assume in this case that the type is compatible with the
        // bound or constraint.
        if ((0, types_1.isClass)(effectiveSrcType) && types_1.ClassType.isPartiallyEvaluated(effectiveSrcType)) {
            return srcType;
        }
        // If there's a bound type, make sure the source is derived from it.
        if (destType.details.boundType && !(0, typeUtils_1.isTypeAliasPlaceholder)(effectiveSrcType)) {
            if (!assignType(destType.details.boundType, effectiveSrcType, diag.createAddendum(), 
            /* destTypeVarContext */ undefined, 
            /* srcTypeVarContext */ undefined)) {
                // Avoid adding a message that will confuse users if the TypeVar was
                // synthesized for internal purposes.
                if (!destType.details.isSynthesized) {
                    diag.addMessage(localize_1.LocAddendum.typeBound().format({
                        sourceType: printType(effectiveSrcType),
                        destType: printType(destType.details.boundType),
                        name: types_1.TypeVarType.getReadableName(destType),
                    }));
                }
                return undefined;
            }
        }
        if (destType.details.isParamSpec) {
            if ((0, types_1.isParamSpec)(srcType)) {
                return srcType;
            }
            if ((0, types_1.isFunction)(srcType) && types_1.FunctionType.isParamSpecValue(srcType)) {
                return srcType;
            }
            if ((0, types_1.isClassInstance)(srcType) && types_1.ClassType.isBuiltIn(srcType, 'Concatenate')) {
                return srcType;
            }
            diag.addMessage(localize_1.LocAddendum.typeParamSpec().format({
                type: printType(srcType),
                name: types_1.TypeVarType.getReadableName(destType),
            }));
            return undefined;
        }
        if ((0, types_1.isTypeVar)(srcType) && srcType.details.isParamSpec) {
            diag.addMessage(localize_1.LocMessage.paramSpecContext());
            return undefined;
        }
        // If there are no constraints, we're done.
        const constraints = destType.details.constraints;
        if (constraints.length === 0) {
            return srcType;
        }
        if ((0, typeUtils_1.isTypeAliasPlaceholder)(srcType)) {
            return srcType;
        }
        if ((0, types_1.isTypeVar)(srcType) && srcType.details.constraints.length > 0) {
            // Make sure all the source constraint types map to constraint types in the dest.
            if (srcType.details.constraints.every((sourceConstraint) => {
                return constraints.some((destConstraint) => assignType(destConstraint, sourceConstraint));
            })) {
                return srcType;
            }
        }
        else {
            let bestConstraintSoFar;
            // Try to find the best (narrowest) match among the constraints.
            for (const constraint of constraints) {
                // Don't allow Never as a type argument.
                if (assignType(constraint, effectiveSrcType) && !(0, types_1.isNever)(effectiveSrcType)) {
                    if (!bestConstraintSoFar || assignType(bestConstraintSoFar, constraint)) {
                        bestConstraintSoFar = constraint;
                    }
                }
            }
            if (bestConstraintSoFar) {
                return bestConstraintSoFar;
            }
        }
        diag.addMessage(localize_1.LocAddendum.typeConstrainedTypeVar().format({
            type: printType(srcType),
            name: types_1.TypeVarType.getReadableName(destType),
        }));
        return undefined;
    }
    // Returns a list of unimplemented abstract symbols (methods or variables) for
    // the specified class.
    function getAbstractSymbols(classType) {
        const symbolTable = new Map();
        types_1.ClassType.getReverseMro(classType).forEach((mroClass) => {
            if ((0, types_1.isInstantiableClass)(mroClass)) {
                // See if this class is introducing a new abstract symbol that has not been
                // introduced previously or if it is overriding an abstract symbol with
                // a non-abstract one.
                types_1.ClassType.getSymbolTable(mroClass).forEach((symbol, symbolName) => {
                    const abstractSymbolInfo = getAbstractSymbolInfo(mroClass, symbolName);
                    if (abstractSymbolInfo) {
                        symbolTable.set(symbolName, abstractSymbolInfo);
                    }
                    else {
                        symbolTable.delete(symbolName);
                    }
                });
            }
        });
        // Create a final list of symbols that are abstract.
        const symbolList = [];
        symbolTable.forEach((method) => {
            symbolList.push(method);
        });
        return symbolList;
    }
    // If the memberType is an instance or class method, creates a new
    // version of the function that has the "self" or "cls" parameter bound
    // to it. If treatConstructorAsClassMethod is true, the function is
    // treated like a class method even if it's not marked as such. That's
    // needed to special-case the __new__ magic method when it's invoked as
    // a constructor (as opposed to by name).
    function bindFunctionToClassOrObject(baseType, memberType, memberClass, treatConstructorAsClassMethod = false, selfType, diag, recursionCount = 0) {
        return (0, typeUtils_1.mapSignatures)(memberType, (functionType) => {
            // If the caller specified no base type, always strip the
            // first parameter. This is used in cases like constructors.
            if (!baseType) {
                return types_1.FunctionType.clone(functionType, /* stripFirstParam */ true);
            }
            if (types_1.FunctionType.isInstanceMethod(functionType)) {
                // If the baseType is a metaclass, don't specialize the function.
                if ((0, typeUtils_1.isInstantiableMetaclass)(baseType)) {
                    return functionType;
                }
                const baseObj = (0, types_1.isClassInstance)(baseType)
                    ? baseType
                    : types_1.ClassType.cloneAsInstance((0, typeUtils_1.specializeClassType)(baseType));
                let stripFirstParam = false;
                if ((0, types_1.isClassInstance)(baseType)) {
                    stripFirstParam = true;
                }
                else if (memberClass && (0, typeUtils_1.isInstantiableMetaclass)(memberClass)) {
                    stripFirstParam = true;
                }
                return partiallySpecializeFunctionForBoundClassOrObject(baseType, functionType, memberClass !== null && memberClass !== void 0 ? memberClass : types_1.ClassType.cloneAsInstantiable(baseObj), diag, recursionCount, selfType !== null && selfType !== void 0 ? selfType : baseObj, stripFirstParam);
            }
            if (types_1.FunctionType.isClassMethod(functionType) ||
                (treatConstructorAsClassMethod && types_1.FunctionType.isConstructorMethod(functionType))) {
                const baseClass = (0, types_1.isInstantiableClass)(baseType) ? baseType : types_1.ClassType.cloneAsInstantiable(baseType);
                const clsType = selfType ? (0, typeUtils_1.convertToInstantiable)(selfType) : undefined;
                return partiallySpecializeFunctionForBoundClassOrObject(baseClass, functionType, memberClass !== null && memberClass !== void 0 ? memberClass : baseClass, diag, recursionCount, clsType !== null && clsType !== void 0 ? clsType : baseClass, 
                /* stripFirstParam */ true);
            }
            if (types_1.FunctionType.isStaticMethod(functionType)) {
                const baseClass = (0, types_1.isInstantiableClass)(baseType) ? baseType : types_1.ClassType.cloneAsInstantiable(baseType);
                return partiallySpecializeFunctionForBoundClassOrObject(baseClass, functionType, memberClass !== null && memberClass !== void 0 ? memberClass : baseClass, diag, recursionCount, 
                /* firstParamType */ undefined, 
                /* stripFirstParam */ false);
            }
            return functionType;
        });
    }
    // Specializes the specified function for the specified class,
    // optionally stripping the first first parameter (the "self" or "cls")
    // off of the specialized function in the process. The baseType
    // is the type used to reference the member, and the memberClass
    // is the class that provided the member (could be an ancestor of
    // the baseType's class).
    function partiallySpecializeFunctionForBoundClassOrObject(baseType, memberType, memberClass, diag, recursionCount, firstParamType, stripFirstParam = true) {
        const typeVarContext = new typeVarContext_1.TypeVarContext((0, typeUtils_1.getTypeVarScopeId)(memberClass));
        if (firstParamType && memberType.details.parameters.length > 0) {
            const memberTypeFirstParam = memberType.details.parameters[0];
            const memberTypeFirstParamType = types_1.FunctionType.getEffectiveParameterType(memberType, 0);
            // Fill out the typeVarContext for the "self" or "cls" parameter.
            typeVarContext.addSolveForScope((0, typeUtils_1.getTypeVarScopeId)(memberType));
            if ((0, types_1.isTypeVar)(memberTypeFirstParamType) &&
                memberTypeFirstParamType.details.boundType &&
                (0, types_1.isClassInstance)(memberTypeFirstParamType.details.boundType) &&
                types_1.ClassType.isProtocolClass(memberTypeFirstParamType.details.boundType)) {
                // Handle the protocol class specially. Some protocol classes
                // contain references to themselves or their subclasses, so if
                // we attempt to call assignType, we'll risk infinite recursion.
                // Instead, we'll assume it's assignable.
                if (!typeVarContext.isLocked()) {
                    typeVarContext.setTypeVarType(memberTypeFirstParamType, types_1.TypeBase.isInstantiable(memberTypeFirstParamType)
                        ? (0, typeUtils_1.convertToInstance)(firstParamType)
                        : firstParamType);
                }
            }
            else {
                const subDiag = diag === null || diag === void 0 ? void 0 : diag.createAddendum();
                if (!assignType(memberTypeFirstParamType, firstParamType, subDiag === null || subDiag === void 0 ? void 0 : subDiag.createAddendum(), typeVarContext, 
                /* srcTypeVarContext */ undefined, 8192 /* AssignTypeFlags.AllowUnspecifiedTypeArguments */, recursionCount)) {
                    if (memberTypeFirstParam.name &&
                        !memberTypeFirstParam.isNameSynthesized &&
                        memberTypeFirstParam.hasDeclaredType) {
                        if (subDiag) {
                            subDiag.addMessage(localize_1.LocMessage.bindTypeMismatch().format({
                                type: printType(firstParamType),
                                methodName: memberType.details.name || '<anonymous>',
                                paramName: memberTypeFirstParam.name,
                            }));
                        }
                        return undefined;
                    }
                }
            }
        }
        // Get the effective return type, which will have the side effect of lazily
        // evaluating (and caching) the inferred return type if there is no defined return type.
        getFunctionEffectiveReturnType(memberType);
        const specializedFunction = (0, typeUtils_1.applySolvedTypeVars)(memberType, typeVarContext);
        // If this is a constructor method, provide the base type's TypeVar scope ID
        // so any TypeVars in this type can be solved.
        let baseTypeTypeVarScopeId;
        if (types_1.FunctionType.isConstructorMethod(specializedFunction) || specializedFunction.details.name === '__init__') {
            baseTypeTypeVarScopeId = (0, typeUtils_1.getTypeVarScopeId)(baseType);
        }
        return types_1.FunctionType.clone(specializedFunction, stripFirstParam, baseType, baseTypeTypeVarScopeId);
    }
    function isFinalVariable(symbol) {
        return symbol.getDeclarations().some((decl) => isFinalVariableDeclaration(decl));
    }
    function isFinalVariableDeclaration(decl) {
        return decl.type === 1 /* DeclarationType.Variable */ && !!decl.isFinal;
    }
    function isExplicitTypeAliasDeclaration(decl) {
        if (decl.type !== 1 /* DeclarationType.Variable */ || !decl.typeAnnotationNode) {
            return false;
        }
        if (decl.typeAnnotationNode.nodeType !== 38 /* ParseNodeType.Name */ &&
            decl.typeAnnotationNode.nodeType !== 35 /* ParseNodeType.MemberAccess */ &&
            decl.typeAnnotationNode.nodeType !== 48 /* ParseNodeType.StringList */) {
            return false;
        }
        const type = getTypeOfAnnotation(decl.typeAnnotationNode, { isVariableAnnotation: true, allowClassVar: true });
        return (0, types_1.isClassInstance)(type) && types_1.ClassType.isBuiltIn(type, 'TypeAlias');
    }
    function isPossibleTypeAliasDeclaration(decl) {
        var _a;
        if (decl.type !== 1 /* DeclarationType.Variable */ || !decl.typeAliasName || decl.typeAnnotationNode) {
            return false;
        }
        if (((_a = decl.node.parent) === null || _a === void 0 ? void 0 : _a.nodeType) !== 3 /* ParseNodeType.Assignment */) {
            return false;
        }
        // Perform a sanity check on the RHS expression. Some expression
        // forms should never be considered legitimate for type aliases.
        return isLegalTypeAliasExpressionForm(decl.node.parent.rightExpression);
    }
    function isLegalTypeAliasExpressionForm(node) {
        switch (node.nodeType) {
            case 0 /* ParseNodeType.Error */:
            case 55 /* ParseNodeType.UnaryOperation */:
            case 4 /* ParseNodeType.AssignmentExpression */:
            case 54 /* ParseNodeType.TypeAnnotation */:
            case 6 /* ParseNodeType.Await */:
            case 51 /* ParseNodeType.Ternary */:
            case 56 /* ParseNodeType.Unpack */:
            case 52 /* ParseNodeType.Tuple */:
            case 9 /* ParseNodeType.Call */:
            case 11 /* ParseNodeType.Comprehension */:
            case 46 /* ParseNodeType.Slice */:
            case 60 /* ParseNodeType.Yield */:
            case 61 /* ParseNodeType.YieldFrom */:
            case 33 /* ParseNodeType.Lambda */:
            case 40 /* ParseNodeType.Number */:
            case 18 /* ParseNodeType.Dictionary */:
            case 34 /* ParseNodeType.List */:
            case 45 /* ParseNodeType.Set */:
                return false;
            case 7 /* ParseNodeType.BinaryOperation */:
                return (node.operator === 6 /* OperatorType.BitwiseOr */ &&
                    isLegalTypeAliasExpressionForm(node.leftExpression) &&
                    isLegalTypeAliasExpressionForm(node.rightExpression));
            case 27 /* ParseNodeType.Index */:
                return isLegalTypeAliasExpressionForm(node.baseExpression);
            case 35 /* ParseNodeType.MemberAccess */:
                return isLegalTypeAliasExpressionForm(node.leftExpression);
        }
        return true;
    }
    function isLegalImplicitTypeAliasType(type) {
        // We explicitly exclude "..." and "Unknown".
        if ((0, typeUtils_1.isEllipsisType)(type)) {
            return false;
        }
        if ((0, types_1.isUnknown)(type)) {
            // If this is a union type, we'll assume that it was meant as a type
            // alias even though all of the union subtypes are Unknown.
            if (type.specialForm && types_1.ClassType.isBuiltIn(type.specialForm, 'UnionType')) {
                return true;
            }
            return false;
        }
        // Look at the subtypes within the union. If any of them are not
        // instantiable (other than "None" which is special-cased), it is
        // not a legal type alias type.
        let isLegal = true;
        (0, typeUtils_1.doForEachSubtype)(type, (subtype) => {
            if (!types_1.TypeBase.isInstantiable(subtype) && !(0, typeUtils_1.isNoneInstance)(subtype)) {
                isLegal = false;
            }
        });
        return isLegal;
    }
    function isPossibleTypeAliasOrTypedDict(decl) {
        return isPossibleTypeAliasDeclaration(decl) || isPossibleTypeDictFactoryCall(decl);
    }
    function isPossibleTypeDictFactoryCall(decl) {
        var _a;
        if (decl.type !== 1 /* DeclarationType.Variable */ ||
            !decl.node.parent ||
            decl.node.parent.nodeType !== 3 /* ParseNodeType.Assignment */ ||
            ((_a = decl.node.parent.rightExpression) === null || _a === void 0 ? void 0 : _a.nodeType) !== 9 /* ParseNodeType.Call */) {
            return false;
        }
        const callLeftNode = decl.node.parent.rightExpression.leftExpression;
        // Use a simple heuristic to determine whether this is potentially
        // a call to the TypedDict call. This avoids the expensive (and potentially
        // recursive) call to getTypeOfExpression in cases where it's not needed.
        if ((callLeftNode.nodeType === 38 /* ParseNodeType.Name */ && callLeftNode.value) === 'TypedDict' ||
            (callLeftNode.nodeType === 35 /* ParseNodeType.MemberAccess */ &&
                callLeftNode.memberName.value === 'TypedDict' &&
                callLeftNode.leftExpression.nodeType === 38 /* ParseNodeType.Name */)) {
            // See if this is a call to TypedDict. We want to support
            // recursive type references in a TypedDict call.
            const callType = getTypeOfExpression(callLeftNode, 2 /* EvalFlags.CallBaseDefaults */).type;
            if ((0, types_1.isInstantiableClass)(callType) && types_1.ClassType.isBuiltIn(callType, 'TypedDict')) {
                return true;
            }
        }
        return false;
    }
    function printObjectTypeForClass(type) {
        return TypePrinter.printObjectTypeForClass(type, evaluatorOptions.printTypeFlags, getFunctionEffectiveReturnType);
    }
    function printFunctionParts(type, extraFlags) {
        const flags = extraFlags ? evaluatorOptions.printTypeFlags | extraFlags : evaluatorOptions.printTypeFlags;
        return TypePrinter.printFunctionParts(type, flags, getFunctionEffectiveReturnType);
    }
    // Prints two types and determines whether they need to be output in
    // fully-qualified form for disambiguation.
    function printSrcDestTypes(srcType, destType, options) {
        const simpleSrcType = printType(srcType, options);
        const simpleDestType = printType(destType, options);
        if (simpleSrcType !== simpleDestType) {
            return { sourceType: simpleSrcType, destType: simpleDestType };
        }
        const fullSrcType = printType(srcType, { ...(options !== null && options !== void 0 ? options : {}), useFullyQualifiedNames: true });
        const fullDestType = printType(destType, { ...(options !== null && options !== void 0 ? options : {}), useFullyQualifiedNames: true });
        if (fullSrcType !== fullDestType) {
            return { sourceType: fullSrcType, destType: fullDestType };
        }
        return { sourceType: simpleSrcType, destType: simpleDestType };
    }
    function printType(type, options) {
        let flags = evaluatorOptions.printTypeFlags;
        if (options === null || options === void 0 ? void 0 : options.expandTypeAlias) {
            flags |= 32 /* TypePrinter.PrintTypeFlags.ExpandTypeAlias */;
        }
        if (options === null || options === void 0 ? void 0 : options.enforcePythonSyntax) {
            flags |= 256 /* TypePrinter.PrintTypeFlags.PythonSyntax */;
        }
        if (options === null || options === void 0 ? void 0 : options.useTypingUnpack) {
            flags |= 512 /* TypePrinter.PrintTypeFlags.UseTypingUnpack */;
        }
        if (options === null || options === void 0 ? void 0 : options.printUnknownWithAny) {
            flags |= 1 /* TypePrinter.PrintTypeFlags.PrintUnknownWithAny */;
        }
        if (options === null || options === void 0 ? void 0 : options.printTypeVarVariance) {
            flags |= 2048 /* TypePrinter.PrintTypeFlags.PrintTypeVarVariance */;
        }
        if (options === null || options === void 0 ? void 0 : options.omitTypeArgumentsIfUnknown) {
            flags |= 2 /* TypePrinter.PrintTypeFlags.OmitTypeArgumentsIfUnknown */;
        }
        if (options === null || options === void 0 ? void 0 : options.useFullyQualifiedNames) {
            flags |= 4096 /* TypePrinter.PrintTypeFlags.UseFullyQualifiedNames */;
        }
        return TypePrinter.printType(type, flags, getFunctionEffectiveReturnType);
    }
    // Calls back into the parser to parse the contents of a string literal.
    // This is unfortunately needed in some cases  specifically where the
    // parser couldn't determine that the string literal would be used in
    // a context where it should be treated as a forward-declared type. This
    // call produces an expression tree that is not attached to the main parse
    // expression tree because we don't want to mutate the latter; the
    // expression tree created by this function is therefore used only temporarily.
    function parseStringAsTypeAnnotation(node) {
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        const parser = new parser_1.Parser();
        const textValue = node.strings[0].value;
        // Determine the offset within the file where the string
        // literal's contents begin.
        let valueOffset = node.strings[0].start;
        if (node.strings[0].nodeType === 49 /* ParseNodeType.String */) {
            valueOffset += node.strings[0].token.prefixLength + node.strings[0].token.quoteMarkLength;
        }
        // Construct a temporary dummy string with the text value at the appropriate
        // offset so as to mimic the original file. This will keep all of the token
        // and diagnostic offsets correct.
        const dummyFileContents = ' '.repeat(valueOffset) + textValue;
        const parseOptions = new parser_1.ParseOptions();
        parseOptions.isStubFile = fileInfo.isStubFile;
        parseOptions.pythonVersion = fileInfo.executionEnvironment.pythonVersion;
        parseOptions.reportErrorsForParsedStringContents = true;
        const parseResults = parser.parseTextExpression(dummyFileContents, valueOffset, textValue.length, parseOptions, 
        /* parseTextMode */ undefined, 
        /* initialParenDepth */ undefined, fileInfo.typingSymbolAliases);
        if (parseResults.parseTree && parseResults.parseTree.nodeType !== 62 /* ParseNodeType.FunctionAnnotation */) {
            parseResults.diagnostics.forEach((diag) => {
                addError(diag.message, node);
            });
            parseResults.parseTree.parent = node;
            return parseResults.parseTree;
        }
        return undefined;
    }
    // Given a code flow node and a constrained TypeVar, determines whether that type
    // var can be "narrowed" to a single one of its constraints based on isinstance
    // checks within the code flow.
    function narrowConstrainedTypeVar(node, typeVar) {
        const flowNode = AnalyzerNodeInfo.getFlowNode(node);
        if (!flowNode) {
            return undefined;
        }
        return codeFlowEngine.narrowConstrainedTypeVar(flowNode, typeVar);
    }
    function getPrintExpressionTypesSpaces() {
        return ' '.repeat(printExpressionSpaceCount);
    }
    function getLineNum(node) {
        const fileInfo = AnalyzerNodeInfo.getFileInfo(node);
        const range = (0, positionUtils_1.convertOffsetsToRange)(node.start, node.start + node.length, fileInfo.lines);
        return (range.start.line + 1).toString();
    }
    function printControlFlowGraph(flowNode, reference, callName, logger) {
        return codeFlowEngine.printControlFlowGraph(flowNode, reference, callName, logger);
    }
    function printTypeVarContext(typeVarContext) {
        const contexts = typeVarContext.getSignatureContexts();
        contexts.forEach((context, index) => {
            if (contexts.length > 1) {
                console.log(`Signature context ${index + 1}:`);
            }
            context.getTypeVars().forEach((typeVarEntry) => {
                const type = context.getTypeVarType(typeVarEntry.typeVar);
                console.log(`  ${typeVarEntry.typeVar.details.name}: ${type ? printType(type) : '<none>'}`);
            });
        });
    }
    // Track these apis internal usages when logging is on. otherwise, it should be noop.
    const getFunctionInferredReturnType = wrapWithLogger(_getFunctionInferredReturnType);
    const evaluatorInterface = {
        runWithCancellationToken,
        getType,
        getTypeResult,
        getTypeResultForDecorator,
        getCachedType,
        getTypeOfExpression,
        getTypeOfAnnotation,
        getTypeOfClass,
        getTypeOfFunction,
        getTypeOfExpressionExpectingType,
        getExpectedType,
        evaluateTypeForSubnode,
        evaluateTypesForStatement,
        evaluateTypesForMatchStatement,
        evaluateTypesForCaseStatement,
        evaluateTypeOfParameter,
        canBeTruthy,
        canBeFalsy,
        stripLiteralValue,
        removeTruthinessFromType,
        removeFalsinessFromType,
        verifyRaiseExceptionType,
        verifyDeleteExpression,
        validateOverloadedFunctionArguments,
        validateInitSubclassArgs,
        isAfterNodeReachable,
        isNodeReachable,
        isAsymmetricAccessorAssignment,
        suppressDiagnostics,
        isSpecialFormClass,
        getDeclarationsForStringNode,
        getDeclarationsForNameNode,
        getTypeForDeclaration,
        resolveAliasDeclaration,
        resolveAliasDeclarationWithInfo,
        getTypeOfIterable,
        getTypeOfIterator,
        getGetterTypeFromProperty,
        getTypeOfArgument,
        markNamesAccessed,
        expandPromotionTypes,
        makeTopLevelTypeVarsConcrete,
        mapSubtypesExpandTypeVars,
        isTypeSubsumedByOtherType,
        lookUpSymbolRecursive,
        getDeclaredTypeOfSymbol,
        getEffectiveTypeOfSymbol,
        getEffectiveTypeOfSymbolForUsage,
        getInferredTypeOfDeclaration,
        getDeclaredTypeForExpression,
        getFunctionDeclaredReturnType,
        getFunctionInferredReturnType,
        getBestOverloadForArguments,
        getBuiltInType,
        getTypeOfMember,
        getTypeOfBoundMember,
        getBoundMagicMethod,
        getTypeOfMagicMethodCall,
        bindFunctionToClassOrObject,
        getCallSignatureInfo,
        getAbstractSymbols,
        narrowConstrainedTypeVar,
        assignType,
        validateOverrideMethod,
        validateCallArguments,
        validateTypeArg,
        assignTypeToExpression,
        assignClassToSelf,
        getTypedDictClassType,
        getTupleClassType,
        getObjectType,
        getNoneType,
        getUnionClassType,
        getBuiltInObject,
        getTypingType,
        assignTypeArguments,
        reportMissingTypeArguments,
        inferReturnTypeIfNecessary,
        inferTypeParameterVarianceForClass,
        isFinalVariable,
        isFinalVariableDeclaration,
        isExplicitTypeAliasDeclaration,
        addInformation,
        addUnusedCode,
        addUnreachableCode,
        addDeprecated,
        addDiagnostic,
        addDiagnosticForTextRange,
        printType,
        printSrcDestTypes,
        printFunctionParts,
        getTypeCacheEntryCount,
        disposeEvaluator,
        useSpeculativeMode,
        isSpeculativeModeInUse,
        setTypeResultForNode,
        checkForCancellation,
        printControlFlowGraph,
        printTypeVarContext,
    };
    const codeFlowEngine = (0, codeFlowEngine_1.getCodeFlowEngine)(evaluatorInterface, speculativeTypeTracker);
    return evaluatorInterface;
}
exports.createTypeEvaluator = createTypeEvaluator;
//# sourceMappingURL=typeEvaluator.js.map