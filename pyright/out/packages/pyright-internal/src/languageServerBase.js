"use strict";
/*
 * languageServerBase.ts
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT license.
 *
 * Implements common language server functionality.
 * This is split out as a base class to allow for
 * different language server variants to be created
 * from the same core functionality.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LanguageServerBase = exports.VSDiagnosticRank = exports.VSDiagnosticTag = void 0;
require("./common/extensions");
const vscode_languageserver_1 = require("vscode-languageserver");
const progress_1 = require("vscode-languageserver/lib/common/progress");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const backgroundAnalysisProgram_1 = require("./analyzer/backgroundAnalysisProgram");
const service_1 = require("./analyzer/service");
const sourceFile_1 = require("./analyzer/sourceFile");
const commandResult_1 = require("./commands/commandResult");
const cancellationUtils_1 = require("./common/cancellationUtils");
const collectionUtils_1 = require("./common/collectionUtils");
const commandLineOptions_1 = require("./common/commandLineOptions");
const configOptions_1 = require("./common/configOptions");
const console_1 = require("./common/console");
const diagnostic_1 = require("./common/diagnostic");
const lspUtils_1 = require("./common/lspUtils");
const progressReporter_1 = require("./common/progressReporter");
const serviceKeys_1 = require("./common/serviceKeys");
const uri_1 = require("./common/uri/uri");
const uriUtils_1 = require("./common/uri/uriUtils");
const analyzerServiceExecutor_1 = require("./languageService/analyzerServiceExecutor");
const callHierarchyProvider_1 = require("./languageService/callHierarchyProvider");
const completionProvider_1 = require("./languageService/completionProvider");
const definitionProvider_1 = require("./languageService/definitionProvider");
const documentHighlightProvider_1 = require("./languageService/documentHighlightProvider");
const documentSymbolProvider_1 = require("./languageService/documentSymbolProvider");
const hoverProvider_1 = require("./languageService/hoverProvider");
const navigationUtils_1 = require("./languageService/navigationUtils");
const referencesProvider_1 = require("./languageService/referencesProvider");
const renameProvider_1 = require("./languageService/renameProvider");
const signatureHelpProvider_1 = require("./languageService/signatureHelpProvider");
const workspaceSymbolProvider_1 = require("./languageService/workspaceSymbolProvider");
const localize_1 = require("./localization/localize");
const workspaceFactory_1 = require("./workspaceFactory");
const dynamicFeature_1 = require("./languageService/dynamicFeature");
const fileWatcherDynamicFeature_1 = require("./languageService/fileWatcherDynamicFeature");
const nullProgressReporter = (0, progress_1.attachWorkDone)(undefined, /* params */ undefined);
/*
 * Additional DiagnosticTag values that are specific to Visual Studio.
 * These must match the values in https://dev.azure.com/devdiv/DevDiv/_git/vslanguageserverclient?path=%2Fsrc%2Fproduct%2FProtocol%2FLanguageServer.Protocol.Extensions%2FVSDiagnosticTags.cs&version=GBdevelop&_a=contents
 */
var VSDiagnosticTag;
(function (VSDiagnosticTag) {
    /**
     * A diagnostic entry generated by the build.
     */
    VSDiagnosticTag.BuildError = -1;
    /**
     * A diagnostic entry generated by Intellisense.
     */
    VSDiagnosticTag.IntellisenseError = -2;
    /**
     * A diagnostic entry that could be generated from both builds and Intellisense.
     *
     * Diagnostic entries tagged with PotentialDuplicate will be hidden
     * in the error list if the error list is displaying build and intellisense errors.
     */
    VSDiagnosticTag.PotentialDuplicate = -3;
    /**
     * A diagnostic entry that is never displayed in the error list.
     */
    VSDiagnosticTag.HiddenInErrorList = -4;
    /**
     * A diagnostic entry that is always displayed in the error list.
     */
    VSDiagnosticTag.VisibleInErrorList = -5;
    /**
     * A diagnostic entry that is never displayed in the editor.
     */
    VSDiagnosticTag.HiddenInEditor = -6;
    /**
     * No tooltip is shown for the Diagnostic entry in the editor.
     */
    VSDiagnosticTag.SuppressEditorToolTip = -7;
    /**
     * A diagnostic entry that is represented in the editor as an Edit and Continue error.
     */
    VSDiagnosticTag.EditAndContinueError = -8;
    /**
     * A diagnostic entry that is represented in the editor as a Task List item (View -> Task List)
     */
    VSDiagnosticTag.TaskItem = -9;
})(VSDiagnosticTag || (exports.VSDiagnosticTag = VSDiagnosticTag = {}));
/*
 * DiagnosticRank values that are specific to Visual Studio.
 * These must match the values in https://dev.azure.com/devdiv/DevDiv/_git/vslanguageserverclient?path=/src/product/Protocol/LanguageServer.Protocol.Extensions/VSDiagnosticRank.cs&version=GBdevelop&_a=contents
 */
var VSDiagnosticRank;
(function (VSDiagnosticRank) {
    VSDiagnosticRank.Highest = 100;
    VSDiagnosticRank.High = 200;
    VSDiagnosticRank.Default = 300;
    VSDiagnosticRank.Low = 400;
    VSDiagnosticRank.Lowest = 500;
})(VSDiagnosticRank || (exports.VSDiagnosticRank = VSDiagnosticRank = {}));
class LanguageServerBase {
    constructor(serverOptions, connection) {
        var _a, _b;
        this.serverOptions = serverOptions;
        this.connection = connection;
        this._lastTriggerKind = vscode_languageserver_1.CompletionTriggerKind.Invoked;
        this._initialized = false;
        this.client = {
            hasConfigurationCapability: false,
            hasVisualStudioExtensionsCapability: false,
            hasWorkspaceFoldersCapability: false,
            hasWatchFileCapability: false,
            hasWatchFileRelativePathCapability: false,
            hasActiveParameterCapability: false,
            hasSignatureLabelOffsetCapability: false,
            hasHierarchicalDocumentSymbolCapability: false,
            hasWindowProgressCapability: false,
            hasGoToDeclarationCapability: false,
            hasDocumentChangeCapability: false,
            hasDocumentAnnotationCapability: false,
            hasCompletionCommitCharCapability: false,
            hoverContentFormat: vscode_languageserver_1.MarkupKind.PlainText,
            completionDocFormat: vscode_languageserver_1.MarkupKind.PlainText,
            completionSupportsSnippet: false,
            signatureDocFormat: vscode_languageserver_1.MarkupKind.PlainText,
            supportsDeprecatedDiagnosticTag: false,
            supportsUnnecessaryDiagnosticTag: false,
            supportsTaskItemDiagnosticTag: false,
            completionItemResolveSupportsAdditionalTextEdits: false,
        };
        this.openFileMap = new Map();
        // The URIs for which diagnostics are reported
        this.documentsWithDiagnostics = new Set();
        this._dynamicFeatures = new dynamicFeature_1.DynamicFeatures();
        // Stash the base directory into a global variable.
        // This must happen before fs.getModulePath().
        global.__rootDirectory = serverOptions.rootDirectory.getFilePath();
        this.console.info(`${serverOptions.productName} language server ${serverOptions.version && serverOptions.version + ' '}starting`);
        this.console.info(`Server root directory: ${serverOptions.rootDirectory}`);
        this.fs = this.serverOptions.serviceProvider.fs();
        this.caseSensitiveDetector = this.serverOptions.serviceProvider.get(serviceKeys_1.ServiceKeys.caseSensitivityDetector);
        this.workspaceFactory = new workspaceFactory_1.WorkspaceFactory(this.console, 
        /* isWeb */ false, this.createAnalyzerServiceForWorkspace.bind(this), this.isPythonPathImmutable.bind(this), this.onWorkspaceCreated.bind(this), this.onWorkspaceRemoved.bind(this), this.serviceProvider);
        // Set the working directory to a known location within
        // the extension directory. Otherwise the execution of
        // python can have unintended and surprising results.
        const moduleDirectory = this.fs.getModulePath();
        if (moduleDirectory && this.fs.existsSync(moduleDirectory)) {
            this.fs.chdir(moduleDirectory);
        }
        // Set up callbacks.
        this.setupConnection((_a = serverOptions.supportedCommands) !== null && _a !== void 0 ? _a : [], (_b = serverOptions.supportedCodeActions) !== null && _b !== void 0 ? _b : []);
        this._progressReporter = new progressReporter_1.ProgressReportTracker(this.createProgressReporter());
        // Listen on the connection.
        this.connection.listen();
    }
    get console() {
        return this.serverOptions.serviceProvider.console();
    }
    // Provides access to the client's window.
    get window() {
        return this.connection.window;
    }
    get supportAdvancedEdits() {
        return this.client.hasDocumentChangeCapability && this.client.hasDocumentAnnotationCapability;
    }
    get serviceProvider() {
        return this.serverOptions.serviceProvider;
    }
    dispose() {
        var _a;
        this.workspaceFactory.clear();
        this.openFileMap.clear();
        this._dynamicFeatures.unregister();
        (_a = this._workspaceFoldersChangedDisposable) === null || _a === void 0 ? void 0 : _a.dispose();
    }
    // Creates a service instance that's used for analyzing a
    // program within a workspace.
    createAnalyzerService(name, services, libraryReanalysisTimeProvider) {
        var _a;
        this.console.info(`Starting service instance "${name}"`);
        const serviceId = (0, service_1.getNextServiceId)(name);
        const service = new service_1.AnalyzerService(name, this.serverOptions.serviceProvider, {
            console: this.console,
            hostFactory: this.createHost.bind(this),
            importResolverFactory: this.createImportResolver.bind(this),
            backgroundAnalysis: services ? services.backgroundAnalysis : this.createBackgroundAnalysis(serviceId),
            maxAnalysisTime: this.serverOptions.maxAnalysisTimeInForeground,
            backgroundAnalysisProgramFactory: this.createBackgroundAnalysisProgram.bind(this),
            cancellationProvider: this.serverOptions.cancellationProvider,
            libraryReanalysisTimeProvider,
            serviceId,
            fileSystem: (_a = services === null || services === void 0 ? void 0 : services.fs) !== null && _a !== void 0 ? _a : this.serverOptions.serviceProvider.fs(),
        });
        service.setCompletionCallback((results) => this.onAnalysisCompletedHandler(service.fs, results));
        return service;
    }
    async getWorkspaces() {
        const workspaces = this.workspaceFactory.items();
        for (const workspace of workspaces) {
            await workspace.isInitialized.promise;
        }
        return workspaces;
    }
    async getWorkspaceForFile(fileUri, pythonPath) {
        return this.workspaceFactory.getWorkspaceForFile(fileUri, pythonPath);
    }
    async getContainingWorkspacesForFile(fileUri) {
        return this.workspaceFactory.getContainingWorkspacesForFile(fileUri);
    }
    reanalyze() {
        this.workspaceFactory.items().forEach((workspace) => {
            workspace.service.invalidateAndForceReanalysis(backgroundAnalysisProgram_1.InvalidatedReason.Reanalyzed);
        });
    }
    restart() {
        this.workspaceFactory.items().forEach((workspace) => {
            workspace.service.restart();
        });
    }
    updateSettingsForAllWorkspaces() {
        const tasks = [];
        this.workspaceFactory.items().forEach((workspace) => {
            // Updating settings can change workspace's file ownership. Make workspace uninitialized so that
            // features can wait until workspace gets new settings.
            // the file's ownership can also changed by `pyrightconfig.json` changes, but those are synchronous
            // operation, so it won't affect this.
            workspace.isInitialized = workspace.isInitialized.reset();
            tasks.push(this.updateSettingsForWorkspace(workspace, workspace.isInitialized));
        });
        Promise.all(tasks).then(() => {
            this._dynamicFeatures.register();
        });
    }
    async updateSettingsForWorkspace(workspace, status, serverSettings) {
        var _a;
        try {
            status === null || status === void 0 ? void 0 : status.markCalled();
            serverSettings = serverSettings !== null && serverSettings !== void 0 ? serverSettings : (await this.getSettings(workspace));
            // Set logging level first.
            this.console.level = (_a = serverSettings.logLevel) !== null && _a !== void 0 ? _a : console_1.LogLevel.Info;
            // Apply the new path to the workspace (before restarting the service).
            serverSettings.pythonPath = this.workspaceFactory.applyPythonPath(workspace, serverSettings.pythonPath ? serverSettings.pythonPath : undefined);
            this._dynamicFeatures.update(serverSettings);
            // Then use the updated settings to restart the service.
            this.updateOptionsAndRestartService(workspace, serverSettings);
            workspace.disableLanguageServices = !!serverSettings.disableLanguageServices;
            workspace.disableTaggedHints = !!serverSettings.disableTaggedHints;
            workspace.disableOrganizeImports = !!serverSettings.disableOrganizeImports;
        }
        finally {
            // Don't use workspace.isInitialized directly since it might have been
            // reset due to pending config change event.
            // The workspace is now open for business.
            status === null || status === void 0 ? void 0 : status.resolve();
        }
    }
    updateOptionsAndRestartService(workspace, serverSettings, typeStubTargetImportName) {
        var _a;
        analyzerServiceExecutor_1.AnalyzerServiceExecutor.runWithOptions(workspace, serverSettings, typeStubTargetImportName);
        workspace.searchPathsToWatch = (_a = workspace.service.librarySearchUrisToWatch) !== null && _a !== void 0 ? _a : [];
    }
    isPythonPathImmutable(fileUri) {
        // This function is called to determine if the file is using
        // a special pythonPath separate from a workspace or not.
        // The default is no.
        return false;
    }
    async getConfiguration(scopeUri, section) {
        if (this.client.hasConfigurationCapability) {
            const item = {};
            if (scopeUri !== undefined) {
                item.scopeUri = scopeUri.toString();
            }
            if (section !== undefined) {
                item.section = section;
            }
            return this.connection.workspace.getConfiguration(item);
        }
        if (this.defaultClientConfig) {
            return (0, collectionUtils_1.getNestedProperty)(this.defaultClientConfig, section);
        }
        return undefined;
    }
    isOpenFilesOnly(diagnosticMode) {
        return diagnosticMode !== 'workspace';
    }
    getSeverityOverrides(value) {
        const enumValue = (0, configOptions_1.parseDiagLevel)(value);
        if (!enumValue) {
            return undefined;
        }
        if ((0, commandLineOptions_1.getDiagnosticSeverityOverrides)().includes(enumValue)) {
            return enumValue;
        }
        return undefined;
    }
    getDiagnosticRuleName(value) {
        const enumValue = value;
        if ((0, configOptions_1.getDiagLevelDiagnosticRules)().includes(enumValue)) {
            return enumValue;
        }
        return undefined;
    }
    createBackgroundAnalysisProgram(serviceId, serviceProvider, configOptions, importResolver, backgroundAnalysis, maxAnalysisTime) {
        return new backgroundAnalysisProgram_1.BackgroundAnalysisProgram(serviceId, serviceProvider, configOptions, importResolver, backgroundAnalysis, maxAnalysisTime, 
        /* disableChecker */ undefined);
    }
    setupConnection(supportedCommands, supportedCodeActions) {
        // After the server has started the client sends an initialize request. The server receives
        // in the passed params the rootPath of the workspace plus the client capabilities.
        this.connection.onInitialize((params) => this.initialize(params, supportedCommands, supportedCodeActions));
        this.connection.onInitialized(() => this.onInitialized());
        this.connection.onDidChangeConfiguration((params) => this.onDidChangeConfiguration(params));
        this.connection.onCodeAction((params, token) => this.executeCodeAction(params, token));
        this.connection.onDefinition(async (params, token) => this.onDefinition(params, token));
        this.connection.onDeclaration(async (params, token) => this.onDeclaration(params, token));
        this.connection.onTypeDefinition(async (params, token) => this.onTypeDefinition(params, token));
        this.connection.onReferences(async (params, token, workDoneReporter, resultReporter) => this.onReferences(params, token, workDoneReporter, resultReporter));
        this.connection.onDocumentSymbol(async (params, token) => this.onDocumentSymbol(params, token));
        this.connection.onWorkspaceSymbol(async (params, token, _, resultReporter) => this.onWorkspaceSymbol(params, token, resultReporter));
        this.connection.onHover(async (params, token) => this.onHover(params, token));
        this.connection.onDocumentHighlight(async (params, token) => this.onDocumentHighlight(params, token));
        this.connection.onSignatureHelp(async (params, token) => this.onSignatureHelp(params, token));
        this.connection.onCompletion((params, token) => this.onCompletion(params, token));
        this.connection.onCompletionResolve(async (params, token) => this.onCompletionResolve(params, token));
        this.connection.onPrepareRename(async (params, token) => this.onPrepareRenameRequest(params, token));
        this.connection.onRenameRequest(async (params, token) => this.onRenameRequest(params, token));
        const callHierarchy = this.connection.languages.callHierarchy;
        callHierarchy.onPrepare(async (params, token) => this.onCallHierarchyPrepare(params, token));
        callHierarchy.onIncomingCalls(async (params, token) => this.onCallHierarchyIncomingCalls(params, token));
        callHierarchy.onOutgoingCalls(async (params, token) => this.onCallHierarchyOutgoingCalls(params, token));
        this.connection.onDidOpenTextDocument(async (params) => this.onDidOpenTextDocument(params));
        this.connection.onDidChangeTextDocument(async (params) => this.onDidChangeTextDocument(params));
        this.connection.onDidCloseTextDocument(async (params) => this.onDidCloseTextDocument(params));
        this.connection.onDidChangeWatchedFiles((params) => this.onDidChangeWatchedFiles(params));
        this.connection.onExecuteCommand(async (params, token, reporter) => this.onExecuteCommand(params, token, reporter));
        this.connection.onShutdown(async (token) => this.onShutdown(token));
    }
    async initialize(params, supportedCommands, supportedCodeActions) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19;
        if (params.locale) {
            (0, localize_1.setLocaleOverride)(params.locale);
        }
        const capabilities = params.capabilities;
        this.client.hasConfigurationCapability = !!((_a = capabilities.workspace) === null || _a === void 0 ? void 0 : _a.configuration);
        this.client.hasWatchFileCapability = !!((_c = (_b = capabilities.workspace) === null || _b === void 0 ? void 0 : _b.didChangeWatchedFiles) === null || _c === void 0 ? void 0 : _c.dynamicRegistration);
        this.client.hasWatchFileRelativePathCapability =
            !!((_e = (_d = capabilities.workspace) === null || _d === void 0 ? void 0 : _d.didChangeWatchedFiles) === null || _e === void 0 ? void 0 : _e.relativePatternSupport);
        this.client.hasWorkspaceFoldersCapability = !!((_f = capabilities.workspace) === null || _f === void 0 ? void 0 : _f.workspaceFolders);
        this.client.hasVisualStudioExtensionsCapability = !!capabilities._vs_supportsVisualStudioExtensions;
        this.client.hasActiveParameterCapability =
            !!((_j = (_h = (_g = capabilities.textDocument) === null || _g === void 0 ? void 0 : _g.signatureHelp) === null || _h === void 0 ? void 0 : _h.signatureInformation) === null || _j === void 0 ? void 0 : _j.activeParameterSupport);
        this.client.hasSignatureLabelOffsetCapability =
            !!((_o = (_m = (_l = (_k = capabilities.textDocument) === null || _k === void 0 ? void 0 : _k.signatureHelp) === null || _l === void 0 ? void 0 : _l.signatureInformation) === null || _m === void 0 ? void 0 : _m.parameterInformation) === null || _o === void 0 ? void 0 : _o.labelOffsetSupport);
        this.client.hasHierarchicalDocumentSymbolCapability =
            !!((_q = (_p = capabilities.textDocument) === null || _p === void 0 ? void 0 : _p.documentSymbol) === null || _q === void 0 ? void 0 : _q.hierarchicalDocumentSymbolSupport);
        this.client.hasDocumentChangeCapability =
            !!((_s = (_r = capabilities.workspace) === null || _r === void 0 ? void 0 : _r.workspaceEdit) === null || _s === void 0 ? void 0 : _s.documentChanges) &&
                !!((_t = capabilities.workspace.workspaceEdit) === null || _t === void 0 ? void 0 : _t.resourceOperations);
        this.client.hasDocumentAnnotationCapability = !!((_v = (_u = capabilities.workspace) === null || _u === void 0 ? void 0 : _u.workspaceEdit) === null || _v === void 0 ? void 0 : _v.changeAnnotationSupport);
        this.client.hasCompletionCommitCharCapability =
            !!((_y = (_x = (_w = capabilities.textDocument) === null || _w === void 0 ? void 0 : _w.completion) === null || _x === void 0 ? void 0 : _x.completionList) === null || _y === void 0 ? void 0 : _y.itemDefaults) &&
                !!((_z = capabilities.textDocument.completion.completionItem) === null || _z === void 0 ? void 0 : _z.commitCharactersSupport);
        this.client.hoverContentFormat = this._getCompatibleMarkupKind((_1 = (_0 = capabilities.textDocument) === null || _0 === void 0 ? void 0 : _0.hover) === null || _1 === void 0 ? void 0 : _1.contentFormat);
        this.client.completionDocFormat = this._getCompatibleMarkupKind((_4 = (_3 = (_2 = capabilities.textDocument) === null || _2 === void 0 ? void 0 : _2.completion) === null || _3 === void 0 ? void 0 : _3.completionItem) === null || _4 === void 0 ? void 0 : _4.documentationFormat);
        this.client.completionSupportsSnippet = !!((_7 = (_6 = (_5 = capabilities.textDocument) === null || _5 === void 0 ? void 0 : _5.completion) === null || _6 === void 0 ? void 0 : _6.completionItem) === null || _7 === void 0 ? void 0 : _7.snippetSupport);
        this.client.signatureDocFormat = this._getCompatibleMarkupKind((_10 = (_9 = (_8 = capabilities.textDocument) === null || _8 === void 0 ? void 0 : _8.signatureHelp) === null || _9 === void 0 ? void 0 : _9.signatureInformation) === null || _10 === void 0 ? void 0 : _10.documentationFormat);
        const supportedDiagnosticTags = ((_13 = (_12 = (_11 = capabilities.textDocument) === null || _11 === void 0 ? void 0 : _11.publishDiagnostics) === null || _12 === void 0 ? void 0 : _12.tagSupport) === null || _13 === void 0 ? void 0 : _13.valueSet) || [];
        this.client.supportsUnnecessaryDiagnosticTag = supportedDiagnosticTags.some((tag) => tag === vscode_languageserver_1.DiagnosticTag.Unnecessary);
        this.client.supportsDeprecatedDiagnosticTag = supportedDiagnosticTags.some((tag) => tag === vscode_languageserver_1.DiagnosticTag.Deprecated);
        // if the client is running in VS, it always supports task item diagnostics
        this.client.supportsTaskItemDiagnosticTag = this.client.hasVisualStudioExtensionsCapability;
        this.client.hasWindowProgressCapability = !!((_14 = capabilities.window) === null || _14 === void 0 ? void 0 : _14.workDoneProgress);
        this.client.hasGoToDeclarationCapability = !!((_15 = capabilities.textDocument) === null || _15 === void 0 ? void 0 : _15.declaration);
        this.client.completionItemResolveSupportsAdditionalTextEdits =
            !!((_19 = (_18 = (_17 = (_16 = capabilities.textDocument) === null || _16 === void 0 ? void 0 : _16.completion) === null || _17 === void 0 ? void 0 : _17.completionItem) === null || _18 === void 0 ? void 0 : _18.resolveSupport) === null || _19 === void 0 ? void 0 : _19.properties.some((p) => p === 'additionalTextEdits'));
        // Create a service instance for each of the workspace folders.
        this.workspaceFactory.handleInitialize(params);
        if (this.client.hasWatchFileCapability) {
            this.addDynamicFeature(new fileWatcherDynamicFeature_1.FileWatcherDynamicFeature(this.connection, this.client.hasWatchFileRelativePathCapability, this.fs, this.workspaceFactory));
        }
        const result = {
            capabilities: {
                textDocumentSync: vscode_languageserver_1.TextDocumentSyncKind.Incremental,
                definitionProvider: { workDoneProgress: true },
                declarationProvider: { workDoneProgress: true },
                typeDefinitionProvider: { workDoneProgress: true },
                referencesProvider: { workDoneProgress: true },
                documentSymbolProvider: { workDoneProgress: true },
                workspaceSymbolProvider: { workDoneProgress: true },
                hoverProvider: { workDoneProgress: true },
                documentHighlightProvider: { workDoneProgress: true },
                renameProvider: { prepareProvider: true, workDoneProgress: true },
                completionProvider: {
                    triggerCharacters: this.client.hasVisualStudioExtensionsCapability
                        ? ['.', '[', '@', '"', "'"]
                        : ['.', '[', '"', "'"],
                    resolveProvider: true,
                    workDoneProgress: true,
                    completionItem: {
                        labelDetailsSupport: true,
                    },
                },
                signatureHelpProvider: {
                    triggerCharacters: ['(', ',', ')'],
                    workDoneProgress: true,
                },
                codeActionProvider: {
                    codeActionKinds: supportedCodeActions,
                    workDoneProgress: true,
                },
                executeCommandProvider: {
                    commands: supportedCommands,
                    workDoneProgress: true,
                },
                callHierarchyProvider: true,
                workspace: {
                    workspaceFolders: {
                        supported: true,
                        changeNotifications: true,
                    },
                },
            },
        };
        return result;
    }
    onInitialized() {
        // Mark as initialized. We need this to make sure to
        // not send config updates before this point.
        this._initialized = true;
        if (!this.client.hasWorkspaceFoldersCapability) {
            // If folder capability is not supported, initialize ones given by onInitialize.
            this.updateSettingsForAllWorkspaces();
            return;
        }
        this._workspaceFoldersChangedDisposable = this.connection.workspace.onDidChangeWorkspaceFolders((event) => {
            this.workspaceFactory.handleWorkspaceFoldersChanged(event);
            this._dynamicFeatures.register();
        });
        this._dynamicFeatures.register();
    }
    onDidChangeConfiguration(params) {
        this.console.log(`Received updated settings`);
        if (params === null || params === void 0 ? void 0 : params.settings) {
            this.defaultClientConfig = params === null || params === void 0 ? void 0 : params.settings;
        }
        this.updateSettingsForAllWorkspaces();
    }
    async onDefinition(params, token) {
        return this.getDefinitions(params, token, this.client.hasGoToDeclarationCapability ? definitionProvider_1.DefinitionFilter.PreferSource : definitionProvider_1.DefinitionFilter.All, (workspace, filePath, position, filter, token) => workspace.service.run((program) => {
            return new definitionProvider_1.DefinitionProvider(program, filePath, position, filter, token).getDefinitions();
        }, token));
    }
    async onDeclaration(params, token) {
        return this.getDefinitions(params, token, this.client.hasGoToDeclarationCapability ? definitionProvider_1.DefinitionFilter.PreferStubs : definitionProvider_1.DefinitionFilter.All, (workspace, filePath, position, filter, token) => workspace.service.run((program) => {
            return new definitionProvider_1.DefinitionProvider(program, filePath, position, filter, token).getDefinitions();
        }, token));
    }
    async onTypeDefinition(params, token) {
        return this.getDefinitions(params, token, definitionProvider_1.DefinitionFilter.All, (workspace, filePath, position, _, token) => workspace.service.run((program) => {
            return new definitionProvider_1.TypeDefinitionProvider(program, filePath, position, token).getDefinitions();
        }, token));
    }
    async getDefinitions(params, token, filter, getDefinitionsFunc) {
        this.recordUserInteractionTime();
        const uri = this.convertLspUriStringToUri(params.textDocument.uri);
        const workspace = await this.getWorkspaceForFile(uri);
        if (workspace.disableLanguageServices) {
            return undefined;
        }
        const locations = getDefinitionsFunc(workspace, uri, params.position, filter, token);
        if (!locations) {
            return undefined;
        }
        return locations
            .filter((loc) => this.canNavigateToFile(loc.uri, workspace.service.fs))
            .map((loc) => vscode_languageserver_1.Location.create((0, uriUtils_1.convertUriToLspUriString)(workspace.service.fs, loc.uri), loc.range));
    }
    async onReferences(params, token, workDoneReporter, resultReporter, createDocumentRange, convertToLocation) {
        if (this._pendingFindAllRefsCancellationSource) {
            this._pendingFindAllRefsCancellationSource.cancel();
            this._pendingFindAllRefsCancellationSource = undefined;
        }
        // VS Code doesn't support cancellation of "find all references".
        // We provide a progress bar a cancellation button so the user can cancel
        // any long-running actions.
        const progress = await this.getProgressReporter(workDoneReporter, localize_1.Localizer.CodeAction.findingReferences(), token);
        const source = progress.source;
        this._pendingFindAllRefsCancellationSource = source;
        try {
            const uri = this.convertLspUriStringToUri(params.textDocument.uri);
            const workspace = await this.getWorkspaceForFile(uri);
            if (workspace.disableLanguageServices) {
                return;
            }
            return workspace.service.run((program) => {
                return new referencesProvider_1.ReferencesProvider(program, source.token, createDocumentRange, convertToLocation).reportReferences(uri, params.position, params.context.includeDeclaration, resultReporter);
            }, token);
        }
        finally {
            progress.reporter.done();
            source.dispose();
        }
    }
    async onDocumentSymbol(params, token) {
        this.recordUserInteractionTime();
        const uri = this.convertLspUriStringToUri(params.textDocument.uri);
        const workspace = await this.getWorkspaceForFile(uri);
        if (workspace.disableLanguageServices) {
            return undefined;
        }
        return workspace.service.run((program) => {
            return new documentSymbolProvider_1.DocumentSymbolProvider(program, uri, this.client.hasHierarchicalDocumentSymbolCapability, { includeAliases: false }, token).getSymbols();
        }, token);
    }
    onWorkspaceSymbol(params, token, resultReporter) {
        const result = new workspaceSymbolProvider_1.WorkspaceSymbolProvider(this.workspaceFactory.items(), resultReporter, params.query, token).reportSymbols();
        return Promise.resolve(result);
    }
    async onHover(params, token) {
        const uri = this.convertLspUriStringToUri(params.textDocument.uri);
        const workspace = await this.getWorkspaceForFile(uri);
        return workspace.service.run((program) => {
            return new hoverProvider_1.HoverProvider(program, uri, params.position, this.client.hoverContentFormat, token).getHover();
        }, token);
    }
    async onDocumentHighlight(params, token) {
        const uri = this.convertLspUriStringToUri(params.textDocument.uri);
        const workspace = await this.getWorkspaceForFile(uri);
        return workspace.service.run((program) => {
            return new documentHighlightProvider_1.DocumentHighlightProvider(program, uri, params.position, token).getDocumentHighlight();
        }, token);
    }
    async onSignatureHelp(params, token) {
        const uri = this.convertLspUriStringToUri(params.textDocument.uri);
        const workspace = await this.getWorkspaceForFile(uri);
        if (workspace.disableLanguageServices) {
            return;
        }
        return workspace.service.run((program) => {
            return new signatureHelpProvider_1.SignatureHelpProvider(program, uri, params.position, this.client.signatureDocFormat, this.client.hasSignatureLabelOffsetCapability, this.client.hasActiveParameterCapability, params.context, program.serviceProvider.docStringService(), token).getSignatureHelp();
        }, token);
    }
    setCompletionIncomplete(params, completions) {
        var _a, _b;
        // We set completion incomplete for the first invocation and next consecutive call,
        // but after that we mark it as completed so the client doesn't repeatedly call back.
        // We mark the first one as incomplete because completion could be invoked without
        // any meaningful character provided, such as an explicit completion invocation (ctrl+space)
        // or a period. That might cause us to not include some items (e.g., auto-imports).
        // The next consecutive call provides some characters to help us to pick
        // better completion items. After that, we are not going to introduce new items,
        // so we can let the client to do the filtering and caching.
        const completionIncomplete = this._lastTriggerKind !== vscode_languageserver_1.CompletionTriggerKind.TriggerForIncompleteCompletions ||
            ((_a = params.context) === null || _a === void 0 ? void 0 : _a.triggerKind) !== vscode_languageserver_1.CompletionTriggerKind.TriggerForIncompleteCompletions;
        this._lastTriggerKind = (_b = params.context) === null || _b === void 0 ? void 0 : _b.triggerKind;
        if (completions) {
            completions.isIncomplete = completionIncomplete;
        }
    }
    async onCompletion(params, token) {
        const uri = this.convertLspUriStringToUri(params.textDocument.uri);
        const workspace = await this.getWorkspaceForFile(uri);
        if (workspace.disableLanguageServices) {
            return null;
        }
        return workspace.service.run((program) => {
            var _a;
            const completions = new completionProvider_1.CompletionProvider(program, uri, params.position, {
                format: this.client.completionDocFormat,
                snippet: this.client.completionSupportsSnippet,
                lazyEdit: false,
                triggerCharacter: (_a = params === null || params === void 0 ? void 0 : params.context) === null || _a === void 0 ? void 0 : _a.triggerCharacter,
            }, token).getCompletions();
            this.setCompletionIncomplete(params, completions);
            return completions;
        }, token);
    }
    // Cancellation bugs in vscode and LSP:
    // https://github.com/microsoft/vscode-languageserver-node/issues/615
    // https://github.com/microsoft/vscode/issues/95485
    //
    // If resolver throws cancellation exception, LSP and VSCode
    // cache that result and never call us back.
    async onCompletionResolve(params, token) {
        const completionItemData = (0, lspUtils_1.fromLSPAny)(params.data);
        if (completionItemData && completionItemData.uri) {
            const uri = uri_1.Uri.parse(completionItemData.uri, this.caseSensitiveDetector);
            const workspace = await this.getWorkspaceForFile(uri);
            workspace.service.run((program) => {
                return new completionProvider_1.CompletionProvider(program, uri, completionItemData.position, {
                    format: this.client.completionDocFormat,
                    snippet: this.client.completionSupportsSnippet,
                    lazyEdit: false,
                }, token).resolveCompletionItem(params);
            }, token);
        }
        return params;
    }
    async onPrepareRenameRequest(params, token) {
        const uri = this.convertLspUriStringToUri(params.textDocument.uri);
        const isUntitled = uri.isUntitled();
        const workspace = await this.getWorkspaceForFile(uri);
        if (workspace.disableLanguageServices) {
            return null;
        }
        return workspace.service.run((program) => {
            return new renameProvider_1.RenameProvider(program, uri, params.position, token).canRenameSymbol(workspace.kinds.includes(workspaceFactory_1.WellKnownWorkspaceKinds.Default), isUntitled);
        }, token);
    }
    async onRenameRequest(params, token) {
        const uri = this.convertLspUriStringToUri(params.textDocument.uri);
        const isUntitled = uri.isUntitled();
        const workspace = await this.getWorkspaceForFile(uri);
        if (workspace.disableLanguageServices) {
            return;
        }
        return workspace.service.run((program) => {
            return new renameProvider_1.RenameProvider(program, uri, params.position, token).renameSymbol(params.newName, workspace.kinds.includes(workspaceFactory_1.WellKnownWorkspaceKinds.Default), isUntitled);
        }, token);
    }
    async onCallHierarchyPrepare(params, token) {
        const uri = this.convertLspUriStringToUri(params.textDocument.uri);
        const workspace = await this.getWorkspaceForFile(uri);
        if (workspace.disableLanguageServices) {
            return null;
        }
        return workspace.service.run((program) => {
            return new callHierarchyProvider_1.CallHierarchyProvider(program, uri, params.position, token).onPrepare();
        }, token);
    }
    async onCallHierarchyIncomingCalls(params, token) {
        const uri = this.convertLspUriStringToUri(params.item.uri);
        const workspace = await this.getWorkspaceForFile(uri);
        if (workspace.disableLanguageServices) {
            return null;
        }
        return workspace.service.run((program) => {
            return new callHierarchyProvider_1.CallHierarchyProvider(program, uri, params.item.range.start, token).getIncomingCalls();
        }, token);
    }
    async onCallHierarchyOutgoingCalls(params, token) {
        const uri = this.convertLspUriStringToUri(params.item.uri);
        const workspace = await this.getWorkspaceForFile(uri);
        if (workspace.disableLanguageServices) {
            return null;
        }
        return workspace.service.run((program) => {
            return new callHierarchyProvider_1.CallHierarchyProvider(program, uri, params.item.range.start, token).getOutgoingCalls();
        }, token);
    }
    async onDidOpenTextDocument(params, ipythonMode = sourceFile_1.IPythonMode.None) {
        const uri = this.convertLspUriStringToUri(params.textDocument.uri);
        let doc = this.openFileMap.get(uri.key);
        if (doc) {
            // We shouldn't get an open text document request for an already-opened doc.
            this.console.error(`Received redundant open text document command for ${uri}`);
            vscode_languageserver_textdocument_1.TextDocument.update(doc, [{ text: params.textDocument.text }], params.textDocument.version);
        }
        else {
            doc = vscode_languageserver_textdocument_1.TextDocument.create(params.textDocument.uri, 'python', params.textDocument.version, params.textDocument.text);
        }
        this.openFileMap.set(uri.key, doc);
        // Send this open to all the workspaces that might contain this file.
        const workspaces = await this.getContainingWorkspacesForFile(uri);
        workspaces.forEach((w) => {
            w.service.setFileOpened(uri, params.textDocument.version, params.textDocument.text, ipythonMode);
        });
    }
    async onDidChangeTextDocument(params, ipythonMode = sourceFile_1.IPythonMode.None) {
        this.recordUserInteractionTime();
        const uri = this.convertLspUriStringToUri(params.textDocument.uri);
        const doc = this.openFileMap.get(uri.key);
        if (!doc) {
            // We shouldn't get a change text request for a closed doc.
            this.console.error(`Received change text document command for closed file ${uri}`);
            return;
        }
        vscode_languageserver_textdocument_1.TextDocument.update(doc, params.contentChanges, params.textDocument.version);
        const newContents = doc.getText();
        // Send this change to all the workspaces that might contain this file.
        const workspaces = await this.getContainingWorkspacesForFile(uri);
        workspaces.forEach((w) => {
            w.service.updateOpenFileContents(uri, params.textDocument.version, newContents, ipythonMode);
        });
    }
    async onDidCloseTextDocument(params) {
        const uri = this.convertLspUriStringToUri(params.textDocument.uri);
        // Send this close to all the workspaces that might contain this file.
        const workspaces = await this.getContainingWorkspacesForFile(uri);
        workspaces.forEach((w) => {
            w.service.setFileClosed(uri);
        });
        this.openFileMap.delete(uri.key);
    }
    onDidChangeWatchedFiles(params) {
        params.changes.forEach((change) => {
            const filePath = this.fs.realCasePath(this.convertLspUriStringToUri(change.uri));
            const eventType = change.type === 1 ? 'add' : 'change';
            this.serverOptions.fileWatcherHandler.onFileChange(eventType, filePath);
        });
    }
    async onExecuteCommand(params, token, reporter) {
        // Cancel running command if there is one.
        if (this._pendingCommandCancellationSource) {
            this._pendingCommandCancellationSource.cancel();
            this._pendingCommandCancellationSource = undefined;
        }
        const executeCommand = async (token) => {
            const result = await this.executeCommand(params, token);
            if (vscode_languageserver_1.WorkspaceEdit.is(result)) {
                // Tell client to apply edits.
                // Do not await; the client isn't expecting a result.
                this.connection.workspace.applyEdit({
                    label: `Command '${params.command}'`,
                    edit: result,
                    metadata: { isRefactoring: this.isRefactoringCommand(params.command) },
                });
            }
            if (commandResult_1.CommandResult.is(result)) {
                // Tell client to apply edits.
                // Await so that we return after the edit is complete.
                await this.connection.workspace.applyEdit({
                    label: result.label,
                    edit: result.edits,
                    metadata: { isRefactoring: this.isRefactoringCommand(params.command) },
                });
            }
            return result;
        };
        if (this.isLongRunningCommand(params.command)) {
            // Create a progress dialog for long-running commands.
            const progress = await this.getProgressReporter(reporter, localize_1.Localizer.CodeAction.executingCommand(), token);
            const source = progress.source;
            this._pendingCommandCancellationSource = source;
            try {
                const result = await executeCommand(source.token);
                return result;
            }
            finally {
                progress.reporter.done();
                source.dispose();
            }
        }
        else {
            const result = await executeCommand(token);
            return result;
        }
    }
    onShutdown(token) {
        // Shutdown remaining workspaces.
        this.workspaceFactory.clear();
        // Stop tracking all open files.
        this.openFileMap.clear();
        return Promise.resolve();
    }
    convertDiagnostics(fs, fileDiagnostics) {
        return [
            {
                uri: (0, uriUtils_1.convertUriToLspUriString)(fs, fileDiagnostics.fileUri),
                version: fileDiagnostics.version,
                diagnostics: this._convertDiagnostics(fs, fileDiagnostics.diagnostics),
            },
        ];
    }
    getDiagCode(_diag, rule) {
        return rule;
    }
    onAnalysisCompletedHandler(fs, results) {
        // Send the computed diagnostics to the client.
        results.diagnostics.forEach((fileDiag) => {
            if (!this.canNavigateToFile(fileDiag.fileUri, fs)) {
                return;
            }
            this.sendDiagnostics(this.convertDiagnostics(fs, fileDiag));
        });
        if (!this._progressReporter.isEnabled(results)) {
            // Make sure to disable progress bar if it is currently active.
            // This can happen if a user changes typeCheckingMode in the middle
            // of analysis.
            // end() is noop if there is no active progress bar.
            this._progressReporter.end();
            return;
        }
        // Update progress.
        const progressMessage = this.getProgressMessage(results);
        if (progressMessage) {
            this._progressReporter.begin();
            this._progressReporter.report(progressMessage);
        }
        else {
            this._progressReporter.end();
        }
    }
    getProgressMessage(results) {
        const fileCount = results.requiringAnalysisCount.files;
        if (fileCount === 0) {
            return undefined;
        }
        const progressMessage = fileCount === 1
            ? localize_1.Localizer.CodeAction.filesToAnalyzeOne()
            : localize_1.Localizer.CodeAction.filesToAnalyzeCount().format({
                count: fileCount,
            });
        return progressMessage;
    }
    onWorkspaceCreated(workspace) {
        // Update settings on this workspace (but only if initialize has happened)
        if (this._initialized) {
            this.updateSettingsForWorkspace(workspace, workspace.isInitialized).ignoreErrors();
        }
        // Otherwise the initialize completion should cause settings to be updated on all workspaces.
    }
    onWorkspaceRemoved(workspace) {
        const documentsWithDiagnosticsList = [...this.documentsWithDiagnostics];
        const otherWorkspaces = this.workspaceFactory.items().filter((w) => w !== workspace);
        for (const uri of documentsWithDiagnosticsList) {
            const fileUri = this.convertLspUriStringToUri(uri);
            if (workspace.service.isTracked(fileUri)) {
                // Do not clean up diagnostics for files tracked by multiple workspaces
                if (otherWorkspaces.some((w) => w.service.isTracked(fileUri))) {
                    continue;
                }
                this.sendDiagnostics([
                    {
                        uri: uri,
                        diagnostics: [],
                    },
                ]);
            }
        }
    }
    createAnalyzerServiceForWorkspace(name, uri, kinds, services) {
        // 5 seconds default
        const defaultBackOffTime = 5 * 1000;
        return this.createAnalyzerService(name, services, () => defaultBackOffTime);
    }
    recordUserInteractionTime() {
        // Tell all of the services that the user is actively
        // interacting with one or more editors, so they should
        // back off from performing any work.
        this.workspaceFactory.items().forEach((workspace) => {
            workspace.service.recordUserInteractionTime();
        });
    }
    getDocumentationUrlForDiagnostic(diag) {
        const rule = diag.getRule();
        if (rule) {
            // Configuration.md is configured to have a link for every rule name.
            return `https://github.com/microsoft/pyright/blob/main/docs/configuration.md#${rule}`;
        }
        return undefined;
    }
    canNavigateToFile(path, fs) {
        return (0, navigationUtils_1.canNavigateToFile)(fs, path);
    }
    async getProgressReporter(reporter, title, token) {
        // This is a bit ugly, but we need to determine whether the provided reporter
        // is an actual client-side progress reporter or a dummy (null) progress reporter
        // created by the LSP library. If it's the latter, we'll create a server-initiated
        // progress reporter.
        if (reporter.constructor !== nullProgressReporter.constructor) {
            return { reporter: reporter, source: (0, cancellationUtils_1.CancelAfter)(this.serverOptions.cancellationProvider, token) };
        }
        const serverInitiatedReporter = await this.connection.window.createWorkDoneProgress();
        serverInitiatedReporter.begin(title, 
        /* percentage */ undefined, 
        /* message */ undefined, 
        /* cancellable */ true);
        return {
            reporter: serverInitiatedReporter,
            source: (0, cancellationUtils_1.CancelAfter)(this.serverOptions.cancellationProvider, token, serverInitiatedReporter.token),
        };
    }
    sendDiagnostics(params) {
        for (const param of params) {
            if (param.diagnostics.length === 0) {
                this.documentsWithDiagnostics.delete(param.uri);
            }
            else {
                this.documentsWithDiagnostics.add(param.uri);
            }
            this.connection.sendDiagnostics(param);
        }
    }
    convertLspUriStringToUri(uri) {
        return uri_1.Uri.parse(uri, this.serverOptions.serviceProvider);
    }
    addDynamicFeature(feature) {
        this._dynamicFeatures.add(feature);
    }
    _getCompatibleMarkupKind(clientSupportedFormats) {
        const serverSupportedFormats = [vscode_languageserver_1.MarkupKind.PlainText, vscode_languageserver_1.MarkupKind.Markdown];
        for (const format of clientSupportedFormats !== null && clientSupportedFormats !== void 0 ? clientSupportedFormats : []) {
            if (serverSupportedFormats.includes(format)) {
                return format;
            }
        }
        return vscode_languageserver_1.MarkupKind.PlainText;
    }
    _convertDiagnostics(fs, diags) {
        const convertedDiags = [];
        diags.forEach((diag) => {
            const severity = convertCategoryToSeverity(diag.category);
            const rule = diag.getRule();
            const code = this.getDiagCode(diag, rule);
            const vsDiag = vscode_languageserver_1.Diagnostic.create(diag.range, diag.message, severity, code, this.serverOptions.productName);
            if (diag.category === 3 /* DiagnosticCategory.UnusedCode */ ||
                diag.category === 4 /* DiagnosticCategory.UnreachableCode */) {
                vsDiag.tags = [vscode_languageserver_1.DiagnosticTag.Unnecessary];
                vsDiag.severity = vscode_languageserver_1.DiagnosticSeverity.Hint;
                // If the client doesn't support "unnecessary" tags, don't report unused code.
                if (!this.client.supportsUnnecessaryDiagnosticTag) {
                    return;
                }
            }
            else if (diag.category === 5 /* DiagnosticCategory.Deprecated */) {
                vsDiag.tags = [vscode_languageserver_1.DiagnosticTag.Deprecated];
                vsDiag.severity = vscode_languageserver_1.DiagnosticSeverity.Hint;
                // If the client doesn't support "deprecated" tags, don't report.
                if (!this.client.supportsDeprecatedDiagnosticTag) {
                    return;
                }
            }
            else if (diag.category === 6 /* DiagnosticCategory.TaskItem */) {
                vsDiag.tags = [VSDiagnosticTag.TaskItem];
                // Map the task item priority to a value VS will understand
                // and store it in the diagnostic.
                // The Diagnostic type is defined in a protocol that we can't change,
                // so we just dynamically create the vsDiag._vs_diagnosticRank property at runtime,
                // which is what VS is looking for.
                switch (diag.priority) {
                    case diagnostic_1.TaskListPriority.High:
                        vsDiag._vs_diagnosticRank = VSDiagnosticRank.High;
                        break;
                    case diagnostic_1.TaskListPriority.Normal:
                        vsDiag._vs_diagnosticRank = VSDiagnosticRank.Default;
                        break;
                    case diagnostic_1.TaskListPriority.Low:
                        vsDiag._vs_diagnosticRank = VSDiagnosticRank.Low;
                        break;
                }
                // if the client doesn't support "task item" tags, don't report.
                if (!this.client.supportsTaskItemDiagnosticTag) {
                    return;
                }
            }
            if (rule) {
                const ruleDocUrl = this.getDocumentationUrlForDiagnostic(diag);
                if (ruleDocUrl) {
                    vsDiag.codeDescription = {
                        href: ruleDocUrl,
                    };
                }
            }
            const relatedInfo = diag.getRelatedInfo();
            if (relatedInfo.length > 0) {
                vsDiag.relatedInformation = relatedInfo
                    .filter((info) => this.canNavigateToFile(info.uri, fs))
                    .map((info) => vscode_languageserver_1.DiagnosticRelatedInformation.create(vscode_languageserver_1.Location.create((0, uriUtils_1.convertUriToLspUriString)(fs, info.uri), info.range), info.message));
            }
            convertedDiags.push(vsDiag);
        });
        function convertCategoryToSeverity(category) {
            switch (category) {
                case 0 /* DiagnosticCategory.Error */:
                    return vscode_languageserver_1.DiagnosticSeverity.Error;
                case 1 /* DiagnosticCategory.Warning */:
                    return vscode_languageserver_1.DiagnosticSeverity.Warning;
                case 2 /* DiagnosticCategory.Information */:
                case 6 /* DiagnosticCategory.TaskItem */: // task items only show up in the task list if they are information or above.
                    return vscode_languageserver_1.DiagnosticSeverity.Information;
                case 3 /* DiagnosticCategory.UnusedCode */:
                case 4 /* DiagnosticCategory.UnreachableCode */:
                case 5 /* DiagnosticCategory.Deprecated */:
                    return vscode_languageserver_1.DiagnosticSeverity.Hint;
            }
        }
        return convertedDiags;
    }
}
exports.LanguageServerBase = LanguageServerBase;
//# sourceMappingURL=languageServerBase.js.map